<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QueueJoy ‚Äî Status</title>

  <!-- Tailwind CDN for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />

  <style>
    :root{
      --purple-1: #8b5cf6;
      --purple-2: #a78bfa;
      --bg-1: #f8f7ff;
    }
    * { box-sizing: border-box; }
    body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; background: linear-gradient(135deg,#f7f6ff,#f1efff); min-height:100vh; display:flex; align-items:center; justify-content:center; padding:20px; margin:0;}
    .card{max-width:720px; width:100%; border-radius:16px; background:rgba(255,255,255,0.96); box-shadow:0 18px 50px rgba(99,102,241,0.12); padding:28px; position:relative;}
    .logo-circle{width:72px;height:72px;border-radius:18px; background: linear-gradient(135deg,var(--purple-1),var(--purple-2)); display:flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:22px; box-shadow:0 10px 30px rgba(139,92,246,0.18);}
    .small-pill{padding:8px 12px;border-radius:12px;background:rgba(139,92,246,0.08); color:var(--purple-1); font-weight:700;}
    .progress-track{height:18px;border-radius:12px;background:#f1f1f1; overflow:hidden;}
    .progress-fill{height:100%; background: linear-gradient(90deg,var(--purple-1),var(--purple-2)); display:flex; align-items:center; justify-content:flex-end; padding-right:10px; color:white; font-weight:700; transition:width .65s cubic-bezier(.2,.9,.2,1);}
    .glass{background:rgba(247,245,255,0.7); border-radius:12px; padding:14px; border:1px solid rgba(139,92,246,0.06);}
    .circle-btn{width:44px;height:44px;border-radius:999px;background:white;display:inline-flex;align-items:center;justify-content:center;border:none;box-shadow:0 8px 28px rgba(15,23,42,0.06);cursor:pointer}
    .onboarding-modal{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;padding:16px;z-index:60;backdrop-filter:blur(4px)}
    .onboarding-panel{width:100%;max-width:420px;background:white;border-radius:16px;padding:22px;box-shadow:0 30px 80px rgba(12,12,30,0.4);}
    .spinner-inline{width:16px;height:16px;border:2px solid rgba(255,255,255,0.3);border-top-color:white;border-radius:50%;animation:spin .8s linear infinite; display:inline-block;margin-right:8px}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* Responsive tweaks */
    @media (max-width:640px){
      .card{padding:18px}
      .logo-circle{width:56px;height:56px;font-size:18px}
    }

    /* ad panel */
    .ad-panel{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;width:100%;max-width:420px;padding:10px;background:white;border-radius:12px;box-shadow:0 18px 48px rgba(12,12,30,0.08);z-index:40;display:none}
    .ad-media{width:100%;height:96px;object-fit:cover;border-radius:8px;display:block}

    /* connection banner dismiss */
    .connection-dismiss{background:transparent;border:none;font-size:18px;line-height:1;cursor:pointer;color:#6b7280}
  </style>
</head>
<body>

  <!-- Onboarding / Telegram Connect Modal (optional) -->
  <div id="onboardingModal" class="onboarding-modal" style="display:none" aria-hidden="true">
    <div class="onboarding-panel" role="dialog" aria-modal="true" aria-labelledby="onboardTitle">
      <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px">
        <div style="width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--purple-1),var(--purple-2));display:flex;align-items:center;justify-content:center;color:white;font-weight:700">‚úâÔ∏è</div>
        <div>
          <h3 id="onboardTitle" style="margin:0;font-size:18px;color:#111827;font-weight:700">Connect Telegram</h3>
          <div style="color:#6b7280;font-size:13px">Get notified via Telegram ‚Äî you don‚Äôt need to keep this page open.</div>
        </div>
      </div>

      <div style="margin-top:8px;color:#374151">
        <p style="margin:0 0 10px 0">Tap <strong>Connect via Telegram</strong> to open the secure link. If your browser blocks popups, allow popups for this site.</p>
      </div>

      <div style="display:flex;gap:10px;margin-top:14px">
        <button id="onboardingConnectBtn" class="btn" style="background:linear-gradient(135deg,var(--purple-1),var(--purple-2));color:white;border:none;padding:10px 14px;border-radius:10px;font-weight:700">Connect via Telegram</button>
        <button id="onboardingSkipBtn" class="btn" style="background:transparent;border:1px solid #e6e6f6;padding:10px 14px;border-radius:10px;font-weight:700;color:#374151">Maybe later</button>
      </div>
      <p id="onboardingStatus" style="margin-top:10px;color:#6b7280;font-size:13px"></p>
    </div>
  </div>

  <!-- Main card -->
  <div class="card" role="main" aria-live="polite">
    <div style="position:absolute; right:18px; top:18px; display:flex; gap:8px; z-index:10;">
      <button id="gameBtn" title="Game" class="circle-btn" aria-label="Game">üéÆ</button>
      <button id="connectTopBtn" title="Connect Telegram" class="circle-btn" aria-label="Connect Telegram">‚úâÔ∏è</button>
    </div>

    <div style="display:flex; gap:18px; align-items:center; justify-content:center; flex-direction:column">
      <div class="logo-circle" id="brandBlob">QJ</div>
      <h1 style="font-size:20px;margin-top:8px;color:#111827;font-weight:800">You are now in line</h1>
      <p style="margin:0;color:#6b7280;max-width:560px;text-align:center">Welcome. We‚Äôll notify you when it‚Äôs your turn. Connect Telegram to receive notifications even with this page closed.</p>
    </div>

    <!-- progress bar -->
    <div style="margin-top:18px">
      <div class="progress-track" aria-hidden="true">
        <div id="progressFill" class="progress-fill" style="width:6%"> <span id="progressLabel" style="font-size:12px;padding-left:8px;padding-right:8px;border-radius:8px;background:rgba(0,0,0,0.12);margin-left:auto">6%</span></div>
      </div>
    </div>

    <!-- main numbers -->
    <div style="margin-top:18px;display:grid;grid-template-columns:1fr 1fr;gap:14px">
      <div class="glass">
        <p style="margin:0;color:#6b7280;font-weight:700;font-size:13px">Your Number</p>
        <div id="yourNumber" style="font-size:34px;font-weight:900;color:var(--purple-1);margin-top:8px">‚Äî</div>
      </div>

      <div class="glass">
        <p style="margin:0;color:#6b7280;font-weight:700;font-size:13px">Now Serving</p>
        <div id="nowServing" style="font-size:34px;font-weight:900;color:#374151;margin-top:8px">‚Äî</div>
      </div>
    </div>

    <!-- people ahead / estimated wait -->
    <div style="margin-top:14px;display:grid;grid-template-columns:1fr 1fr;gap:14px">
      <div class="glass" style="text-align:left">
        <p style="margin:0;color:#6b7280;font-weight:700;font-size:13px">People Ahead</p>
        <div id="peopleAhead" style="font-size:22px;font-weight:800;color:#111827;margin-top:8px">‚Äî</div>
      </div>

      <div class="glass" style="text-align:left">
        <p style="margin:0;color:#6b7280;font-weight:700;font-size:13px">Estimated Wait</p>
        <div id="estimatedWait" style="font-size:22px;font-weight:800;color:var(--purple-1);margin-top:8px">‚Äî</div>
      </div>
    </div>

    <!-- connection banner (dismissible) -->
    <div id="connectionBanner" style="margin-top:18px;padding:14px;border-radius:12px;background:linear-gradient(90deg,rgba(167,139,250,0.07),rgba(139,92,246,0.03));border:1px solid rgba(139,92,246,0.06);display:flex;align-items:center;gap:12px" role="region" aria-label="Notification connection">
      <div style="width:42px;height:42px;border-radius:10px;background:linear-gradient(135deg,var(--purple-1),var(--purple-2));display:flex;align-items:center;justify-content:center;color:white">üîî</div>
      <div style="flex:1">
        <div id="connectionBannerText" style="font-weight:700;color:#111827">Checking notification status...</div>
        <div style="color:#6b7280;font-size:13px" id="connectionBannerSub">You can connect Telegram for push notifications.</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="connectBtn" class="btn" style="background:linear-gradient(135deg,var(--purple-1),var(--purple-2));color:white;border:none;padding:9px 12px;border-radius:10px;font-weight:700">Connect</button>
        <button id="dismissBannerBtn" class="connection-dismiss" title="Dismiss notifications banner" aria-label="Dismiss notifications">‚úï</button>
      </div>
    </div>

    <div id="errorBox" style="display:none;margin-top:12px;padding:12px;border-radius:10px;background:#fff5f5;border:1px solid #ffe4e6;color:#b91c1c;font-weight:700;text-align:center" role="status" aria-live="polite"></div>
  </div>

  <!-- Ad panel (bottom center) -->
  <div id="adPanel" class="ad-panel" aria-hidden="true">
    <div style="font-size:12px;color:#9CA3AF;text-align:center;margin-bottom:6px">Advertisement</div>
    <div id="adContainer"><!-- ad injected here --></div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getDatabase, ref, onValue, off, get } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

    // === CONFIG / ENDPOINTS ===
    const TELEGRAM_BOT_URL = 'https://t.me/QueueJoyBot';
    const CREATE_LINK_ENDPOINT = '/.netlify/functions/createTelegramLink'; // optional - we'll sanitize result
    // Firebase config (kept from your original)
    const firebaseConfig = {
      apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
      authDomain: "queue-joy-aa21b.firebaseapp.com",
      databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "queue-joy-aa21b",
      storageBucket: "queue-joy-aa21b.firebasedestorage.app",
      messagingSenderId: "950240394209",
      appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
    };

    // === INIT ===
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // DOM refs
    const yourNumberEl = document.getElementById('yourNumber');
    const nowServingEl = document.getElementById('nowServing');
    const peopleAheadEl = document.getElementById('peopleAhead');
    const estimatedWaitEl = document.getElementById('estimatedWait');
    const progressFill = document.getElementById('progressFill');
    const progressLabel = document.getElementById('progressLabel');
    const connectionBannerText = document.getElementById('connectionBannerText');
    const connectionBannerSub = document.getElementById('connectionBannerSub');
    const connectBtn = document.getElementById('connectBtn');
    const connectTopBtn = document.getElementById('connectTopBtn');
    const onboardingModal = document.getElementById('onboardingModal');
    const onboardingConnectBtn = document.getElementById('onboardingConnectBtn');
    const onboardingSkipBtn = document.getElementById('onboardingSkipBtn');
    const onboardingStatus = document.getElementById('onboardingStatus');
    const adPanel = document.getElementById('adPanel');
    const adContainer = document.getElementById('adContainer');
    const dismissBannerBtn = document.getElementById('dismissBannerBtn');
    const errorBox = document.getElementById('errorBox');
    const brandBlob = document.getElementById('brandBlob');

    // state
    let currentQueueKey = null;
    let currentQueueData = null;
    let currentCounterId = null;
    let avgServiceMsBySeries = {}; // { CAP: { sum, count, avg } }
    let avgServiceTimeFromSettingsMinutes = null; // fallback from settings
    let createdListeners = []; // store refs for cleanup

    // helpers
    function showError(msg){
      errorBox.style.display = 'block';
      errorBox.textContent = msg;
      setTimeout(()=> errorBox.style.display = 'none', 6000);
    }

    function setTelegramConnectedUI(connected){
      if(connected){
        connectionBannerText.textContent = "Connected ‚Äî you'll get Telegram notifications";
        connectionBannerSub.textContent = "You can close the page; Telegram will notify you when it's your turn.";
        connectBtn.textContent = "Connected";
        connectBtn.disabled = true;
      } else {
        connectionBannerText.textContent = "Not connected ‚Äî get Telegram notifications";
        connectionBannerSub.textContent = "Connect to receive notifications even when this page is closed.";
        connectBtn.textContent = "Connect";
        connectBtn.disabled = false;
      }
    }

    // parse queueId like CAP009 -> { series:'CAP', number:9 }
    function parseQueueId(qid){
      if(!qid) return null;
      const m = String(qid).match(/^([A-Za-z]+)(\d+)$/);
      if(!m) return null;
      return { series: m[1].toUpperCase(), number: Number(m[2]) };
    }
    function zeroPad(num, len){
      return String(num).padStart(len,'0');
    }
    function digitsFromQueueId(qid){
      if(!qid) return 3;
      const m = String(qid).match(/(\d+)$/);
      return m? m[1].length:3;
    }

    // --- AD PANEL ---
    function clearAd(){
      adContainer.innerHTML = '';
      adPanel.style.display = 'none';
      adPanel.setAttribute('aria-hidden','true');
    }
    function showAdFromUrl(url){
      clearAd();
      if(!url) return;
      const trimmed = String(url).trim();
      const isVideo = /\.(mp4|webm|ogg)(\?.*)?$/i.test(trimmed) || trimmed.startsWith('data:video/');
      adPanel.style.display = 'block';
      adPanel.setAttribute('aria-hidden','false');
      if(isVideo){
        const v = document.createElement('video');
        v.src = trimmed;
        v.autoplay = true;
        v.muted = true;
        v.loop = true;
        v.playsInline = true;
        v.className = 'ad-media';
        v.setAttribute('playsinline','');
        v.setAttribute('muted','');
        adContainer.appendChild(v);
        v.play().catch(()=> v.setAttribute('controls',''));
      } else {
        const img = document.createElement('img');
        img.src = trimmed;
        img.className = 'ad-media';
        img.alt = 'Advertisement';
        img.onerror = ()=> clearAd();
        adContainer.appendChild(img);
      }
    }

    // --- serviceEvents -> compute per-series average serviceMs
    const serviceEventsRef = ref(db, 'serviceEvents');
    onValue(serviceEventsRef, (snap) => {
      avgServiceMsBySeries = {};
      if(!snap.exists()) return;
      const all = snap.val();
      for(const k in all){
        if(!Object.prototype.hasOwnProperty.call(all,k)) continue;
        const ev = all[k];
        if(!ev || !ev.series) continue;
        const s = String(ev.series).toUpperCase();
        const ms = Number(ev.serviceMs) || 0;
        if(!avgServiceMsBySeries[s]) avgServiceMsBySeries[s] = { sum: 0, count: 0 };
        avgServiceMsBySeries[s].sum += ms;
        avgServiceMsBySeries[s].count += 1;
      }
      for(const s in avgServiceMsBySeries){
        const o = avgServiceMsBySeries[s];
        o.avg = o.count ? Math.round(o.sum / o.count) : null;
      }
    }, (err)=>{ console.warn('serviceEvents read err', err); });

    // fallback global avg (minutes)
    const settingsRef = ref(db, 'settings/avgServiceTime');
    onValue(settingsRef, (snap) => {
      if(snap && snap.exists()){
        const v = Number(snap.val());
        if(Number.isFinite(v) && v>0) avgServiceTimeFromSettingsMinutes = v;
        else avgServiceTimeFromSettingsMinutes = null;
      } else avgServiceTimeFromSettingsMinutes = null;
      // recompute when setting changes
      computePeopleAheadAndEstimate();
    });

    // load logo (if set)
    const logoRef = ref(db, 'settings/logoUrl');
    onValue(logoRef, (snap)=>{
      if(snap && snap.exists()){
        const v = String(snap.val() || '');
        if(!v) return;
        const img = new Image();
        img.onload = ()=>{ brandBlob.innerHTML=''; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover'; img.style.borderRadius='12px'; brandBlob.appendChild(img); };
        img.onerror = ()=> { brandBlob.textContent = 'QJ'; };
        img.src = v;
      } else {
        brandBlob.textContent = 'QJ';
      }
    });

    // --- Telegram connect (never send /start) ---
    // We will try to call a server endpoint for a dedicated link, but we will never open a link containing start=.
    async function generateLinkFromServer(){
      try {
        const res = await fetch(CREATE_LINK_ENDPOINT, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ queueKey: currentQueueKey }) });
        if(!res.ok) return null;
        const j = await res.json().catch(()=>null);
        return j && j.link ? String(j.link) : null;
      } catch(e){ return null; }
    }
    function stripStartParam(url){
      try{
        const u = new URL(url);
        u.searchParams.delete('start');
        return u.toString();
      }catch(e){ return url; }
    }
    async function openConnectLink(){
      // attempt to get server link, but don't use start= param
      let link = null;
      try {
        link = await generateLinkFromServer();
      } catch(e){ link = null; }
      if(!link) link = TELEGRAM_BOT_URL;
      link = stripStartParam(link);
      window.open(link, '_blank', 'noopener,noreferrer');
    }

    // --- Dismiss connection banner persist ---
    const BANNER_DISMISSED_KEY = 'queuejoy_banner_dismissed_v1';
    function isBannerDismissed(){ return localStorage.getItem(BANNER_DISMISSED_KEY) === '1'; }
    function setBannerDismissed(){ localStorage.setItem(BANNER_DISMISSED_KEY,'1'); document.getElementById('connectionBanner').style.display='none'; }

    // --- Redirect detection ---
    function detectAndRedirectIfCalled(counterData){
      if(!currentQueueData) return;
      try{
        // If our queue entry's status says called/serving, redirect
        const status = currentQueueData && currentQueueData.status ? String(currentQueueData.status) : '';
        if(status === 'serving' || status === 'called'){
          redirectToYourTurn();
          return;
        }

        // If counter data includes prefix & nowServing number and matches our queueId, redirect
        if(counterData){
          const prefix = counterData.prefix ? String(counterData.prefix) : null;
          const nowServingNum = (counterData.nowServing !== undefined && counterData.nowServing !== null) ? Number(counterData.nowServing) : null;
          if(prefix && Number.isFinite(nowServingNum)){
            const digits = digitsFromQueueId(currentQueueData.queueId || currentQueueKey);
            // some counters include prefix with or without space; compare canonical forms
            const nowServingFull = `${String(prefix)}${zeroPad(nowServingNum, digits)}`;
            const normalizedFull = String(nowServingFull).replace(/\s+/g,'').toUpperCase();
            const myQ = String(currentQueueData.queueId || currentQueueKey).replace(/\s+/g,'').toUpperCase();
            if(normalizedFull === myQ){
              redirectToYourTurn();
              return;
            }
          }
          // some counters may expose nowServing as full queueId string; compare directly
          const nowServingRaw = counterData.nowServingRaw || counterData.nowServingAs || counterData.nowServingQueueId;
          if(nowServingRaw && String(nowServingRaw).toUpperCase().replace(/\s+/g,'') === String(currentQueueData.queueId || currentQueueKey).toUpperCase().replace(/\s+/g,'')){
            redirectToYourTurn();
            return;
          }
        }
      }catch(e){ console.warn('redirect detect error', e); }
    }

    function redirectToYourTurn(){
      try{
        const targetQ = encodeURIComponent(currentQueueData.queueId || currentQueueKey);
        const url = `${location.origin}/your_turn.html?queueId=${targetQ}`;
        connectionBannerText.textContent = "It's your turn ‚Äî redirecting...";
        // short delay for UX then redirect
        setTimeout(()=> { window.location.href = url; }, 350);
      }catch(e){ console.warn('redirect fail', e); }
    }

    // --- Compute people ahead & ETA ---
    async function computePeopleAheadAndEstimate(){
      try {
        if(!currentQueueData) return;
        const allSnap = await get(ref(db, 'queue'));
        if(!allSnap.exists()){
          peopleAheadEl.textContent = '0';
          estimatedWaitEl.textContent = 'Less than a minute';
          updateProgress(6);
          return;
        }
        const all = allSnap.val();
        const myTime = Number(currentQueueData.timestamp) || 0;
        const myQueueId = String(currentQueueData.queueId || '');
        const parsed = parseQueueId(myQueueId);
        const mySeries = parsed ? parsed.series : (currentQueueData.series ? String(currentQueueData.series).toUpperCase() : null);

        // Build waiting list (same series if possible) ordered by timestamp
        const waitingList = Object.keys(all)
          .map(k => ({ key:k, data: all[k], ts: Number(all[k].timestamp) || 0 }))
          .filter(item => {
            if(!item.data) return false;
            const qid = item.data.queueId || '';
            const status = item.data.status || '';
            if(status !== 'waiting' && status !== 'queued') return false;
            if(mySeries){
              return String(qid).toUpperCase().startsWith(mySeries);
            }
            return true;
          })
          .sort((a,b) => a.ts - b.ts);

        const positionIndex = waitingList.findIndex(w => String(w.data.queueId) === myQueueId);
        const totalWaitingForSeries = waitingList.length;
        const peopleAhead = positionIndex >= 0 ? positionIndex : waitingList.filter(w => w.ts < myTime).length;
        peopleAheadEl.textContent = String(peopleAhead);

        // choose avg ms: serviceEvents avg -> global settings -> fallback 3min
        let avgMs = null;
        if(mySeries && avgServiceMsBySeries[mySeries] && avgServiceMsBySeries[mySeries].avg) avgMs = avgServiceMsBySeries[mySeries].avg;
        if(!avgMs && avgServiceTimeFromSettingsMinutes) avgMs = avgServiceTimeFromSettingsMinutes * 60 * 1000;
        if(!avgMs) avgMs = 3 * 60 * 1000;

        const estMs = Math.round(peopleAhead * avgMs);
        const estMinutes = Math.max(0, Math.round(estMs / 60000));
        estimatedWaitEl.textContent = (peopleAhead === 0) ? 'Now' : `${peopleAhead} person${peopleAhead>1?'s':''} ‚Äî approx ${formatMinutes(estMinutes)}`;

        // progress percent based on position within same series waiting list (more accurate)
        let percent = 6;
        if(positionIndex >= 0 && totalWaitingForSeries > 0){
          // ratio how far towards front (1 means at front)
          const ratio = 1 - (positionIndex / Math.max(1, totalWaitingForSeries - 1));
          percent = Math.round(6 + Math.min(92, Math.max(0, ratio * 92)));
        } else {
          // fallback bucket method
          const bucket = Math.max(1, peopleAhead + 2);
          percent = Math.max(6, Math.min(98, Math.round(((bucket - peopleAhead) / bucket) * 100)));
        }
        updateProgress(percent, estMinutes);
      } catch(e){
        console.warn('estimate compute error', e);
        showError('Error computing estimated wait');
      }
    }

    function formatMinutes(m){ const mm = Math.max(0, Math.round(m)); if(mm === 0) return 'Less than a minute'; if(mm < 60) return `${mm} min${mm>1?'s':''}`; const hrs = Math.floor(mm/60), rem = mm%60; return rem === 0 ? `${hrs} hr${hrs>1?'s':''}` : `${hrs} hr ${rem} min`; }

    function updateProgress(p, estMinutes){
      p = Math.max(4, Math.min(100, Math.round(p)));
      progressFill.style.width = p + '%';
      progressLabel.textContent = p >= 95 ? 'Almost' : p + '%';
      if(typeof estMinutes === 'number') progressLabel.title = `Approx ${formatMinutes(estMinutes)} remaining`;
    }

    // --- Listen for ad changes + initial read ---
    const adRef = ref(db, 'settings/adImage');
    onValue(adRef, (snap) => {
      const v = (snap && snap.exists()) ? snap.val() : null;
      if(v) showAdFromUrl(v); else clearAd();
    });

    (async function initAdOnce(){ try{ const s = await get(ref(db,'settings/adImage')); if(s && s.exists()) showAdFromUrl(s.val()); }catch(e){} })();

    // --- Subscriptions for queue entry + counters ---
    document.addEventListener('DOMContentLoaded', async () => {
      const params = new URLSearchParams(window.location.search);
      const incoming = params.get('queueId') || params.get('key') || params.get('q');
      if(!incoming){
        showError('Queue ID missing ‚Äî redirecting...');
        setTimeout(()=> window.location.href = 'index.html', 1200);
        return;
      }

      // Try direct key or search for queueId field fallback
      let foundKey = null;
      try{
        const direct = await get(ref(db, `queue/${incoming}`));
        if(direct.exists()) foundKey = incoming;
        else {
          const all = await get(ref(db,'queue'));
          if(all.exists()){
            const val = all.val();
            for(const k in val){ if(val[k] && (val[k].queueId === incoming || k === incoming)){ foundKey = k; break; } }
          }
        }
      }catch(e){ console.warn('db read error', e); }

      if(!foundKey){
        showError('Queue entry not found');
        setTimeout(()=> window.location.href = 'index.html', 1200);
        return;
      }
      currentQueueKey = foundKey;

      // subscribe to this entry
      const qRef = ref(db, `queue/${currentQueueKey}`);
      const qListener = onValue(qRef, (snap)=>{
        if(!snap.exists()){
          showError('Queue entry removed'); return;
        }
        currentQueueData = snap.val();
        yourNumberEl.textContent = currentQueueData.queueId || '--';
        setTelegramConnectedUI(!!currentQueueData.telegramConnected);

        // subscribe to counter changes if present
        const counterId = currentQueueData.counterId || null;
        if(counterId && counterId !== currentCounterId){
          if(currentCounterId) try{ off(ref(db, `counters/${currentCounterId}`)); }catch(e){}
          currentCounterId = counterId;
          const counterRef = ref(db, `counters/${counterId}`);
          const listener = onValue(counterRef, (cSnap)=>{
            if(!cSnap.exists()) return;
            const cData = cSnap.val();
            // prefer a formatted prefix+nowServing if prefix exists
            const prefix = cData && cData.prefix ? String(cData.prefix) : null;
            const nowServingNum = (cData && (cData.nowServing !== undefined && cData.nowServing !== null)) ? Number(cData.nowServing) : null;
            const digits = digitsFromQueueId(currentQueueData.queueId);
            let nowServingText = '--';
            if(prefix && Number.isFinite(nowServingNum)) nowServingText = `${String(prefix)} ${zeroPad(nowServingNum, digits)}`;
            else if(Number.isFinite(nowServingNum)) nowServingText = String(nowServingNum);
            else nowServingText = (cData && cData.nowServing) ? String(cData.nowServing) : '--';
            nowServingEl.textContent = nowServingText;

            detectAndRedirectIfCalled(cData);
            computePeopleAheadAndEstimate();
          });
          createdListeners.push({ ref: counterRef, listener });
        } else {
          if(!counterId) nowServingEl.textContent = '--';
        }

        computePeopleAheadAndEstimate();
      }, (err)=>{ console.warn('queue entry onValue err', err); });
      createdListeners.push({ ref: qRef, listener: qListener });

      // watch whole queue so we update estimates live
      const allQueueRef = ref(db, 'queue');
      const allListener = onValue(allQueueRef, ()=> computePeopleAheadAndEstimate());
      createdListeners.push({ ref: allQueueRef, listener: allListener });

      // apply banner dismissal from storage
      if(isBannerDismissed()) document.getElementById('connectionBanner').style.display='none';

      // cleanup on unload
      window.addEventListener('beforeunload', () => {
        try{
          for(const item of createdListeners){
            try{ off(item.ref, item.listener); }catch(e){}
          }
        }catch(e){}
      });
    });

    // --- Connect button flows (onboarding modal & direct) ---
    connectBtn.addEventListener('click', () => {
      // show onboarding modal to explain, then open link
      onboardingModal.style.display = 'flex';
      onboardingModal.setAttribute('aria-hidden','false');
      onboardingStatus.textContent = '';
    });
    connectTopBtn.addEventListener('click', ()=> {
      onboardingModal.style.display = 'flex';
      onboardingModal.setAttribute('aria-hidden','false');
    });

    onboardingConnectBtn.addEventListener('click', async () => {
      onboardingStatus.textContent = 'Opening Telegram...';
      onboardingConnectBtn.disabled = true;
      try{
        await openConnectLink();
        onboardingStatus.textContent = 'Opened Telegram';
        setTimeout(()=> { onboardingModal.style.display = 'none'; onboardingModal.setAttribute('aria-hidden','true'); }, 700);
      }catch(e){
        onboardingStatus.textContent = 'Failed to open link ‚Äî try again';
        onboardingConnectBtn.disabled = false;
      }
    });
    onboardingSkipBtn.addEventListener('click', () => {
      onboardingModal.style.display = 'none';
      onboardingModal.setAttribute('aria-hidden','true');
    });

    // dismiss banner
    dismissBannerBtn.addEventListener('click', ()=> {
      setBannerDismissed();
    });

    // quick game link
    document.getElementById('gameBtn').addEventListener('click', ()=> window.location.href = 'https://queuejoy.netlify.app/game.html');

    // allow connect modal to be opened via connect top icon
    document.getElementById('connectTopBtn').addEventListener('click', ()=> onboardingModal.style.display = 'flex');

    // Small helper: initial progress
    updateProgress(6);
  </script>
</body>
</html>
