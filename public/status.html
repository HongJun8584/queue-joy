<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QueueJoy â€” Status</title>

  <!-- NOTE: for production compile Tailwind into static CSS. This CDN is fine for testing. -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet" />

  <style>
    :root{ --p1:#7c3aed; --p2:#a78bfa; --bg1:#f7f6ff; --glass: rgba(250,246,255,0.9); }
    html,body{height:100%}
    body{ margin:0; font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial; background:linear-gradient(135deg,var(--bg1),#f3f0ff); display:flex; align-items:center; justify-content:center; padding:18px }

    .card{ width:100%; max-width:980px; border-radius:18px; padding:22px; background:linear-gradient(180deg,rgba(255,255,255,0.98),rgba(250,247,255,0.98)); box-shadow:0 30px 80px rgba(99,102,241,0.08); position:relative; overflow:hidden; transition:transform .3s }
    .card:hover{ transform:translateY(-6px) }

    .top-actions{ position:absolute; right:18px; top:18px; display:flex; gap:10px; z-index:20 }
    .action-btn{ display:inline-flex; align-items:center; gap:8px; padding:.55rem .9rem; border-radius:12px; font-weight:700; cursor:pointer; border:none; box-shadow:0 10px 26px rgba(2,6,23,0.06) }
    .action-game{ background:linear-gradient(135deg,#ff8a00,#ff4500); color:white }
    .action-connect{ background:linear-gradient(135deg,var(--p1),var(--p2)); color:white }

    .brand{ display:flex; gap:16px; align-items:center; justify-content:center; flex-wrap:wrap }
    .brand-blob{ width:84px; height:84px; border-radius:14px; overflow:hidden; display:flex; align-items:center; justify-content:center; font-weight:900; color:white; box-shadow:0 18px 50px rgba(124,58,237,0.14); background:linear-gradient(135deg,var(--p1),var(--p2)) }
    .brand-blob img{ width:100%; height:100%; object-fit:cover }

    .muted{ color:#6b7280 }

    /* Progress */
    .progress-wrap{ margin-top:18px }
    .progress-track{ height:20px; border-radius:999px; background:linear-gradient(180deg,#f3f2fb,#f7f6ff); border:1px solid rgba(99,102,241,0.06); overflow:hidden; position:relative }
    .progress-fill{ height:100%; display:flex; align-items:center; justify-content:flex-end; padding-right:10px; font-weight:800; color:white; transition:width .7s cubic-bezier(.2,.9,.2,1); position:relative; background:linear-gradient(90deg,var(--p1),var(--p2)); }
    .progress-stripes{ position:absolute; inset:0; background-image:repeating-linear-gradient(45deg, rgba(255,255,255,0.06) 0 8px, transparent 8px 16px); opacity:0.22; animation:moveStripes 1.6s linear infinite }
    @keyframes moveStripes{ from{ background-position:0 0 } to{ background-position:40px 0 } }

    .glass{ background:var(--glass); border-radius:12px; padding:14px; border:1px solid rgba(139,92,246,0.04) }
    .shimmer{ position:relative; overflow:hidden }
    .shimmer::after{ content:''; position:absolute; left:-120%; top:0; width:40%; height:100%; background:linear-gradient(90deg, transparent, rgba(255,255,255,0.45), transparent); transform:skewX(-20deg); animation:shimmer 2.2s linear infinite }
    @keyframes shimmer{ 100%{ left:120% } }

    /* Ad panel - full width, non-dismissible */
    .ad-panel{ position:fixed; left:0; right:0; bottom:0; height:140px; background:#000; display:flex; align-items:center; justify-content:center; z-index:60 }
    .ad-media{ max-width:100%; max-height:100%; object-fit:cover }

    @media (max-width:720px){ .card{ padding:16px } .brand-blob{ width:64px; height:64px } .top-actions{ right:12px; top:12px } .ad-panel{ height:110px } }
  </style>
</head>
<body>

  <main class="card" role="main" aria-live="polite">
    <div class="top-actions">
      <button id="gameBtn" class="action-btn action-game" title="Play game">
        <!-- small SVG icon + text -->
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24"><path d="M5 10h4v4H5z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M19 7l-6 10H8l4-7" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Play
      </button>

      <button id="connectBtn" class="action-btn action-connect" title="Connect via Telegram">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M21 6.5L4.5 11.5l4.5 1.6L11 19l1.6-5.9 7.4-6.6z" stroke="white" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Connect
      </button>
    </div>

    <div class="brand">
      <div id="brandBlob" class="brand-blob" aria-hidden="true"><span id="brandFallback">QJ</span></div>
      <div style="text-align:center">
        <h1 style="font-size:20px;margin:0;font-weight:900;color:#111827">You are now in line</h1>
        <p class="muted" style="margin-top:6px;max-width:640px">We'll keep you updated. Connect Telegram to receive push notifications when it's your turn.</p>
      </div>
    </div>

    <div class="progress-wrap">
      <div class="progress-track" aria-hidden="true">
        <div id="progressFill" class="progress-fill" style="width:4%;">
          <div class="progress-stripes"></div>
          <div id="progressLabel" style="font-size:12px;margin-right:8px">0%</div>
        </div>
      </div>
    </div>

    <div style="display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-top:18px">
      <div class="glass">
        <div class="muted">Your Number</div>
        <div id="yourNumber" style="font-weight:900;font-size:34px;color:var(--p1);margin-top:6px">â€”</div>
      </div>
      <div class="glass">
        <div class="muted">Now Serving</div>
        <div id="nowServing" style="font-weight:900;font-size:34px;color:#111827;margin-top:6px">â€”</div>
      </div>
    </div>

    <div style="display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-top:12px">
      <div class="glass">
        <div class="muted">People Ahead</div>
        <div id="peopleAhead" style="font-weight:800;font-size:20px;margin-top:8px">â€”</div>
      </div>
      <div class="glass shimmer">
        <div class="muted">Estimated Wait</div>
        <div id="estimatedWait" style="font-weight:800;font-size:20px;color:var(--p1);margin-top:8px">â€”</div>
      </div>
    </div>

    <div id="connectionBanner" class="glass" style="display:flex;align-items:center;gap:12px;margin-top:16px">
      <div style="width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--p1),var(--p2));display:flex;align-items:center;justify-content:center;color:white;font-weight:800">ðŸ””</div>
      <div style="flex:1">
        <div id="connectionBannerText" style="font-weight:800">Checking notification status...</div>
        <div id="connectionBannerSub" style="color:#6b7280;font-size:13px">Connect Telegram to receive notifications even with this page closed.</div>
      </div>
      <div style="min-width:120px;display:flex;gap:8px;justify-content:flex-end">
        <button id="connectMain" class="action-connect action-btn">Connect</button>
      </div>
    </div>

    <div id="error" style="display:none;margin-top:12px;padding:10px;border-radius:10px;background:#fff5f5;border:1px solid #fde2e2;color:#b91c1c;font-weight:700;text-align:center"></div>
  </main>

  <!-- AD PANEL (non-dismissible, full-width) -->
  <div id="adPanel" class="ad-panel" aria-hidden="false">
    <div id="adContainer" style="width:100%;height:100%;display:flex;align-items:center;justify-content:center"></div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getDatabase, ref, onValue, off, get } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

    // endpoints
    const TELEGRAM_BOT_URL = 'https://t.me/QueueJoyBot';

    // firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
      authDomain: "queue-joy-aa21b.firebaseapp.com",
      databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "queue-joy-aa21b",
      storageBucket: "queue-joy-aa21b.firebasedestorage.app",
      messagingSenderId: "950240394209",
      appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
    };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // DOM
    const brandBlob = document.getElementById('brandBlob');
    const brandFallback = document.getElementById('brandFallback');
    const yourNumberEl = document.getElementById('yourNumber');
    const nowServingEl = document.getElementById('nowServing');
    const peopleAheadEl = document.getElementById('peopleAhead');
    const estimatedWaitEl = document.getElementById('estimatedWait');
    const progressFill = document.getElementById('progressFill');
    const progressLabel = document.getElementById('progressLabel');
    const adContainer = document.getElementById('adContainer');
    const connectMainBtn = document.getElementById('connectMain');
    const connectBtn = document.getElementById('connectBtn');
    const gameBtn = document.getElementById('gameBtn');
    const connectionBannerText = document.getElementById('connectionBannerText');

    // state
    let currentQueueKey = null;
    let currentQueueData = null;
    let currentCounterId = null;
    let avgServiceMsBySeries = {}; // { CAP: {sum,count,avg} }
    let avgServiceTimeFromSettingsMinutes = null;

    // parse queueId like CAP009 -> { series:'CAP', number:9 }
    function parseQueueId(qid){ if(!qid) return null; const m = String(qid).match(/^([A-Za-z]+)(\d+)$/); if(!m) return null; return { series: m[1].toUpperCase(), number: Number(m[2]) }; }

    // load logo from settings/logoUrl (supports data: URL)
    const logoRef = ref(db, 'settings/logoUrl');
    onValue(logoRef, (snap)=>{ if(snap.exists()){ const v = snap.val(); const img = new Image(); img.onload = ()=>{ brandBlob.innerHTML=''; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover'; img.style.borderRadius='12px'; brandBlob.appendChild(img); brandFallback.style.display='none'; }; img.onerror=()=>{ brandFallback.style.display='block'; }; img.src = v; } else brandFallback.style.display='block'; });

    // Ad panel (non-dismissible) - supports image/video/gif/data URLs
    const adRef = ref(db, 'settings/adImage');
    onValue(adRef, (snap)=>{ if(snap.exists()) showAdFromUrl(snap.val()); else clearAd(); });
    function clearAd(){ adContainer.innerHTML = ''; }
    function showAdFromUrl(url){
      clearAd(); if(!url) return;
      const trimmed = String(url).trim();
      const isVideo = /\.(mp4|webm|ogg)(\?.*)?$/i.test(trimmed) || trimmed.startsWith('data:video/');
      if(isVideo){
        const v = document.createElement('video');
        v.src = trimmed; v.autoplay = true; v.muted = true; v.loop = true; v.playsInline = true;
        v.className = 'ad-media'; v.style.width='100%'; v.style.height='100%'; v.style.objectFit='cover';
        adContainer.appendChild(v); v.play().catch(()=> v.setAttribute('controls',''));
      } else {
        const img = document.createElement('img');
        img.src = trimmed; img.className = 'ad-media'; img.alt = 'Ad';
        img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover';
        img.onerror = ()=> clearAd(); adContainer.appendChild(img);
      }
    }

    // serviceEvents -> compute per-series average serviceMs
    const serviceEventsRef = ref(db, 'serviceEvents');
    onValue(serviceEventsRef, (snap) => {
      avgServiceMsBySeries = {};
      if(!snap.exists()) return;
      const all = snap.val();
      for(const k in all){ if(!Object.prototype.hasOwnProperty.call(all,k)) continue; const ev = all[k]; if(!ev || !ev.series) continue; const s = String(ev.series).toUpperCase(); const ms = Number(ev.serviceMs) || 0; if(!avgServiceMsBySeries[s]) avgServiceMsBySeries[s] = { sum:0, count:0 }; avgServiceMsBySeries[s].sum += ms; avgServiceMsBySeries[s].count += 1; }
      for(const s in avgServiceMsBySeries){ const o = avgServiceMsBySeries[s]; o.avg = o.count ? Math.round(o.sum / o.count) : null; }
    });

    // fallback global avg (minutes)
    const settingsRef = ref(db, 'settings/avgServiceTime');
    onValue(settingsRef, (snap)=>{ if(snap.exists()){ const v = Number(snap.val()); if(Number.isFinite(v) && v>0) avgServiceTimeFromSettingsMinutes = v; else avgServiceTimeFromSettingsMinutes = null; } else avgServiceTimeFromSettingsMinutes = null; computePeopleAheadAndEstimate(); });

    // On load: find the queue entry by query param (support queueId or key)
    document.addEventListener('DOMContentLoaded', async ()=>{
      const params = new URLSearchParams(window.location.search);
      const incoming = params.get('queueId') || params.get('key') || params.get('q');
      if(!incoming){ showError('Queue ID missing â€” redirecting...'); setTimeout(()=> window.location.href = 'index.html', 1100); return; }

      // try direct child key first
      let foundKey = null;
      try{
        const directSnap = await get(ref(db, `queue/${incoming}`));
        if(directSnap.exists()) foundKey = incoming;
        else {
          // fallback: search for entry where queueId === incoming
          const all = await get(ref(db, 'queue'));
          if(all.exists()){ const val = all.val(); for(const k in val){ if(val[k] && val[k].queueId === incoming){ foundKey = k; break; } } }
        }
      }catch(e){ console.warn('db read error', e); }

      if(!foundKey){ showError('Queue entry not found'); setTimeout(()=> window.location.href = 'index.html', 1200); return; }
      currentQueueKey = foundKey;

      // subscribe to this entry
      const qRef = ref(db, `queue/${currentQueueKey}`);
      onValue(qRef, (snap)=>{ if(!snap.exists()){ showError('Queue entry removed'); return; } currentQueueData = snap.val(); yourNumberEl.textContent = currentQueueData.queueId || '--'; setTelegramConnectedUI(!!currentQueueData.telegramConnected);

        // subscribe to counter (if present)
        const counterId = currentQueueData.counterId || null;
        if(counterId && counterId !== currentCounterId){
          if(currentCounterId) try{ off(ref(db, `counters/${currentCounterId}`)); }catch(e){}
          currentCounterId = counterId;
          const counterRef = ref(db, `counters/${counterId}`);
          onValue(counterRef, (cSnap)=>{ if(!cSnap.exists()) return; const cData = cSnap.val();
            const prefix = cData && cData.prefix ? String(cData.prefix) : null;
            const nowServingNum = (cData && (cData.nowServing !== undefined && cData.nowServing !== null)) ? Number(cData.nowServing) : null;
            const digits = digitsFromQueueId(currentQueueData.queueId);
            let nowServingText = '--';
            if(prefix && Number.isFinite(nowServingNum)) nowServingText = `${String(prefix)} ${zeroPad(nowServingNum, digits)}`;
            else if(Number.isFinite(nowServingNum)) nowServingText = String(nowServingNum);
            else nowServingText = (cData && cData.nowServing) ? String(cData.nowServing) : '--';
            nowServingEl.textContent = nowServingText;

            detectAndRedirectIfCalled(cData);
            computePeopleAheadAndEstimate();
          });
        } else {
          nowServingEl.textContent = '--';
        }

        computePeopleAheadAndEstimate();
      });

      // watch whole queue so we update estimates live
      const allQueueRef = ref(db, 'queue');
      onValue(allQueueRef, ()=> computePeopleAheadAndEstimate());
    });

    function zeroPad(num, len){ return String(num).padStart(len,'0'); }
    function digitsFromQueueId(qid){ if(!qid) return 3; const m = String(qid).match(/(\d+)$/); return m? m[1].length:3; }

    async function computePeopleAheadAndEstimate(){
      try{
        if(!currentQueueData) return;
        const allSnap = await get(ref(db, 'queue'));
        if(!allSnap.exists()){ peopleAheadEl.textContent='0'; estimatedWaitEl.textContent='Less than a minute'; updateProgress(4); return; }
        const all = allSnap.val();
        const myTime = Number(currentQueueData.timestamp) || 0;
        const myQueueId = String(currentQueueData.queueId || '');
        const parsed = parseQueueId(myQueueId);
        const mySeries = parsed ? parsed.series : (currentQueueData.series ? String(currentQueueData.series).toUpperCase() : null);

        // waiting list for same series
        const waitingList = Object.keys(all)
          .map(k => ({ key:k, data: all[k], ts: Number(all[k].timestamp) || 0 }))
          .filter(item => item.data && item.data.status === 'waiting' && item.data.queueId && (mySeries ? String(item.data.queueId).startsWith(mySeries) : true))
          .sort((a,b)=> a.ts - b.ts);

        const positionIndex = waitingList.findIndex(w => String(w.data.queueId) === myQueueId);
        const totalWaitingForSeries = waitingList.length;
        const peopleAhead = positionIndex >= 0 ? positionIndex : waitingList.filter(w => w.ts < myTime).length;
        peopleAheadEl.textContent = String(peopleAhead);

        // choose avg ms: serviceEvents avg -> global settings -> fallback 3min
        let avgMs = null;
        if(mySeries && avgServiceMsBySeries[mySeries] && avgServiceMsBySeries[mySeries].avg) avgMs = avgServiceMsBySeries[mySeries].avg;
        if(!avgMs && avgServiceTimeFromSettingsMinutes) avgMs = avgServiceTimeFromSettingsMinutes * 60 * 1000;
        if(!avgMs) avgMs = 3 * 60 * 1000;

        const estMs = Math.round(peopleAhead * avgMs);
        const estMinutes = Math.max(0, Math.round(estMs / 60000));
        estimatedWaitEl.textContent = (peopleAhead === 0) ? 'Now' : `${peopleAhead} person${peopleAhead>1?'s':''} â€” approx ${formatMinutes(estMinutes)}`;

        // progress percent based on position within same series waiting list (more accurate)
        let percent = 6;
        if(positionIndex >= 0 && totalWaitingForSeries > 0){
          const ratio = 1 - (positionIndex / Math.max(1, totalWaitingForSeries - 1));
          percent = Math.round(6 + Math.min(92, Math.max(0, ratio * 92)));
        } else {
          // fallback
          const bucket = Math.max(1, peopleAhead + 2);
          percent = Math.max(6, Math.min(98, Math.round(((bucket - peopleAhead) / bucket) * 100)));
        }
        updateProgress(percent, estMinutes);
      }catch(e){ console.warn('compute estimate err', e); showError('Could not compute estimate.'); }
    }

    function formatMinutes(m){ const mm = Math.max(0, Math.round(m)); if(mm === 0) return 'Less than a minute'; if(mm < 60) return `${mm} min${mm>1?'s':''}`; const hrs = Math.floor(mm/60), rem = mm%60; return rem === 0 ? `${hrs} hr${hrs>1?'s':''}` : `${hrs} hr ${rem} min`; }

    function updateProgress(p, estMinutes){
      p = Math.max(4, Math.min(100, Math.round(p)));
      progressFill.style.width = p + '%';
      progressLabel.textContent = p >= 95 ? 'Almost' : p + '%';
      if(typeof estMinutes === 'number') progressLabel.title = `Approx ${formatMinutes(estMinutes)} remaining`;
    }

    // Redirect to your_turn.html correctly (using full origin + queueId param)
    function detectAndRedirectIfCalled(counterData){
      if(!currentQueueData) return;
      try{
        const prefix = counterData && counterData.prefix ? String(counterData.prefix) : null;
        const nowServingNum = (counterData && (counterData.nowServing !== undefined && counterData.nowServing !== null)) ? Number(counterData.nowServing) : null;
        if(prefix && Number.isFinite(nowServingNum)){
          const digits = digitsFromQueueId(currentQueueData.queueId);
          const nowServingFull = `${prefix}${zeroPad(nowServingNum, digits)}`;
          if(String(nowServingFull) === String(currentQueueData.queueId)){
            const targetQ = encodeURIComponent(currentQueueData.queueId || currentQueueKey);
            const url = `${location.origin}/your_turn.html?queueId=${targetQ}`;
            connectionBannerText.textContent = "It's your turn â€” redirecting...";
            setTimeout(()=> { window.location.href = url; }, 500);
          }
        }
        const status = currentQueueData && currentQueueData.status ? String(currentQueueData.status) : '';
        if(status === 'serving' || status === 'called'){
          const targetQ = encodeURIComponent(currentQueueData.queueId || currentQueueKey);
          const url = `${location.origin}/your_turn.html?queueId=${targetQ}`;
          connectionBannerText.textContent = "It's your turn â€” redirecting...";
          setTimeout(()=> { window.location.href = url; }, 500);
        }
      }catch(e){ console.warn('redirect detect error', e); }
    }

    function showError(msg){ const el = document.getElementById('error'); el.style.display = 'block'; el.textContent = msg; setTimeout(()=> el.style.display = 'none', 6000); }
    function setTelegramConnectedUI(connected){ if(connected){ connectionBannerText.textContent = "Connected â€” you'll get Telegram notifications"; connectMainBtn.textContent = 'Connected'; connectMainBtn.disabled = true; } else { connectionBannerText.textContent = 'Not connected â€” get Telegram notifications'; connectMainBtn.textContent = 'Connect'; connectMainBtn.disabled = false; } }

    // small UI handlers
    connectMainBtn.addEventListener('click', ()=>{ window.open(TELEGRAM_BOT_URL, '_blank', 'noopener'); });
    connectBtn.addEventListener('click', ()=> connectMainBtn.click());
    gameBtn.addEventListener('click', ()=> window.location.href = 'https://queuejoy.netlify.app/game.html');

  </script>
</body>
</html>
