<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QueueJoy ‚Äî Status</title>

  <!-- Tailwind for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />

  <style>
    :root{
      --p1:#8b5cf6; --p2:#a78bfa; --bg1:#f6f5ff;
    }
    * { box-sizing:border-box; }
    body {
      margin:0;
      font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;
      background: linear-gradient(135deg,var(--bg1),#f3f0ff);
      min-height:100vh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:16px;
    }
    .page-wrapper{
      width:100%;
      max-width:880px;
      display:flex;
      justify-content:center;
    }
    .card {
      width:100%;
      max-width:820px;
      border-radius:20px;
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(250,248,255,0.98));
      box-shadow:0 26px 80px rgba(99,102,241,0.16);
      padding:22px 20px 20px;
      position:relative;
      overflow:hidden;
    }
    @media (min-width:768px){
      .card{ padding:26px 26px 22px; border-radius:22px; }
    }

    .brand-blob {
      width:76px;height:76px;border-radius:18px;
      background:linear-gradient(135deg,var(--p1),var(--p2));
      display:flex;align-items:center;justify-content:center;color:white;font-weight:800;
      box-shadow:0 18px 50px rgba(139,92,246,0.18);
      transform:translateY(-4px);
      font-size:26px;
    }
    .muted { color:#6b7280 }

    .progress-track {
      height:20px;
      border-radius:999px;
      background:#f3f4ff;
      position:relative;
      overflow:hidden;
      box-shadow:inset 0 0 0 1px rgba(148,163,184,0.18);
    }
    .progress-fill {
      height:100%;
      background:linear-gradient(90deg,var(--p1),var(--p2));
      display:flex;
      align-items:center;
      justify-content:flex-end;
      padding-right:10px;
      color:white;
      font-weight:800;
      font-size:11px;
      letter-spacing:0.04em;
      transition:width .55s cubic-bezier(.22,.9,.22,1);
      box-shadow:0 10px 30px rgba(129,140,248,0.45);
    }

    .glass {
      background:rgba(247,245,255,0.8);
      border-radius:14px;
      padding:12px 12px 10px;
      border:1px solid rgba(148,163,238,0.14);
      backdrop-filter:blur(16px);
    }
    @media (min-width:768px){
      .glass{ padding:14px 16px 12px; border-radius:16px; }
    }

    .circle-btn {
      width:40px;height:40px;border-radius:999px;background:white;
      display:inline-flex;align-items:center;justify-content:center;
      border:none;
      box-shadow:0 10px 30px rgba(2,6,23,0.08);
      cursor:pointer;
      font-size:18px;
      transition:transform .18s ease, box-shadow .18s ease, background .18s ease;
    }
    .circle-btn:hover {
      transform:translateY(-1px) scale(1.03);
      box-shadow:0 16px 40px rgba(15,23,42,0.16);
      background:#f9fafb;
    }

    .btn-gradient {
      background:linear-gradient(135deg,var(--p1),var(--p2));
      color:white;
      padding:.85rem 1.4rem;
      border-radius:12px;
      font-weight:700;
      border:none;
      box-shadow:0 10px 30px rgba(139,92,246,0.28);
      width:100%;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      font-size:15px;
      transition:transform .16s ease, box-shadow .16s ease, filter .16s ease, opacity .16s ease;
    }
    .btn-gradient:hover {
      transform:translateY(-1px);
      box-shadow:0 18px 42px rgba(129,140,248,0.3);
      filter:brightness(1.02);
    }
    .btn-gradient:disabled{
      opacity:0.7;
      cursor:not-allowed;
      box-shadow:none;
      transform:none;
    }

    .btn-outline {
      border:1px solid rgba(148,163,255,0.3);
      padding:.7rem 1.1rem;
      border-radius:10px;
      background:white;
      font-weight:600;
      width:100%;
      cursor:pointer;
      font-size:14px;
      color:#111827;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      transition:background .15s ease, box-shadow .15s ease, transform .15s ease;
    }
    .btn-outline:hover {
      background:#f9fafb;
      box-shadow:0 8px 24px rgba(15,23,42,0.08);
      transform:translateY(-1px);
    }

    /* Onboarding modal */
    .onboarding-modal {
      position:fixed; inset:0;
      background:rgba(15,23,42,0.55);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:60;
      padding:16px;
      backdrop-filter:blur(10px);
    }
    .onboarding-card {
      width:100%;
      max-width:460px;
      background:white;
      border-radius:20px;
      padding:20px 18px 18px;
      box-shadow:0 30px 90px rgba(15,23,42,0.48);
      overflow:hidden;
    }
    @media (min-width:480px){
      .onboarding-card{ padding:22px 22px 18px; border-radius:22px; }
    }

    .slide {
      display:none;
      animation:slideIn .32s ease both;
      min-height:320px;
    }
    .slide.active {
      display:flex;
      flex-direction:column;
      justify-content:space-between;
    }
    @keyframes slideIn {
      from { opacity:0; transform:translateY(18px) }
      to { opacity:1; transform:translateY(0) }
    }

    .step-dots {
      display:flex;
      gap:8px;
      justify-content:center;
      margin:14px 0;
    }
    .step-dot {
      width:8px;height:8px;border-radius:999px;background:#e6e7f8;
      transition:all .25s;
    }
    .step-dot.active {
      width:26px;
      border-radius:999px;
      background:linear-gradient(135deg,var(--p1),var(--p2));
      box-shadow:0 6px 18px rgba(129,140,248,0.35);
    }

    .spinner {
      width:14px;height:14px;border-radius:50%;
      border:2px solid rgba(255,255,255,0.35);
      border-top-color:white;
      animation:spin .8s linear infinite;
      display:inline-block;
    }
    @keyframes spin { to { transform:rotate(360deg) } }

    /* ad panel bottom */
    .ad-panel {
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:14px;
      width:100%;
      max-width:420px;
      background:white;
      border-radius:14px;
      box-shadow:0 22px 70px rgba(15,23,42,0.16);
      padding:9px 9px 10px;
      z-index:40;
    }
    .ad-media {
      width:100%;
      height:96px;
      object-fit:cover;
      border-radius:10px;
    }

    .pulse {
      animation:pulseX 2.2s ease-in-out infinite;
    }
    @keyframes pulseX {
      0% { transform:scale(1) }
      50% { transform:scale(1.02) }
      100% { transform:scale(1) }
    }

    /* responsive tweaks */
    @media (max-width:640px) {
      body{
        padding:10px;
      }
      .card {
        padding:16px 14px 14px;
        border-radius:18px;
      }
      .brand-blob {
        width:64px;height:64px;font-size:22px;
      }
    }
  </style>
</head>
<body>

<div class="page-wrapper">

  <!-- Onboarding (appears immediately on load) -->
  <div id="onboardingModal" class="onboarding-modal" aria-hidden="false">
    <div class="onboarding-card" role="dialog" aria-modal="true">
      <!-- Slide 1 -->
      <div class="slide active" data-slide="0">
        <div style="text-align:center">
          <div style="width:120px;height:120px;margin:0 auto;border-radius:22px;background:linear-gradient(135deg,var(--p1),var(--p2));display:flex;align-items:center;justify-content:center;font-size:40px;color:white;box-shadow:0 16px 46px rgba(139,92,246,0.24)">‚úâÔ∏è</div>
          <h3 style="margin-top:18px;font-size:20px;font-weight:800;color:#111827">Connect Telegram</h3>
          <p style="color:#6b7280;margin-top:8px;font-size:14px;line-height:1.5">
            Get notified on Telegram ‚Äî you don‚Äôt need this page open. Use the Telegram app on your phone to receive push notifications.
          </p>
        </div>

        <div>
          <div class="step-dots">
            <div class="step-dot active"></div>
            <div class="step-dot"></div>
            <div class="step-dot"></div>
          </div>
          <button id="obNext" class="btn-gradient">Next</button>
          <button id="obSkip" class="btn-outline" style="margin-top:10px">Skip for now</button>
        </div>
      </div>

      <!-- Slide 2 -->
      <div class="slide" data-slide="1">
        <div style="text-align:center">
          <div style="width:120px;height:120px;margin:0 auto;border-radius:22px;background:linear-gradient(135deg,var(--p2),var(--p1));display:flex;align-items:center;justify-content:center;font-size:40px;color:white;box-shadow:0 16px 46px rgba(139,92,246,0.24)">‚ñ∂Ô∏è</div>
          <h3 style="margin-top:18px;font-size:20px;font-weight:800;color:#111827">Tap ‚ÄúStart‚Äù in Telegram</h3>
          <p style="color:#6b7280;margin-top:8px;font-size:14px;line-height:1.5">
            We‚Äôll open QueueJoy on Telegram. Tap <strong>Start</strong> there so we can notify you automatically.
          </p>
        </div>

        <div>
          <div class="step-dots">
            <div class="step-dot"></div>
            <div class="step-dot active"></div>
            <div class="step-dot"></div>
          </div>
          <button id="obNext2" class="btn-gradient">Next</button>
          <button id="obBack1" class="btn-outline" style="margin-top:10px">Back</button>
        </div>
      </div>

      <!-- Slide 3 -->
      <div class="slide" data-slide="2">
        <div style="text-align:center">
          <div style="width:120px;height:120px;margin:0 auto;border-radius:22px;background:linear-gradient(135deg,var(--p1),var(--p2));display:flex;align-items:center;justify-content:center;font-size:40px;color:white;box-shadow:0 16px 46px rgba(139,92,246,0.24)">‚úÖ</div>
          <h3 style="margin-top:18px;font-size:20px;font-weight:800;color:#111827">All set in a moment</h3>
          <p id="obStatusText" style="color:#6b7280;margin-top:8px;font-size:14px;line-height:1.5">
            Preparing a secure connection link for your ticket‚Ä¶
          </p>
        </div>

        <div>
          <div class="step-dots">
            <div class="step-dot"></div>
            <div class="step-dot"></div>
            <div class="step-dot active"></div>
          </div>
          <button id="obFinish" class="btn-gradient">
            <span id="obFinishText">Connect via Telegram</span>
          </button>
          <button id="obBack2" class="btn-outline" style="margin-top:10px">Back</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Main card -->
  <main class="card" role="main" aria-live="polite">
    <div style="position:absolute;right:16px;top:14px;display:flex;gap:8px">
      <button id="miniGame" class="circle-btn" title="Play a quick game">üéÆ</button>
      <button id="miniConnect" class="circle-btn pulse" title="Connect Telegram">‚úâÔ∏è</button>
    </div>

    <div style="display:flex;gap:16px;align-items:center;flex-wrap:wrap;justify-content:center;margin-top:6px">
      <div class="brand-blob">QJ</div>
      <div style="text-align:center;max-width:620px">
        <h1 style="font-size:20px;margin:0;font-weight:900;color:#111827">
          You‚Äôre in line ‚Äî we‚Äôre watching your spot
        </h1>
        <p class="muted" style="margin-top:6px;font-size:14px;line-height:1.5">
          Stay on this page or connect Telegram to get a notification the moment it‚Äôs your turn.
        </p>
      </div>
    </div>

    <!-- progress -->
    <section style="margin-top:18px">
      <div style="display:flex;justify-content:space-between;align-items:flex-end;margin-bottom:6px">
        <span class="muted" style="font-size:13px">Progress to your turn</span>
        <span id="progressCaption" style="font-size:12px;font-weight:600;color:#4b5563">Calculating‚Ä¶</span>
      </div>
      <div class="progress-track" aria-hidden="true">
        <div id="progressFill" class="progress-fill" style="width:8%">
          <div id="progressLabel">8%</div>
        </div>
      </div>
    </section>

    <!-- main stats -->
    <section style="margin-top:18px;display:grid;grid-template-columns:1fr 1fr;gap:12px">
      <div class="glass">
        <div class="muted" style="font-size:12px;text-transform:uppercase;letter-spacing:0.08em">Your Number</div>
        <div id="yourNumber" style="font-weight:900;font-size:32px;color:var(--p1);margin-top:4px;word-break:break-word">‚Äî</div>
      </div>
      <div class="glass">
        <div class="muted" style="font-size:12px;text-transform:uppercase;letter-spacing:0.08em">Now Serving</div>
        <div id="nowServing" style="font-weight:900;font-size:32px;color:#111827;margin-top:4px;word-break:break-word">‚Äî</div>
      </div>
    </section>

    <section style="margin-top:12px;display:grid;grid-template-columns:1fr 1fr;gap:12px">
      <div class="glass">
        <div class="muted" style="font-size:12px;text-transform:uppercase;letter-spacing:0.08em">People Ahead</div>
        <div id="peopleAhead" style="font-weight:800;font-size:20px;margin-top:6px">‚Äî</div>
      </div>
      <div class="glass">
        <div class="muted" style="font-size:12px;text-transform:uppercase;letter-spacing:0.08em">Estimated Wait</div>
        <div id="estimatedWait" style="font-weight:800;font-size:18px;color:var(--p1);margin-top:6px">‚Äî</div>
      </div>
    </section>

    <section id="connectionBanner" class="glass" style="display:flex;align-items:center;gap:12px;margin-top:16px">
      <div style="width:46px;height:46px;border-radius:12px;background:linear-gradient(135deg,var(--p1),var(--p2));display:flex;align-items:center;justify-content:center;color:white;font-size:22px;flex-shrink:0">üîî</div>
      <div style="flex:1;min-width:0">
        <div id="connectionBannerText" style="font-weight:800;font-size:14px;white-space:normal">
          Checking notification status‚Ä¶
        </div>
        <div id="connectionBannerSub" style="color:#6b7280;font-size:13px;margin-top:2px">
          Connect Telegram to receive alerts even if this page is closed.
        </div>
      </div>
      <div style="min-width:140px;max-width:180px">
        <button id="connectMain" class="btn-gradient" style="padding-inline:1.1rem;font-size:13px">Connect Telegram</button>
      </div>
    </section>

    <div id="error" style="display:none;margin-top:12px;padding:10px;border-radius:10px;background:#fff5f5;border:1px solid #fde2e2;color:#b91c1c;font-weight:600;font-size:13px;text-align:center"></div>
  </main>

</div>

  <!-- ad panel -->
  <div id="adPanel" class="ad-panel" style="display:none">
    <div style="font-size:11px;color:#9ca3af;text-align:center;margin-bottom:4px">Advertisement</div>
    <div id="adContainer"></div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getDatabase, ref, onValue, off, get } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

    // endpoints
    const CREATE_LINK_ENDPOINT = '/.netlify/functions/createTelegramLink';
    const MARK_TOKEN_USED = '/.netlify/functions/markTokenUsed';
    const TELEGRAM_BOT_URL = 'https://t.me/QueueJoyBot';

    // firebase config (your project)
    const firebaseConfig = {
      apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
      authDomain: "queue-joy-aa21b.firebaseapp.com",
      databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "queue-joy-aa21b",
      storageBucket: "queue-joy-aa21b.firebasestorage.app",
      messagingSenderId: "950240394209",
      appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
    };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // DOM
    const obModal = document.getElementById('onboardingModal');
    const slides = Array.from(document.querySelectorAll('.slide'));
    const stepDots = Array.from(document.querySelectorAll('.step-dot'));
    const obNext = document.getElementById('obNext');
    const obNext2 = document.getElementById('obNext2');
    const obBack1 = document.getElementById('obBack1');
    const obBack2 = document.getElementById('obBack2');
    const obSkip = document.getElementById('obSkip');
    const obFinish = document.getElementById('obFinish');
    const obFinishText = document.getElementById('obFinishText');
    const obStatusText = document.getElementById('obStatusText');

    const yourNumberEl = document.getElementById('yourNumber');
    const nowServingEl = document.getElementById('nowServing');
    const peopleAheadEl = document.getElementById('peopleAhead');
    const estimatedWaitEl = document.getElementById('estimatedWait');
    const progressFill = document.getElementById('progressFill');
    const progressLabel = document.getElementById('progressLabel');
    const progressCaption = document.getElementById('progressCaption');
    const connectMainBtn = document.getElementById('connectMain');
    const connectMiniBtn = document.getElementById('miniConnect');
    const connectionBannerText = document.getElementById('connectionBannerText');
    const connectionBannerSub = document.getElementById('connectionBannerSub');
    const adPanel = document.getElementById('adPanel');
    const adContainer = document.getElementById('adContainer');
    const errorBox = document.getElementById('error');

    // onboarding state
    let slideIndex = 0;
    let onboardingDismissed = false;
    function showSlide(i){
      slides.forEach(s => s.classList.remove('active'));
      stepDots.forEach(d => d.classList.remove('active'));
      slideIndex = i;
      const sl = slides[i];
      if(sl) sl.classList.add('active');
      const dot = stepDots[i];
      if(dot) dot.classList.add('active');
      // when slide 3 visible, trigger generate link in background
      if(i === 2) triggerGenerateLink();
    }

    obNext.addEventListener('click', ()=> showSlide(1));
    obNext2.addEventListener('click', ()=> showSlide(2));
    obBack1.addEventListener('click', ()=> showSlide(0));
    obBack2.addEventListener('click', ()=> showSlide(1));
    obSkip.addEventListener('click', ()=> {
      onboardingDismissed = true;
      obModal.style.display = 'none';
    });

    // allow clicking outside popup to close
    obModal.addEventListener('click', (e)=>{
      if(e.target === obModal){
        onboardingDismissed = true;
        obModal.style.display = 'none';
      }
    });

    // connect flow
    let currentQueueKey = null;
    let currentQueueData = null;
    let currentCounterId = null;
    let latestConnectLink = null;
    let linkGenerating = false;
    let avgServiceTimeFromSettings = null; // admin.html avg wait priority
    let avgServiceTimeForCounter = 3;
    let redirecting = false;

    // Helper UI functions
    function showError(msg){
      if(!errorBox) return;
      errorBox.style.display = 'block';
      errorBox.textContent = msg;
      setTimeout(()=> { if(errorBox) errorBox.style.display = 'none'; }, 6000);
    }

    function setTelegramConnectedUI(connected){
      if(connected){
        connectionBannerText.textContent = "Connected ‚Äî you‚Äôll get Telegram notifications";
        connectionBannerSub.textContent = "You can safely close this page. We‚Äôll notify you when it‚Äôs your turn.";
        connectMainBtn.textContent = "Connected";
        connectMainBtn.disabled = true;
        connectMiniBtn.classList.remove('pulse');
      } else {
        connectionBannerText.textContent = "Not connected ‚Äî get Telegram notifications";
        connectionBannerSub.textContent = "Connect to receive notifications even when this page is closed.";
        connectMainBtn.textContent = "Connect Telegram";
        connectMainBtn.disabled = false;
        connectMiniBtn.classList.add('pulse');
      }
    }

    // Generate secure telegram link via function
    async function generateConnectLink(){
      if(!currentQueueKey) throw new Error('Missing queueId');
      const res = await fetch(CREATE_LINK_ENDPOINT, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ queueKey: currentQueueKey })
      });
      if(!res.ok) {
        const t = await res.text().catch(()=> '');
        throw new Error('create link failed ' + res.status + ' ' + t);
      }
      const j = await res.json();
      if(j.link) return j.link;
      // fallback: if token returned, build Telegram URL that triggers /start
      if(j.token){
        const url = new URL(TELEGRAM_BOT_URL);
        url.searchParams.set('start', j.token);
        return url.toString();
      }
      throw new Error('no link returned');
    }

    async function triggerGenerateLink(){
      if(linkGenerating) return;
      linkGenerating = true;
      obStatusText.textContent = 'Generating secure link‚Ä¶';
      obFinishText.innerText = 'Connect via Telegram';
      latestConnectLink = null;
      try{
        let link = await generateConnectLink();
        // ensure the Telegram link actually triggers /start
        if(link && !link.includes('start=')){
          const url = new URL(TELEGRAM_BOT_URL);
          const token = (currentQueueData && (currentQueueData.telegramToken || currentQueueData.tgToken || currentQueueData.token)) || null;
          if(token) url.searchParams.set('start', token);
          link = url.toString();
        }
        latestConnectLink = link || TELEGRAM_BOT_URL;
        obStatusText.textContent = 'Ready to connect. Tap the button below.';
      }catch(e){
        latestConnectLink = TELEGRAM_BOT_URL;
        obStatusText.textContent = 'Couldn‚Äôt generate a unique link ‚Äî using the main bot link.';
        console.warn(e);
      } finally {
        linkGenerating = false;
      }
    }

    async function openConnectLink(){
      if(!latestConnectLink && !linkGenerating){
        try{
          linkGenerating = true;
          latestConnectLink = await generateConnectLink();
        }catch(e){
          console.warn(e);
          latestConnectLink = TELEGRAM_BOT_URL;
        } finally {
          linkGenerating = false;
        }
      }

      const finalUrl = latestConnectLink || TELEGRAM_BOT_URL;

      // Prefer full-page navigation so Telegram opens reliably on mobile
      window.location.href = finalUrl;

      // try to notify server to mark token as used
      try{
        const token = (finalUrl && finalUrl.split('start=')[1]) || null;
        if(token && currentQueueKey){
          await fetch(MARK_TOKEN_USED, {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ queueKey: currentQueueKey, token })
          });
        }
      }catch(e){
        console.warn('mark token used failed', e);
      }
    }

    obFinish.addEventListener('click', async () => {
      obFinish.disabled = true;
      obFinishText.innerHTML = '<span class="spinner"></span><span>Opening Telegram‚Ä¶</span>';
      try{
        await openConnectLink();
        obFinishText.innerHTML = 'Opened in Telegram';
        setTimeout(()=> {
          onboardingDismissed = true;
          obModal.style.display = 'none';
        }, 650);
      }catch(e){
        console.error(e);
        obFinishText.innerHTML = 'Connect via Telegram';
        showError('Unable to open Telegram. Please try again.');
      } finally {
        obFinish.disabled = false;
      }
    });

    // connect button triggers onboarding modal
    function openOnboarding(){
      if(onboardingDismissed) {
        // if user already dismissed, go straight to connect
        showSlide(2);
        triggerGenerateLink();
      }
      obModal.style.display = 'flex';
      if(!onboardingDismissed) showSlide(0);
    }
    connectMainBtn.addEventListener('click', openOnboarding);
    connectMiniBtn.addEventListener('click', openOnboarding);
    document.getElementById('miniGame').addEventListener('click', ()=> {
      window.location.href = 'https://queuejoy.netlify.app/game.html';
    });

    // AD helpers
    function clearAd(){
      adContainer.innerHTML='';
      adPanel.style.display='none';
    }
    function showAdFromUrl(url){
      clearAd();
      if(!url) return;
      const trimmed = String(url).trim();
      if(!trimmed) return;
      const isVideo = /\.(mp4|webm|ogg)(\?.*)?$/i.test(trimmed) || trimmed.startsWith('data:video/');
      adPanel.style.display = 'block';
      if(isVideo){
        const v = document.createElement('video');
        v.src = trimmed;
        v.autoplay = true;
        v.muted = true;
        v.loop = true;
        v.playsInline = true;
        v.className = 'ad-media';
        v.setAttribute('playsinline', '');
        v.setAttribute('muted','');
        adContainer.appendChild(v);
        v.play().catch(()=> v.setAttribute('controls',''));
      } else {
        const img = document.createElement('img');
        img.src = trimmed;
        img.className = 'ad-media';
        img.alt = 'Advertisement';
        img.onerror = ()=> clearAd();
        adContainer.appendChild(img);
      }
    }

    // Utility helpers
    function digitsFromQueueId(qid){
      if(!qid) return 3;
      const m = String(qid).match(/(\d+)$/);
      return m ? m[1].length : 3;
    }
    function zeroPad(num, len){
      return String(num).padStart(len,'0');
    }

    // compute avg service time priority: admin settings -> counter.avgServiceTime -> fallback 3
    async function readGlobalAvgServiceTime(){
      try{
        const snap = await get(ref(db,'settings/avgServiceTime'));
        if(snap && snap.exists()){
          const val = Number(snap.val());
          if(Number.isFinite(val) && val > 0) {
            avgServiceTimeFromSettings = val;
            return val;
          }
        }
      }catch(e){
        console.warn('readGlobalAvgServiceTime error', e);
      }
      avgServiceTimeFromSettings = null;
      return null;
    }

    // keep live subscriptions
    let qRef = null, allQueueRef = null, adRef = null, counterRef = null, settingsRef = null;

    // Listen and live-sync
    document.addEventListener('DOMContentLoaded', async () => {
      // show onboarding immediately on first load
      obModal.style.display = 'flex';
      showSlide(0);

      const params = new URLSearchParams(window.location.search);
      const queueKey = params.get('queueId');
      if(!queueKey){
        showError('Queue ID missing ‚Äî returning‚Ä¶');
        setTimeout(()=> window.location.href = 'index.html', 1100);
        return;
      }
      currentQueueKey = queueKey;
      qRef = ref(db, `queue/${queueKey}`);

      // watch ad setting
      adRef = ref(db, 'settings/adImage');
      onValue(adRef, (snap) => {
        if(snap.exists()) showAdFromUrl(snap.val());
        else clearAd();
      });

      // watch global avg service time and update whenever changed
      settingsRef = ref(db, 'settings/avgServiceTime');
      onValue(settingsRef, (snap) => {
        if(snap.exists()){
          const val = Number(snap.val());
          if(Number.isFinite(val) && val>0) avgServiceTimeFromSettings = val;
        } else {
          avgServiceTimeFromSettings = null;
        }
        computePeopleAheadAndEstimate();
      });

      // listen to your queue entry
      onValue(qRef, async (snap) => {
        if(!snap.exists()){
          showError('Queue entry not found ‚Äî returning‚Ä¶');
          setTimeout(()=> window.location.href = 'index.html', 1200);
          return;
        }
        currentQueueData = snap.val();

        // show your number
        yourNumberEl.textContent = currentQueueData.queueId || currentQueueData.ticket || '--';

        // optional: if Firebase stores nowServing and peopleAhead directly on this node, prefer that
        if(currentQueueData.nowServingDisplay){
          nowServingEl.textContent = String(currentQueueData.nowServingDisplay);
        }

        // telegram UI
        setTelegramConnectedUI(Boolean(currentQueueData.telegramConnected || currentQueueData.tgConnected));

        // subscribe to assigned counter if present
        const counterId = currentQueueData.counterId || currentQueueData.counter || null;
        if(counterId && counterId !== currentCounterId){
          if(counterRef) try{ off(counterRef); }catch(e){}
          currentCounterId = counterId;
          counterRef = ref(db, `counters/${counterId}`);
          onValue(counterRef, (cSnap) => {
            if(!cSnap.exists()) return;
            const cData = cSnap.val();
            updateNowServingFromCounter(cData);
            updateAvgServiceTimeFromCounter(cData);
            detectAndRedirectIfCalled(cData);
          });
        } else if(!counterId){
          nowServingEl.textContent = '--';
        }

        // If Firebase already sends peopleAhead / estimatedWait / progress, respect that
        applyDirectFirebaseEstimates();

        // compute estimates each time queue entry changes (fallback / live sync)
        computePeopleAheadAndEstimate();
      });

      // watch entire queue (people-ahead + progress computation)
      allQueueRef = ref(db, 'queue');
      onValue(allQueueRef, () => computePeopleAheadAndEstimate());

      // when unloading, cleanup listeners
      window.addEventListener('beforeunload', () => {
        try {
          if(qRef) off(qRef);
          if(allQueueRef) off(allQueueRef);
          if(adRef) off(adRef);
          if(counterRef) off(counterRef);
          if(settingsRef) off(settingsRef);
        } catch(e){
          console.warn(e);
        }
      });

      // initial avg setting
      try{ await readGlobalAvgServiceTime(); }catch(e){}
    });

    function updateNowServingFromCounter(cData){
      if(!currentQueueData) return;
      const prefix = (cData && cData.prefix) ? String(cData.prefix) : '';
      const nowServingNumber = (cData && (cData.nowServing !== undefined && cData.nowServing !== null))
        ? Number(cData.nowServing)
        : null;
      const digits = digitsFromQueueId(currentQueueData.queueId);
      let nowServingText = '--';
      if(prefix && Number.isFinite(nowServingNumber)){
        nowServingText = `${String(prefix)} ${zeroPad(nowServingNumber, digits)}`;
      } else if(Number.isFinite(nowServingNumber)){
        nowServingText = String(nowServingNumber);
      } else if(cData && cData.nowServingDisplay){
        nowServingText = String(cData.nowServingDisplay);
      } else {
        nowServingText = (cData && cData.nowServing) ? String(cData.nowServing) : '--';
      }
      nowServingEl.textContent = nowServingText;
    }

    function updateAvgServiceTimeFromCounter(cData){
      (async ()=> {
        if(Number.isFinite(avgServiceTimeFromSettings) && avgServiceTimeFromSettings > 0){
          avgServiceTimeForCounter = Number(avgServiceTimeFromSettings);
        } else if(cData && Number.isFinite(Number(cData.avgServiceTime)) && Number(cData.avgServiceTime) > 0){
          avgServiceTimeForCounter = Number(cData.avgServiceTime);
        } else {
          avgServiceTimeForCounter = 3;
        }
        computePeopleAheadAndEstimate();
      })();
    }

    function applyDirectFirebaseEstimates(){
      if(!currentQueueData) return;

      // direct peopleAhead from node
      const directAhead = Number(currentQueueData.peopleAhead ?? currentQueueData.ahead ?? currentQueueData.positionAhead);
      if(Number.isFinite(directAhead)){
        peopleAheadEl.textContent = String(directAhead);
      }

      // direct estimated wait (text or minutes)
      if(typeof currentQueueData.estimatedWaitText === 'string' && currentQueueData.estimatedWaitText.trim()){
        estimatedWaitEl.textContent = currentQueueData.estimatedWaitText;
      } else {
        const directMinutes = Number(currentQueueData.estimatedWaitMinutes ?? currentQueueData.etaMinutes);
        if(Number.isFinite(directMinutes)){
          estimatedWaitEl.textContent = formatMinutes(directMinutes);
        }
      }

      // direct progress percent
      const directProgress = Number(currentQueueData.progressPercent ?? currentQueueData.progress ?? currentQueueData.progress_pct);
      if(Number.isFinite(directProgress)){
        const pct = Math.max(4, Math.min(100, Math.round(directProgress)));
        updateProgress(pct, directAhead);
      }
    }

    // compute people ahead & estimated wait; prefer Firebase but fall back to calculation
    async function computePeopleAheadAndEstimate(){
      try{
        if(!currentQueueData) return;

        // If Firebase already provides both peopleAhead and progress, treat that as source of truth
        const directAhead = Number(currentQueueData.peopleAhead ?? currentQueueData.ahead ?? currentQueueData.positionAhead);
        const directProgress = Number(currentQueueData.progressPercent ?? currentQueueData.progress ?? currentQueueData.progress_pct);
        const hasDirectAhead = Number.isFinite(directAhead);
        const hasDirectProgress = Number.isFinite(directProgress);

        const allSnap = await get(ref(db, 'queue'));
        if(!allSnap.exists()){
          const aheadVal = hasDirectAhead ? directAhead : 0;
          peopleAheadEl.textContent = String(aheadVal);
          const estMinutes = Math.max(0, aheadVal * (Number(avgServiceTimeFromSettings) || avgServiceTimeForCounter || 3));
          estimatedWaitEl.textContent = aheadVal === 0 ? 'Now' : formatMinutes(estMinutes);
          const pct = hasDirectProgress ? directProgress : (aheadVal === 0 ? 92 : 10);
          updateProgress(pct, aheadVal);
          return;
        }

        const all = allSnap.val();
        const myTime = Number(currentQueueData.timestamp) || 0;
        const myCounter = currentQueueData.counterId || currentQueueData.counter || null;
        const myStatus = String(currentQueueData.status || '').toLowerCase();

        let ahead = 0;
        let waitingSameCounter = 0;

        if(myCounter){
          for(const k in all){
            if(!Object.prototype.hasOwnProperty.call(all,k)) continue;
            const t = all[k];
            if(!t) continue;
            const status = String(t.status || '').toLowerCase();
            if(status !== 'waiting') continue;
            if(String(t.counterId || t.counter || '') !== String(myCounter)) continue;
            waitingSameCounter++;
            if(Number(t.timestamp) < myTime) ahead++;
          }
        } else {
          // not assigned: count everyone waiting before you across all counters
          for(const k in all){
            if(!Object.prototype.hasOwnProperty.call(all,k)) continue;
            const t = all[k];
            if(!t) continue;
            const status = String(t.status || '').toLowerCase();
            if(status !== 'waiting') continue;
            waitingSameCounter++;
            if(Number(t.timestamp) < myTime) ahead++;
          }
        }

        // If Firebase is already tracking peopleAhead, use that as source of truth
        const finalAhead = hasDirectAhead ? directAhead : ahead;
        peopleAheadEl.textContent = String(finalAhead);

        // decide avg minutes: admin setting > counter-specific fallback
        let avg = (Number.isFinite(avgServiceTimeFromSettings) && avgServiceTimeFromSettings > 0)
          ? avgServiceTimeFromSettings
          : (Number.isFinite(avgServiceTimeForCounter) ? avgServiceTimeForCounter : 3);
        if(!Number.isFinite(avg) || avg <= 0) avg = 3;

        // If Firebase provides estimated minutes, prefer it
        let estMinutes = null;
        const directMinutes = Number(currentQueueData.estimatedWaitMinutes ?? currentQueueData.etaMinutes);
        if(Number.isFinite(directMinutes)){
          estMinutes = directMinutes;
        } else {
          estMinutes = Math.max(0, finalAhead * avg);
        }

        estimatedWaitEl.textContent = (finalAhead === 0 && myStatus === 'waiting')
          ? 'Next ‚Äî be ready'
          : (finalAhead === 0 ? 'Now' : `${finalAhead} ahead ‚Äî ${formatMinutes(estMinutes)}`);

        // Progress:
        //  0 ahead   => ~92‚Äì96%
        //  many ahead => closer to 10‚Äì40%
        let percent;
        if(hasDirectProgress){
          percent = directProgress;
        } else {
          const totalWaiting = Math.max(waitingSameCounter || 0, finalAhead + 1);
          const positionFromBack = totalWaiting - finalAhead; // 1 when you‚Äôre last, totalWaiting when you‚Äôre first
          const raw = (positionFromBack / totalWaiting) * 92; // reserve 8% for "called" state
          percent = Math.max(6, Math.min(96, Math.round(raw)));
          if(finalAhead === 0){
            percent = Math.max(percent, 92);
          }
        }

        updateProgress(percent, finalAhead, myStatus);
      }catch(e){
        console.warn('compute estimate err', e);
        showError('Could not update live estimate.');
      }
    }

    function formatMinutes(m){
      const mm = Math.max(0, Math.round(m));
      if(mm === 0) return 'Less than a minute';
      if(mm < 60) return `${mm} min${mm>1?'s':''}`;
      const hrs = Math.floor(mm/60), rem = mm%60;
      return rem === 0 ? `${hrs} hr${hrs>1?'s':''}` : `${hrs} hr ${rem} min`;
    }

    function updateProgress(p, ahead = null, status = ''){
      const pct = Math.max(4, Math.min(100, Math.round(p)));
      progressFill.style.width = pct + '%';
      if(pct >= 98){
        progressLabel.textContent = '100%';
      } else {
        progressLabel.textContent = pct + '%';
      }

      const st = String(status || '').toLowerCase();
      if(st === 'called' || st === 'serving' || st === 'your_turn'){
        progressCaption.textContent = "It's your turn ‚Äî please go to the counter.";
      } else if(ahead === 0){
        progressCaption.textContent = "You‚Äôre next ‚Äî keep an eye on the screen.";
      } else if(ahead !== null && ahead > 0){
        progressCaption.textContent = `${ahead} ahead of you`;
      } else {
        progressCaption.textContent = "Tracking your place in line‚Ä¶";
      }
    }

    // Detect if served == our ticket or Firebase marks us as called -> redirect to your_turn.html
    function detectAndRedirectIfCalled(counterData){
      if(!currentQueueData || redirecting) return;
      try{
        const status = String(currentQueueData.status || '').toLowerCase();
        if(status === 'serving' || status === 'called' || status === 'your_turn'){
          redirectToTurnPage();
          return;
        }

        // also support explicit match via prefix + nowServing
        const prefix = (counterData && counterData.prefix) ? String(counterData.prefix) : null;
        const nowServingNum = (counterData && (counterData.nowServing !== undefined && counterData.nowServing !== null))
          ? Number(counterData.nowServing)
          : null;
        if(prefix && Number.isFinite(nowServingNum)){
          const digits = digitsFromQueueId(currentQueueData.queueId);
          const nowServingFull = `${prefix}${zeroPad(nowServingNum, digits)}`;
          if(String(nowServingFull) === String(currentQueueData.queueId)){
            redirectToTurnPage();
          }
        }
      }catch(e){
        console.warn('redirect detect error', e);
      }
    }

    function redirectToTurnPage(){
      if(redirecting) return;
      redirecting = true;
      connectionBannerText.textContent = "It‚Äôs your turn ‚Äî redirecting‚Ä¶";
      connectionBannerSub.textContent = "We‚Äôre opening your turn page now.";
      updateProgress(100, 0, 'serving');
      setTimeout(()=> {
        window.location.href = `your_turn.html?queueId=${encodeURIComponent(currentQueueKey || currentQueueData.queueId || '')}`;
      }, 600);
    }

  </script>
</body>
</html>
