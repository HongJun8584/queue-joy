<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QueueJoy ‚Äî Status</title>

  <!-- Tailwind CDN for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />

  <style>
    :root{
      --purple-1: #8b5cf6;
      --purple-2: #a78bfa;
      --bg-1: #f8f7ff;
    }
    body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; background: linear-gradient(135deg,#f7f6ff,#f1efff); min-height:100vh; display:flex; align-items:center; justify-content:center; padding:20px;}
    .card{max-width:720px; width:100%; border-radius:16px; background:rgba(255,255,255,0.96); box-shadow:0 18px 50px rgba(99,102,241,0.12); padding:28px; position:relative;}
    .logo-circle{width:72px;height:72px;border-radius:18px; background: linear-gradient(135deg,var(--purple-1),var(--purple-2)); display:flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:22px; box-shadow:0 10px 30px rgba(139,92,246,0.18);}
    .small-pill{padding:8px 12px;border-radius:12px;background:rgba(139,92,246,0.08); color:var(--purple-1); font-weight:700;}
    .progress-track{height:18px;border-radius:12px;background:#f1f1f1; overflow:hidden;}
    .progress-fill{height:100%; background: linear-gradient(90deg,var(--purple-1),var(--purple-2)); display:flex; align-items:center; justify-content:flex-end; padding-right:10px; color:white; font-weight:700;}
    .glass{background:rgba(247,245,255,0.7); border-radius:12px; padding:14px; border:1px solid rgba(139,92,246,0.06);}
    .circle-btn{width:44px;height:44px;border-radius:999px;background:white;display:inline-flex;align-items:center;justify-content:center;border:none;box-shadow:0 8px 28px rgba(15,23,42,0.06);cursor:pointer}
    .onboarding-modal{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;padding:16px;z-index:60;backdrop-filter:blur(4px)}
    .onboarding-panel{width:100%;max-width:420px;background:white;border-radius:16px;padding:22px;box-shadow:0 30px 80px rgba(12,12,30,0.4);}
    .spinner-inline{width:16px;height:16px;border:2px solid rgba(255,255,255,0.3);border-top-color:white;border-radius:50%;animation:spin .8s linear infinite; display:inline-block;margin-right:8px}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* Responsive tweaks */
    @media (max-width:640px){
      .card{padding:18px}
      .logo-circle{width:56px;height:56px;font-size:18px}
    }

    /* ad panel */
    .ad-panel{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;width:100%;max-width:420px;padding:10px;background:white;border-radius:12px;box-shadow:0 18px 48px rgba(12,12,30,0.08);z-index:40}
    .ad-media{width:100%;height:96px;object-fit:cover;border-radius:8px;display:block}
  </style>
</head>
<body>

  <!-- Onboarding / Telegram Connect Modal -->
  <div id="onboardingModal" class="onboarding-modal" style="display:none">
    <div class="onboarding-panel">
      <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px">
        <div style="width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--purple-1),var(--purple-2));display:flex;align-items:center;justify-content:center;color:white;font-weight:700">‚úâÔ∏è</div>
        <div>
          <h3 style="margin:0;font-size:18px;color:#111827;font-weight:700">Connect Telegram</h3>
          <div style="color:#6b7280;font-size:13px">Get notified via Telegram ‚Äî you don‚Äôt need to keep this page open.</div>
        </div>
      </div>

      <div style="margin-top:8px;color:#374151">
        <p style="margin:0 0 10px 0">Tap <strong>Connect via Telegram</strong> to open the secure link and finish setup. If your browser blocks popups, allow popups for this site.</p>
      </div>

      <div style="display:flex;gap:10px;margin-top:14px">
        <button id="onboardingConnectBtn" class="btn" style="background:linear-gradient(135deg,var(--purple-1),var(--purple-2));color:white;border:none;padding:10px 14px;border-radius:10px;font-weight:700">Connect via Telegram</button>
        <button id="onboardingSkipBtn" class="btn" style="background:transparent;border:1px solid #e6e6f6;padding:10px 14px;border-radius:10px;font-weight:700;color:#374151">Maybe later</button>
      </div>
      <p id="onboardingStatus" style="margin-top:10px;color:#6b7280;font-size:13px"></p>
    </div>
  </div>

  <!-- Main card -->
  <div class="card fade-in" role="main" aria-live="polite">
    <div class="absolute top-4 right-4 flex gap-2" style="position:absolute; right:18px; top:18px;">
      <button id="gameBtn" title="Game" class="circle-btn" aria-label="Game">üéÆ</button>
      <button id="connectTopBtn" title="Connect Telegram" class="circle-btn" aria-label="Connect Telegram">‚úâÔ∏è</button>
    </div>

    <div style="display:flex; gap:18px; align-items:center; justify-content:center; flex-direction:column">
      <div class="logo-circle">QJ</div>
      <h1 style="font-size:20px;margin-top:8px;color:#111827;font-weight:800">You are now in line</h1>
      <p style="margin:0;color:#6b7280;max-width:560px;text-align:center">Welcome. We‚Äôll notify you when it‚Äôs your turn. Connect Telegram to receive notifications even with this page closed.</p>
    </div>

    <!-- progress bar -->
    <div style="margin-top:18px">
      <div class="progress-track" aria-hidden="true">
        <div id="progressFill" class="progress-fill" style="width:6%"> <span id="progressLabel" style="font-size:12px;padding-left:8px;padding-right:8px;border-radius:8px;background:rgba(0,0,0,0.12);margin-left:auto">0%</span></div>
      </div>
    </div>

    <!-- main numbers -->
    <div style="margin-top:18px;display:grid;grid-template-columns:1fr 1fr;gap:14px">
      <div class="glass">
        <p style="margin:0;color:#6b7280;font-weight:700;font-size:13px">Your Number</p>
        <div id="yourNumber" style="font-size:34px;font-weight:900;color:var(--purple-1);margin-top:8px">‚Äî</div>
      </div>

      <div class="glass">
        <p style="margin:0;color:#6b7280;font-weight:700;font-size:13px">Now Serving</p>
        <div id="nowServing" style="font-size:34px;font-weight:900;color:#374151;margin-top:8px">‚Äî</div>
      </div>
    </div>

    <!-- people ahead / estimated wait -->
    <div style="margin-top:14px;display:grid;grid-template-columns:1fr 1fr;gap:14px">
      <div class="glass" style="text-align:left">
        <p style="margin:0;color:#6b7280;font-weight:700;font-size:13px">People Ahead</p>
        <div id="peopleAhead" style="font-size:22px;font-weight:800;color:#111827;margin-top:8px">‚Äî</div>
      </div>

      <div class="glass" style="text-align:left">
        <p style="margin:0;color:#6b7280;font-weight:700;font-size:13px">Estimated Wait</p>
        <div id="estimatedWait" style="font-size:22px;font-weight:800;color:var(--purple-1);margin-top:8px">‚Äî</div>
      </div>
    </div>

    <!-- connection banner -->
    <div id="connectionBanner" style="margin-top:18px;padding:14px;border-radius:12px;background:linear-gradient(90deg,rgba(167,139,250,0.07),rgba(139,92,246,0.03));border:1px solid rgba(139,92,246,0.06);display:flex;align-items:center;gap:12px">
      <div style="width:42px;height:42px;border-radius:10px;background:linear-gradient(135deg,var(--purple-1),var(--purple-2));display:flex;align-items:center;justify-content:center;color:white">üîî</div>
      <div>
        <div id="connectionBannerText" style="font-weight:700;color:#111827">Checking notification status...</div>
        <div style="color:#6b7280;font-size:13px" id="connectionBannerSub">You can connect Telegram for push notifications.</div>
      </div>
      <div style="margin-left:auto;min-width:130px">
        <button id="connectBtn" class="btn-gradient">Connect via Telegram</button>
      </div>
    </div>

    <div id="errorBox" style="display:none;margin-top:12px;padding:12px;border-radius:10px;background:#fff5f5;border:1px solid #ffe4e6;color:#b91c1c;font-weight:700;text-align:center"></div>
  </div>

  <!-- Ad panel (bottom center) -->
  <div id="adPanel" class="ad-panel" style="display:none">
    <div style="font-size:12px;color:#9CA3AF;text-align:center;margin-bottom:6px">Advertisement</div>
    <div id="adContainer"><!-- ad injected here --></div>
  </div>

  <script type="module">
    // Firebase imports (v10 modular)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getDatabase, ref, onValue, off, get, query, orderByChild } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

    // === CONFIG ===
    const CREATE_LINK_ENDPOINT = '/.netlify/functions/createTelegramLink';
    const MARK_TOKEN_USED = '/.netlify/functions/markTokenUsed';
    const TELEGRAM_BOT_URL = 'https://t.me/QueueJoyBot';

    // Use your project's Firebase config (kept from your original project)
    const firebaseConfig = {
      apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
      authDomain: "queue-joy-aa21b.firebaseapp.com",
      databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "queue-joy-aa21b",
      storageBucket: "queue-joy-aa21b.firebasestorage.app",
      messagingSenderId: "950240394209",
      appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
    };

    // === INIT ===
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // DOM refs
    const yourNumberEl = document.getElementById('yourNumber');
    const nowServingEl = document.getElementById('nowServing');
    const peopleAheadEl = document.getElementById('peopleAhead');
    const estimatedWaitEl = document.getElementById('estimatedWait');
    const progressFill = document.getElementById('progressFill');
    const progressLabel = document.getElementById('progressLabel');
    const connectionBannerText = document.getElementById('connectionBannerText');
    const connectionBannerSub = document.getElementById('connectionBannerSub');
    const connectBtn = document.getElementById('connectBtn');
    const connectTopBtn = document.getElementById('connectTopBtn');
    const onboardingModal = document.getElementById('onboardingModal');
    const onboardingConnectBtn = document.getElementById('onboardingConnectBtn');
    const onboardingSkipBtn = document.getElementById('onboardingSkipBtn');
    const onboardingStatus = document.getElementById('onboardingStatus');
    const adPanel = document.getElementById('adPanel');
    const adContainer = document.getElementById('adContainer');
    const connectTopButton = document.getElementById('connectTopBtn');
    const errorBox = document.getElementById('errorBox');

    // state
    let currentQueueKey = null;
    let currentQueueData = null;
    let currentCounterId = null;
    let latestConnectLink = null;
    let linkGenerating = false;
    let avgServiceTimeForCounter = 3; // minutes fallback

    // helpers
    function showError(msg){
      errorBox.style.display = 'block';
      errorBox.textContent = msg;
      setTimeout(()=> errorBox.style.display = 'none', 6000);
    }

    function setTelegramConnectedUI(connected){
      if(connected){
        connectionBannerText.textContent = "Connected ‚Äî you'll get Telegram notifications";
        connectionBannerSub.textContent = "You can close the page; Telegram will notify you when it's your turn.";
        connectBtn.textContent = "Connected";
        connectBtn.disabled = true;
      } else {
        connectionBannerText.textContent = "Not connected ‚Äî get Telegram notifications";
        connectionBannerSub.textContent = "Connect to receive notifications even when this page is closed.";
        connectBtn.textContent = "Connect via Telegram";
        connectBtn.disabled = false;
      }
    }

    // generate secure link (calls your Netlify function)
    async function generateConnectLink(){
      if(!currentQueueKey) throw new Error('missing queueKey');
      const res = await fetch(CREATE_LINK_ENDPOINT, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ queueKey: currentQueueKey })
      });
      if(!res.ok) {
        const txt = await res.text().catch(()=>'');
        throw new Error(`Create link failed ${res.status} ${txt}`);
      }
      const j = await res.json();
      if(!j.link) throw new Error('no link returned');
      return j.link;
    }

    async function openConnectLink(){
      // ensure link exists
      if(!latestConnectLink && !linkGenerating){
        linkGenerating = true;
        try{
          latestConnectLink = await generateConnectLink();
        }catch(e){
          latestConnectLink = TELEGRAM_BOT_URL;
        } finally {
          linkGenerating = false;
        }
      }
      // open new window
      const win = window.open(latestConnectLink || TELEGRAM_BOT_URL, '_blank', 'noopener,noreferrer');
      // try to mark used token server-side (server expects `start=` token)
      try{
        const token = (latestConnectLink && latestConnectLink.split('start=')[1]) || null;
        if(token && currentQueueKey){
          await fetch(MARK_TOKEN_USED, {
            method:'POST', headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ queueKey: currentQueueKey, token })
          });
        }
      }catch(e){}
    }

    // onboarding modal handlers
    connectBtn.addEventListener('click', () => {
      onboardingModal.style.display = 'flex';
      onboardingStatus.textContent = '';
    });
    connectTopBtn.addEventListener('click', () => {
      onboardingModal.style.display = 'flex';
      onboardingStatus.textContent = '';
    });

    onboardingConnectBtn.addEventListener('click', async () => {
      onboardingStatus.textContent = 'Generating link...';
      onboardingConnectBtn.disabled = true;
      try{
        await openConnectLink();
        onboardingStatus.textContent = 'Opened Telegram';
        setTimeout(()=> onboardingModal.style.display = 'none', 700);
      }catch(e){
        onboardingStatus.textContent = 'Failed to open link ‚Äî try again';
        onboardingConnectBtn.disabled = false;
      }
    });
    onboardingSkipBtn.addEventListener('click', () => onboardingModal.style.display = 'none');

    // ad support: can accept video URL or data:video/* or image/gif
    function clearAd(){
      adContainer.innerHTML = '';
      adPanel.style.display = 'none';
    }
    function showAdFromUrl(url){
      clearAd();
      if(!url) return;
      const trimmed = String(url).trim();
      const isVideo = /\.(mp4|webm|ogg)(\?.*)?$/i.test(trimmed) || trimmed.startsWith('data:video/');
      adPanel.style.display = 'block';
      if(isVideo){
        const v = document.createElement('video');
        v.src = trimmed;
        v.autoplay = true;
        v.muted = true;
        v.loop = true;
        v.playsInline = true;
        v.className = 'ad-media';
        v.setAttribute('playsinline','');
        v.setAttribute('muted','');
        adContainer.appendChild(v);
        v.play().catch(()=>v.setAttribute('controls',''));
      } else {
        const img = document.createElement('img');
        img.src = trimmed;
        img.className = 'ad-media';
        img.alt = 'Advertisement';
        img.onerror = () => { clearAd(); };
        adContainer.appendChild(img);
      }
    }

    // compute avg service time for a counter (minutes)
    async function computeAvgServiceTime(counterId, counterData){
      // prefer explicit counter.avgServiceTime
      let avg = (counterData && Number(counterData.avgServiceTime));
      if(Number.isFinite(avg) && avg > 0) return avg;

      // try global settings
      try {
        const snap = await get(ref(db, 'settings/avgServiceTime'));
        if(snap && snap.exists()){
          const val = Number(snap.val());
          if(Number.isFinite(val) && val > 0) return val;
        }
      }catch(e){/* ignore */ }

      // fallback to 3 minutes
      return 3;
    }

    // Recompute estimated wait: people ahead * avgServiceTime
    function formatMinutesReadable(mins){
      const m = Math.max(0, Math.round(mins));
      if(m === 0) return 'Less than a minute';
      if(m < 60) return `${m} min${m>1?'s':''}`;
      const hrs = Math.floor(m/60), rem = m%60;
      return rem === 0 ? `${hrs} hr${hrs>1?'s':''}` : `${hrs} hr ${rem} min`;
    }

    // Main subscription: read queue entry for queueId from URL
    document.addEventListener('DOMContentLoaded', () => {
      const params = new URLSearchParams(window.location.search);
      const queueKey = params.get('queueId');
      if(!queueKey){
        showError('Queue ID missing. Redirecting...');
        setTimeout(()=> window.location.href = 'index.html', 1400);
        return;
      }
      currentQueueKey = queueKey;
      const qRef = ref(db, `queue/${queueKey}`);

      // Listen for ad changes (global settings path)
      const adRef = ref(db, 'settings/adImage');
      onValue(adRef, (snap) => {
        const adUrl = snap.exists()? snap.val() : null;
        if(adUrl) showAdFromUrl(adUrl); else clearAd();
      });

      // Listen to our specific queue entry
      onValue(qRef, async (snap) => {
        if(!snap.exists()){
          showError('Queue entry not found. Returning...');
          setTimeout(()=> window.location.href = 'index.html', 1600);
          return;
        }
        currentQueueData = snap.val();
        yourNumberEl.textContent = currentQueueData.queueId || '--';
        setTelegramConnectedUI(!!currentQueueData.telegramConnected);

        // if this queue entry has counterId, subscribe to that counter
        const counterId = currentQueueData.counterId || null;
        if(counterId && counterId !== currentCounterId){
          if(currentCounterId){
            try { off(ref(db, `counters/${currentCounterId}`)); } catch(e){}
          }
          currentCounterId = counterId;
          const cRef = ref(db, `counters/${counterId}`);
          onValue(cRef, async (cSnap) => {
            if(!cSnap.exists()) return;
            const cData = cSnap.val();
            // update now serving display
            nowServingEl.textContent = (cData.nowServing !== undefined && cData.nowServing !== null) ? String(cData.nowServing).padStart(1,'') : '--';

            // compute avg service time for counter
            avgServiceTimeForCounter = await computeAvgServiceTime(counterId, cData);
            // after updating avgServiceTime, recompute people ahead (we will do that below when reading the queue list)
            computePeopleAheadAndEstimate();
          });
        } else {
          // ensure nowServing shows a default if no counter subscribed yet
          if(!counterId) nowServingEl.textContent = '--';
        }

        // any time our queue entry changes, recompute people ahead & estimated wait
        computePeopleAheadAndEstimate();
      });

      // Also listen to entire queue list (for live people-ahead computing)
      const allQueueRef = ref(db, 'queue');
      onValue(allQueueRef, (snap) => {
        // recompute on any change
        computePeopleAheadAndEstimate();
      });

      // cleanup on unload
      window.addEventListener('beforeunload', () => {
        try{
          off(qRef);
          off(adRef);
          off(allQueueRef);
          if(currentCounterId) off(ref(db, `counters/${currentCounterId}`));
        }catch(e){}
      });
    });

    // Compute people ahead and estimated wait by scanning queue list
    async function computePeopleAheadAndEstimate(){
      try {
        if(!currentQueueData) return;
        const queueSnap = await get(ref(db,'queue'));
        if(!queueSnap.exists()){
          peopleAheadEl.textContent = '0';
          estimatedWaitEl.textContent = formatMinutesReadable(0);
          updateProgress(0);
          return;
        }
        const all = queueSnap.val();
        const myTimestamp = Number(currentQueueData.timestamp) || 0;
        const myCounter = currentQueueData.counterId || null;
        let ahead = 0;

        if(myCounter){
          for(const k in all){
            if(!Object.prototype.hasOwnProperty.call(all,k)) continue;
            const t = all[k];
            // Count those assigned to same counter and still waiting (status='waiting') AND older than our timestamp
            if(t && String(t.counterId) === String(myCounter) && t.status === 'waiting' && (Number(t.timestamp) < myTimestamp)){
              ahead++;
            }
            // If nowServing is represented as queueId and we are in waiting, those being served shouldn't count
          }
        } else {
          // If no counter assigned yet, fallback: count all waiting items earlier than us
          for(const k in all){
            if(!Object.prototype.hasOwnProperty.call(all,k)) continue;
            const t = all[k];
            if(t && t.status === 'waiting' && (Number(t.timestamp) < myTimestamp)){
              ahead++;
            }
          }
        }

        peopleAheadEl.textContent = String(ahead);
        // ensure avgServiceTimeForCounter is set (fallback to 3)
        const avg = (Number(avgServiceTimeForCounter) && avgServiceTimeForCounter>0) ? Number(avgServiceTimeForCounter) : 3;
        const estMinutes = Math.round(ahead * avg);
        estimatedWaitEl.textContent = ahead === 0 ? 'Now' : `${ahead} person${ahead>1?'s':''} ‚Äî approx ${formatMinutesReadable(estMinutes)}`;
        // progress: estimate how close you are as percent (cap at 95 before Now)
        const maxSeen = Math.max(1, ahead + 2); // naive bucket
        const percent = Math.max(0, Math.min(100, Math.round(((maxSeen - ahead) / maxSeen) * 100)));
        updateProgress(percent);
      } catch(e){
        console.warn('estimate compute error', e);
        showError('Error computing estimated wait');
      }
    }

    function updateProgress(percent){
      progressFill.style.width = `${percent}%`;
      progressLabel.textContent = `${percent}%`;
      if(percent >= 95) progressLabel.textContent = 'Almost';
    }

    // subscribe to admin ad setting (already wired above via adRef in DOMContentLoaded),
    // but also fallback: try reading once now
    (async function initAdOnce(){
      try{
        const snap = await get(ref(db,'settings/adImage'));
        if(snap && snap.exists()){
          showAdFromUrl(snap.val());
        }
      }catch(e){}
    })();

    // For convenience, allow quick "game" link and fallback navigation
    document.getElementById('gameBtn').addEventListener('click', ()=>window.location.href='https://queuejoy.netlify.app/game.html');

    // Prevent accidental multiple clicks (generate link on demand)
    let creatingLink = false;
    connectBtn.addEventListener('click', async () => {
      if(creatingLink) return;
      creatingLink = true;
      connectBtn.textContent = 'Opening...';
      try{
        await openConnectLink();
      }catch(e){
        showError('Unable to open Telegram link.');
      } finally {
        creatingLink = false;
      }
    });

    // allow top connect icon to open onboarding
    connectTopButton.addEventListener('click', ()=> onboardingModal.style.display = 'flex');

  </script>
</body>
</html>
