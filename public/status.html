<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Queue Joy — Status</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .fade-in{animation:fadeIn .45s ease-out}.qj-backdrop{background:rgba(15,23,42,0.6);position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:60}
    @keyframes fadeIn{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:translateY(0)}}
    .hidden{display:none}
    .monos { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; font-size:13px }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 flex items-center justify-center p-4">

  <!-- NAMEPLACER: SERVER / SECRET CONFIG (DO NOT PUT SECRETS IN CLIENT)
       If you want to keep a single place to remember where your server keys live,
       place them in your serverless function / backend, not here.
       Example (server-side only):
         TELEGRAM_BOT_TOKEN = '<INSERT_BOT_TOKEN_HERE>'
         TELEGRAM_API_ID    = '<INSERT_API_ID_HERE>'
         TELEGRAM_API_HASH  = '<INSERT_API_HASH_HERE>'
  -->

  <!-- MAIN -->
  <div class="w-full max-w-sm bg-white rounded-2xl shadow-xl p-6 text-center fade-in">
    <div class="mb-4">
      <div class="w-16 h-16 bg-gradient-to-r from-purple-600 to-indigo-500 rounded-full mx-auto grid place-items-center text-white mb-2">
        <svg class="w-8 h-8" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
        </svg>
      </div>
      <h1 class="text-2xl font-bold text-indigo-800">Queue Status</h1>
      <p id="counterName" class="text-sm text-gray-600 mt-1">--</p>
    </div>

    <div class="bg-gradient-to-r from-purple-100 to-indigo-100 rounded-xl p-4 border-2 border-purple-200 mb-4">
      <div class="text-sm text-purple-600 font-medium">Your Number</div>
      <div id="yourNumber" class="mt-2 text-4xl font-bold text-purple-800">--</div>
    </div>

    <div class="grid grid-cols-1 gap-3 mb-2">
      <div class="bg-gray-50 rounded-xl p-4">
        <div class="flex justify-between items-center mb-2">
          <span class="text-sm text-gray-600">Now Serving</span>
          <div id="statusIndicator" class="w-3 h-3 bg-green-400 rounded-full"></div>
        </div>
        <div id="nowServing" class="text-2xl font-bold text-indigo-600">--</div>
      </div>

      <div class="grid grid-cols-2 gap-3">
        <div class="bg-gray-50 rounded-xl p-3 text-center">
          <div class="text-sm text-gray-600">People Ahead</div>
          <div id="peopleAhead" class="text-xl font-bold">--</div>
        </div>
        <div class="bg-gray-50 rounded-xl p-3 text-center">
          <div class="text-sm text-gray-600">Est. Wait</div>
          <div id="estimatedWait" class="text-xl font-bold">--</div>
        </div>
      </div>
    </div>

    <div class="text-xs text-gray-400" id="fbStatus">Connecting to Firebase…</div>
  </div>

  <!-- Telegram Connect Modal -->
  <div id="telegramModal" class="qj-backdrop hidden">
    <div class="bg-white rounded-2xl p-6 w-full max-w-md mx-4">
      <h3 class="text-lg font-bold text-indigo-800">Connect Telegram Bot</h3>
      <p class="text-sm text-gray-600 mt-2">
        Two ways to connect:
        <ol class="text-xs text-gray-500 mt-1 list-decimal list-inside">
          <li>One-click: generate a secure token and press "Open Bot" → tap Start in Telegram (recommended).</li>
          <li>Manual: paste your Telegram chat id and save (trusted deployments only).</li>
        </ol>
      </p>

      <div class="mt-4 space-y-3">
        <label class="text-xs text-gray-600">Bot username (without @)</label>
        <input id="tgBot" type="text" placeholder="your_bot_username" class="w-full border rounded px-3 py-2" />

        <div class="flex gap-2">
          <button id="tgGenerate" class="flex-1 px-4 py-2 bg-indigo-600 text-white rounded-lg">Generate Start Token</button>
          <button id="tgOpen" class="px-4 py-2 border rounded-lg">Open Telegram</button>
        </div>

        <div class="pt-2 border-t"></div>

        <label class="text-xs text-gray-600">Or enter chat id / @username</label>
        <input id="tgChat" type="text" placeholder="@yourusername or chat_id" class="w-full border rounded px-3 py-2" />
        <div class="flex gap-2 mt-2">
          <button id="tgSaveChat" class="px-4 py-2 bg-indigo-600 text-white rounded-lg">Save Chat ID</button>
          <button id="tgDismiss" class="px-4 py-2 text-sm text-gray-600">Dismiss</button>
        </div>

        <div id="tgNote" class="text-xs text-gray-500 mt-2 monos">Tip: One-click Start token will let your bot/server link your Telegram account automatically when you press Start in Telegram.</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
    import { getDatabase, ref, onValue, off, get, set } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js';

    /* ---------- CONFIG ---------- */
    const firebaseConfig = {
      apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
      authDomain: "queue-joy-aa21b.firebaseapp.com",
      databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "queue-joy-aa21b",
      storageBucket: "queue-joy-aa21b.firebasestorage.app",
      messagingSenderId: "950240394209",
      appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
    };

    // IMPORTANT: keep bot token & api_hash on server-side only. DO NOT place secrets here.
    // NAMEPLACER: server-side placeholders (for your record)
    // TELEGRAM_BOT_TOKEN = '<INSERT_BOT_TOKEN_ON_SERVER>'
    // TELEGRAM_API_ID = '<INSERT_API_ID_ON_SERVER>'
    // TELEGRAM_API_HASH = '<INSERT_API_HASH_ON_SERVER>'
    // SERVER_ENDPOINT (example): '/.netlify/functions/linkTelegram'  <-- server reads pending token and links chatId

    /* ---------- DOM ---------- */
    const yourNumberEl = document.getElementById('yourNumber');
    const counterNameEl = document.getElementById('counterName');
    const nowServingEl = document.getElementById('nowServing');
    const peopleAheadEl = document.getElementById('peopleAhead');
    const estimatedWaitEl = document.getElementById('estimatedWait');
    const fbStatusEl = document.getElementById('fbStatus');
    const statusIndicator = document.getElementById('statusIndicator');

    const telegramModal = document.getElementById('telegramModal');
    const tgBotInput = document.getElementById('tgBot');
    const tgGenerateBtn = document.getElementById('tgGenerate');
    const tgOpenBtn = document.getElementById('tgOpen');
    const tgChatInput = document.getElementById('tgChat');
    const tgSaveChatBtn = document.getElementById('tgSaveChat');
    const tgDismissBtn = document.getElementById('tgDismiss');

    /* ---------- STATE ---------- */
    let app, db;
    let queueKey = null;
    let queueRef = null;
    let counterRef = null;
    let servingRef = null;
    let yourNumberRaw = null;
    let wakeLock = null;
    let wakePreferred = localStorage.getItem('qj_wake_pref') === 'true';
    let fallbackIntervalHandle = null;

    /* ---------- INIT FIREBASE ---------- */
    try {
      app = initializeApp(firebaseConfig);
      db = getDatabase(app);
      fbStatusEl.textContent = 'Connected to Firebase';
    } catch (e) {
      fbStatusEl.textContent = 'Firebase init failed';
      console.error(e);
    }

    // get queueKey
    const usp = new URLSearchParams(window.location.search);
    queueKey = usp.get('queueId') || usp.get('qid') || usp.get('id');
    if (!queueKey) {
      fbStatusEl.textContent = 'Missing queueId in URL';
      yourNumberEl.textContent = '--';
      counterNameEl.textContent = '--';
      throw new Error('Missing queueId');
    }

    /* ---------- Telegram modal logic ---------- */
    function showTelegramModalIfNeeded() {
      const hidden = localStorage.getItem('qj_tg_dontshow') === 'true';
      const connected = !!localStorage.getItem('qj_tg_connected_' + queueKey);
      if (!hidden && !connected) telegramModal.classList.remove('hidden');
    }

    // load saved bot username & chat
    tgBotInput.value = localStorage.getItem('qj_tg_bot') || '';
    tgChatInput.value = localStorage.getItem('qj_tg_chat') || '';

    // Option A: generate start token stored in Firebase and open t.me/<bot>?start=<token>
    tgGenerateBtn.addEventListener('click', async () => {
      const bot = (tgBotInput.value || localStorage.getItem('qj_tg_bot') || '').trim();
      if (!bot) { alert('Enter bot username first (without @).'); return; }

      // generate secure random token (URL-safe)
      const token = generateToken(20);
      try {
        // write a short-lived pending mapping in Firebase: telegramPending/{token} -> { queueKey, createdAt }
        await set(ref(db, `telegramPending/${token}`), { queueKey, createdAt: Date.now() });
        localStorage.setItem('qj_tg_bot', bot);
        // open Telegram bot start link
        const url = `https://t.me/${encodeURIComponent(bot)}?start=${encodeURIComponent(token)}`;
        window.open(url, '_blank');
        alert('Bot opened. Tap Start in Telegram to complete link.');
      } catch (e) {
        console.error('failed to write pending token', e);
        alert('Could not create start token. Try again.');
      }
    });

    // Option B: manual chat id write (client writes chat id to queue entry)
    tgSaveChatBtn.addEventListener('click', async () => {
      const chat = (tgChatInput.value || '').trim();
      if (!chat) { alert('Paste chat id or @username'); return; }
      try {
        // Save locally and write to queue entry (server should validate in production)
        localStorage.setItem('qj_tg_chat', chat);
        await set(ref(db, `queue/${queueKey}/telegramChatId`), chat);
        localStorage.setItem('qj_tg_connected_' + queueKey, 'true');
        telegramModal.classList.add('hidden');
        alert('Chat id saved for this queue. Server may verify before sending messages.');
      } catch (e) {
        console.error('save chat failed', e);
        alert('Failed to save chat id. Check console.');
      }
    });

    tgOpenBtn.addEventListener('click', () => {
      const bot = (tgBotInput.value || localStorage.getItem('qj_tg_bot') || '').trim();
      if (!bot) { alert('Enter bot username first (without @).'); return; }
      window.open(`https://t.me/${encodeURIComponent(bot)}`, '_blank');
    });
    tgDismissBtn.addEventListener('click', () => telegramModal.classList.add('hidden'));

    // small helper: secure random token
    function generateToken(length = 24) {
      const bytes = new Uint8Array(length);
      crypto.getRandomValues(bytes);
      // base36-ish URL safe
      return Array.from(bytes).map(b => ('0' + (b % 36).toString(36)).slice(-1)).join('');
    }

    // show modal if not connected
    showTelegramModalIfNeeded();

    /* ---------- Wake Lock (keeps screen awake while visible) ---------- */
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          localStorage.setItem('qj_wake_pref', 'true');
          wakePreferred = true;
          console.log('[wake] acquired');
          wakeLock.addEventListener('release', () => {
            console.log('[wake] released');
            if (wakePreferred) tryReacquireWake();
          });
          document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible' && wakePreferred && !wakeLock) {
              try { wakeLock = await navigator.wakeLock.request('screen'); console.log('[wake] reacquired'); } catch(e){ console.warn(e); }
            }
          });
        }
      } catch (e) { console.warn('Wake request failed', e); }
    }
    async function releaseWakeLock() {
      try { if (wakeLock) { await wakeLock.release(); wakeLock = null; localStorage.setItem('qj_wake_pref','false'); wakePreferred = false; } } catch(e){ console.warn(e); }
    }
    async function tryReacquireWake() {
      if (wakePreferred && 'wakeLock' in navigator && !wakeLock) {
        try { wakeLock = await navigator.wakeLock.request('screen'); console.log('[wake] reacquired'); } catch(e){ console.warn(e); }
      }
    }
    if (wakePreferred) tryReacquireWake();
    // quick toggle: double click to toggle wake lock
    document.addEventListener('dblclick', async () => { if (wakeLock) await releaseWakeLock(); else await requestWakeLock(); });

    /* ---------- Firebase listeners & fallback polling ---------- */
    function parseTicketNum(ticket) {
      if (!ticket) return NaN;
      const s = String(ticket);
      const letters = s.match(/^[A-Za-z]+/);
      const numPart = letters ? s.slice(letters[0].length) : s;
      return parseInt(numPart, 10) || 0;
    }

    function attachQueueListener() {
      queueRef = ref(db, `queue/${queueKey}`);
      onValue(queueRef, snap => {
        if (!snap.exists()) {
          yourNumberEl.textContent = '--'; counterNameEl.textContent = '--'; fbStatusEl.textContent = 'Queue not found';
          return;
        }
        const q = snap.val() || {};
        const ticket = q.queueId || q.ticketNumber || q.id || q.number || q.queueNo || q.ticket || '--';
        yourNumberEl.textContent = ticket;
        yourNumberRaw = ticket;

        const counterId = q.counterAssigned || q.counterId || q.counter || null;
        if (counterId) attachCounterListeners(counterId, ticket);
      }, err => { console.warn('queue read err', err); fbStatusEl.textContent = 'Failed to read queue'; });
    }

    function attachCounterListeners(counterId) {
      counterRef = ref(db, `settings/counters/${counterId}`);
      onValue(counterRef, cSnap => {
        if (!cSnap.exists()) return;
        const cData = cSnap.val() || {};
        counterNameEl.textContent = cData.name || `Counter ${counterId}`;
      });

      servingRef = ref(db, `counters/${counterId}/nowServing`);
      onValue(servingRef, nowSnap => {
        const current = nowSnap.exists() ? nowSnap.val() : 0;
        nowServingEl.textContent = String(current);
        evaluateAheadAndMaybeRedirect(current, counterId);
      });
    }

    async function periodicFallback(counterId) {
      if (!counterId) return;
      try {
        const sRef = ref(db, `counters/${counterId}/nowServing`);
        const snap = await get(sRef);
        if (snap.exists()) {
          const current = snap.val();
          nowServingEl.textContent = String(current);
          evaluateAheadAndMaybeRedirect(current, counterId);
        }
      } catch (e) { console.warn('periodic get failed', e); }
    }
    function startPeriodicFallback(counterId) { if (fallbackIntervalHandle) clearInterval(fallbackIntervalHandle); fallbackIntervalHandle = setInterval(()=> periodicFallback(counterId), 8000); }
    function stopPeriodicFallback() { if (fallbackIntervalHandle) clearInterval(fallbackIntervalHandle); }

    function evaluateAheadAndMaybeRedirect(currentServingValue, counterId) {
      const ticket = yourNumberRaw;
      if (!ticket) return;
      const prefixMatch = String(ticket).match(/^[A-Za-z]+/);
      const prefix = prefixMatch ? prefixMatch[0] : '';
      const ticketNum = parseTicketNum(ticket);
      const currentNum = parseTicketNum(prefix ? (String(currentServingValue).replace(prefix, '')) : currentServingValue);
      const ahead = Math.max(0, ticketNum - currentNum);
      peopleAheadEl.textContent = ahead;
      estimatedWaitEl.textContent = ahead > 0 ? `${ahead * 2} min` : 'Now';

      if (ahead === 0) {
        statusIndicator.className = 'w-3 h-3 bg-green-400 rounded-full animate-pulse';
        const redirectKey = `qj_redirected_${queueKey}`;
        if (!localStorage.getItem(redirectKey)) {
          localStorage.setItem(redirectKey, 'true');
          // redirect user to your_turn page silently
          window.location.href = `/your_turn.html?queueId=${encodeURIComponent(queueKey)}`;
        }
      } else if (ahead <= 2) {
        statusIndicator.className = 'w-3 h-3 bg-yellow-400 rounded-full';
      } else {
        statusIndicator.className = 'w-3 h-3 bg-blue-400 rounded-full';
      }

      // start fallback once we know counterId
      if (counterId) startPeriodicFallback(counterId);
    }

    // initial attach
    attachQueueListener();

    // attempt to find counterId (then start fallback)
    const counterFinder = setInterval(async () => {
      try {
        const qRef = ref(db, `queue/${queueKey}`);
        const qSnap = await get(qRef);
        if (qSnap.exists()) {
          const q = qSnap.val() || {};
          const counterId = q.counterAssigned || q.counterId || q.counter || null;
          if (counterId) { startPeriodicFallback(counterId); clearInterval(counterFinder); }
        }
      } catch(e){ console.warn(e); }
    }, 1000);

    // visibility handling: reattach listeners and try reacquire wake lock
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        tryReacquireWake();
        try { if (queueRef) off(queueRef); if (counterRef) off(counterRef); if (servingRef) off(servingRef); } catch(_) {}
        attachQueueListener();
      }
    });

    // cleanup
    window.addEventListener('beforeunload', () => {
      try { if (queueRef) off(queueRef); if (counterRef) off(counterRef); if (servingRef) off(servingRef); stopPeriodicFallback(); } catch(_) {}
    });

    // end of module
  </script>
</body>
</html>
