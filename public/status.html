<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>QueueJoy ‚Äî Your Status</title>
  <meta name="description" content="Track your queue position in real-time" />
  <meta name="theme-color" content="#8b5cf6" />

  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet" />

  <style>
    :root {
      --primary: #8b5cf6;
      --primary-dark: #7c3aed;
      --primary-light: #a78bfa;
      --bg-start: #f6f5ff;
      --bg-end: #ede9fe;
      --success: #10b981;
      --warning-bg: #fef3c7;
      --warning-border: #fcd34d;
      --warning-text: #92400e;
      --success-bg: #d1fae5;
      --success-border: #6ee7b7;
      --success-text: #065f46;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    html, body {
      font-family: Inter, system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
      min-height: 100vh;
      min-height: 100dvh;
      color: #1f2937;
      -webkit-font-smoothing: antialiased;
      overflow-x: hidden;
    }
    
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 16px;
      padding-bottom: 160px;
    }
    
    .page-wrapper {
      width: 100%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    /* Alert Banners - Now at top */
    .alert-banner {
      background: linear-gradient(135deg, var(--warning-bg), #fde68a);
      border: 1px solid var(--warning-border);
      color: var(--warning-text);
      padding: 16px;
      border-radius: 14px;
      font-size: 13px;
      font-weight: 600;
      text-align: center;
      line-height: 1.5;
    }

    .alert-banner strong {
      font-weight: 800;
    }

    .alert-banner.success {
      background: linear-gradient(135deg, var(--success-bg), #a7f3d0);
      border: 1px solid var(--success-border);
      color: var(--success-text);
    }
    
    .card {
      background: rgba(255, 255, 255, 0.97);
      border-radius: 24px;
      padding: 24px 20px;
      box-shadow: 0 20px 60px rgba(139, 92, 246, 0.15);
      position: relative;
    }

    .logo-box {
      width: 80px;
      height: 80px;
      border-radius: 20px;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 900;
      font-size: 28px;
      box-shadow: 0 12px 30px rgba(139, 92, 246, 0.3);
      overflow: hidden;
      flex-shrink: 0;
    }
    
    .logo-box img { width: 100%; height: 100%; object-fit: cover; }

    .header {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-bottom: 24px;
      padding-right: 80px;
    }

    .header-text h1 {
      font-size: 22px;
      font-weight: 800;
      color: #111827;
      line-height: 1.2;
    }

    .header-text p {
      color: #6b7280;
      margin-top: 6px;
      font-size: 14px;
      line-height: 1.4;
    }

    .top-buttons {
      position: absolute;
      right: 16px;
      top: 20px;
      display: flex;
      gap: 10px;
      z-index: 10;
    }

    .circle-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: #fff;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
    }
    
    .circle-btn:active { transform: scale(0.95); }

    /* Progress Section */
    .progress-section {
      margin-bottom: 20px;
    }

    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .progress-label {
      font-size: 14px;
      font-weight: 600;
      color: #374151;
    }

    .progress-status {
      font-size: 14px;
      font-weight: 700;
      color: var(--primary);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .progress-track {
      height: 28px;
      border-radius: 999px;
      background: #f3f4f6;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-dark), var(--primary));
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 12px;
      color: #fff;
      font-weight: 800;
      font-size: 13px;
      transition: width 0.6s cubic-bezier(0.22, 0.9, 0.22, 1);
      box-shadow: 0 4px 16px rgba(139, 92, 246, 0.4);
      min-width: 50px;
    }

    /* Stats Grid */
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    .glass-card {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(250, 248, 255, 0.9));
      border-radius: 16px;
      padding: 18px 16px;
      border: 1px solid rgba(139, 92, 246, 0.08);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.03);
    }
    
    .stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
      font-weight: 600;
    }
    
    .stat-value {
      font-weight: 900;
      font-size: 32px;
      margin-top: 8px;
      line-height: 1;
      word-break: break-word;
      color: var(--primary);
    }

    .stat-value.dark {
      color: #111827;
    }
    
    .stat-value-sm {
      font-weight: 800;
      font-size: 26px;
      margin-top: 8px;
      line-height: 1;
      color: #374151;
    }

    .stat-value-sm.highlight {
      color: var(--primary);
    }

    /* Connection Banner */
    .connection-banner {
      display: flex;
      align-items: center;
      gap: 14px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(250, 248, 255, 0.9));
      border-radius: 16px;
      padding: 16px;
      border: 1px solid rgba(139, 92, 246, 0.08);
    }

    .connection-icon {
      width: 52px;
      height: 52px;
      border-radius: 14px;
      background: linear-gradient(135deg, var(--primary-dark), var(--primary));
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 24px;
      flex-shrink: 0;
    }

    .connection-text {
      flex: 1;
      min-width: 0;
    }

    .connection-title {
      font-weight: 700;
      font-size: 14px;
      color: #111827;
      line-height: 1.3;
    }

    .connection-sub {
      color: #6b7280;
      font-size: 12px;
      margin-top: 4px;
      line-height: 1.3;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary-dark), var(--primary));
      color: #fff;
      padding: 14px 20px;
      border-radius: 12px;
      font-weight: 700;
      border: none;
      box-shadow: 0 8px 20px rgba(139, 92, 246, 0.3);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 14px;
      transition: transform 0.15s, box-shadow 0.15s, opacity 0.15s;
      min-height: 48px;
      white-space: nowrap;
    }
    
    .btn-primary:active { transform: scale(0.98); }
    .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

    .btn-connected {
      background: linear-gradient(135deg, #059669, var(--success));
    }

    /* Error */
    .error-banner {
      padding: 14px;
      border-radius: 12px;
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #b91c1c;
      font-weight: 600;
      font-size: 13px;
      text-align: center;
      display: none;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
      padding: 20px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.25s, visibility 0.25s;
    }
    
    .modal-overlay.show { opacity: 1; visibility: visible; }
    
    .modal-card {
      width: 100%;
      max-width: 380px;
      background: #fff;
      border-radius: 24px;
      padding: 28px 24px;
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.4);
      transform: translateY(20px) scale(0.96);
      transition: transform 0.3s cubic-bezier(0.22, 0.9, 0.22, 1);
    }
    
    .modal-overlay.show .modal-card {
      transform: translateY(0) scale(1);
    }

    .modal-icon {
      width: 100px;
      height: 100px;
      margin: 0 auto;
      border-radius: 24px;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 44px;
      color: #fff;
      box-shadow: 0 16px 40px rgba(139, 92, 246, 0.3);
    }

    .modal-icon.success {
      background: linear-gradient(135deg, var(--success), #059669);
      box-shadow: 0 16px 40px rgba(16, 185, 129, 0.3);
    }

    .modal-title {
      margin-top: 24px;
      font-size: 22px;
      font-weight: 800;
      color: #111827;
      text-align: center;
    }

    .modal-desc {
      color: #6b7280;
      margin-top: 12px;
      font-size: 15px;
      line-height: 1.6;
      text-align: center;
    }

    .step-dots {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin: 20px 0;
    }
    
    .step-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #e5e7eb;
      transition: all 0.25s;
    }
    
    .step-dot.active {
      width: 28px;
      background: linear-gradient(90deg, var(--primary-dark), var(--primary));
      box-shadow: 0 4px 10px rgba(139, 92, 246, 0.35);
    }

    .btn-outline {
      border: 2px solid rgba(139, 92, 246, 0.2);
      padding: 14px 16px;
      border-radius: 12px;
      background: #fff;
      font-weight: 600;
      cursor: pointer;
      font-size: 14px;
      color: #374151;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: background 0.15s;
      width: 100%;
    }
    
    .btn-outline:active { background: #f9fafb; }

    .btn-full {
      width: 100%;
    }

    .slide { display: none; }
    .slide.active { display: block; }

    .spinner {
      width: 18px;
      height: 18px;
      border: 3px solid rgba(255, 255, 255, 0.25);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
    }
    
    @keyframes spin { to { transform: rotate(360deg); } }

    .pulse { animation: pulse 2s ease-in-out infinite; }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.08); }
    }

    /* Ad panel */
    .ad-panel {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 12px;
      width: calc(100% - 32px);
      max-width: 400px;
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.2);
      padding: 12px;
      z-index: 100;
      display: none;
    }
    
    .ad-label {
      font-size: 9px;
      color: #9ca3af;
      text-align: center;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .ad-media {
      width: 100%;
      height: 100px;
      object-fit: cover;
      border-radius: 12px;
    }
  </style>
</head>
<body>

<div class="page-wrapper">

  <!-- Alert Banner - Now at TOP -->
  <div id="stayAlert" class="alert-banner" style="display: none">
    ‚ö†Ô∏è <strong>Stay on this page</strong> ‚Äî Only Telegram can notify you when the app is closed.
  </div>

  <!-- Connected Banner - Shows when Telegram is connected -->
  <div id="connectedAlert" class="alert-banner success" style="display: none">
    ‚úÖ <strong>You're all set!</strong> You can close this browser now. Sit back and relax ‚Äî we'll notify you on Telegram when it's your turn.
  </div>

  <!-- Onboarding Modal -->
  <div id="onboardingModal" class="modal-overlay" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true">
      
      <!-- Slide 1 -->
      <div class="slide active" data-slide="0">
        <div class="modal-icon">‚úâÔ∏è</div>
        <h3 class="modal-title">Get Telegram Notifications</h3>
        <p class="modal-desc">
          Only Telegram can notify you when the app is closed. Receive instant alerts on your phone when it's your turn.
        </p>
        <div class="step-dots">
          <div class="step-dot active"></div>
          <div class="step-dot"></div>
          <div class="step-dot"></div>
        </div>
        <button id="obNext" class="btn-primary btn-full">Continue ‚Üí</button>
        <button id="obSkip" class="btn-outline" style="margin-top: 12px">Skip for now</button>
      </div>

      <!-- Slide 2 -->
      <div class="slide" data-slide="1">
        <div class="modal-icon">‚ñ∂Ô∏è</div>
        <h3 class="modal-title">Tap "Start" in Telegram</h3>
        <p class="modal-desc">
          We'll open our bot. Tap <strong>Start</strong> to activate notifications.
        </p>
        <div class="step-dots">
          <div class="step-dot"></div>
          <div class="step-dot active"></div>
          <div class="step-dot"></div>
        </div>
        <button id="obNext2" class="btn-primary btn-full">Next ‚Üí</button>
        <button id="obBack1" class="btn-outline" style="margin-top: 12px">‚Üê Back</button>
      </div>

      <!-- Slide 3 -->
      <div class="slide" data-slide="2">
        <div class="modal-icon">‚úÖ</div>
        <h3 class="modal-title">Ready to Connect</h3>
        <p id="obStatusText" class="modal-desc">
          Generating your secure link...
        </p>
        <div class="step-dots">
          <div class="step-dot"></div>
          <div class="step-dot"></div>
          <div class="step-dot active"></div>
        </div>
        <button id="obFinish" class="btn-primary btn-full" disabled>
          <span id="obFinishContent">
            <span class="spinner"></span>
            <span>Generating...</span>
          </span>
        </button>
        <button id="obBack2" class="btn-outline" style="margin-top: 12px">‚Üê Back</button>
      </div>

      <!-- Connected Slide -->
      <div class="slide" data-slide="connected">
        <div class="modal-icon success">‚úÖ</div>
        <h3 class="modal-title">You're Connected!</h3>
        <p class="modal-desc">
          You'll get a Telegram notification when it's your turn.
        </p>
        <button id="obDone" class="btn-primary btn-full" style="margin-top: 24px">Got it!</button>
      </div>
      
    </div>
  </div>

  <!-- Main Card -->
  <main class="card">
    
    <!-- Top buttons -->
    <div class="top-buttons">
      <button id="miniGame" class="circle-btn" title="Play game">üéÆ</button>
      <button id="miniConnect" class="circle-btn pulse" title="Connect Telegram">‚úâÔ∏è</button>
    </div>

    <!-- Header -->
    <div class="header">
      <div class="logo-box" id="logoBox">
        <span id="logoText">QJ</span>
        <img id="logoImg" style="display: none" alt="Logo" />
      </div>
      <div class="header-text">
        <h1>You're in the queue</h1>
        <p>We're tracking your spot in real-time.</p>
      </div>
    </div>

    <!-- Progress -->
    <section class="progress-section">
      <div class="progress-header">
        <span class="progress-label">Queue Progress</span>
        <span id="progressCaption" class="progress-status">Loading...</span>
      </div>
      <div class="progress-track">
        <div id="progressFill" class="progress-fill" style="width: 8%">
          <span id="progressLabel">8%</span>
        </div>
      </div>
    </section>

    <!-- Stats Grid -->
    <section class="stats-grid">
      <div class="glass-card">
        <div class="stat-label">Your Ticket</div>
        <div id="yourNumber" class="stat-value">‚Äî</div>
      </div>
      <div class="glass-card">
        <div class="stat-label">Now Serving</div>
        <div id="nowServing" class="stat-value dark">‚Äî</div>
      </div>
    </section>

    <section class="stats-grid">
      <div class="glass-card">
        <div class="stat-label">People Ahead</div>
        <div id="peopleAhead" class="stat-value-sm">‚Äî</div>
      </div>
      <div class="glass-card">
        <div class="stat-label">Estimated Wait</div>
        <div id="estimatedWait" class="stat-value-sm highlight">‚Äî</div>
      </div>
    </section>

    <!-- Connection Banner -->
    <section id="connectionBanner" class="connection-banner">
      <div class="connection-icon">üîî</div>
      <div class="connection-text">
        <div id="connectionTitle" class="connection-title">Get Telegram notifications</div>
        <div id="connectionSub" class="connection-sub">Only Telegram can notify you when the app is closed.</div>
      </div>
      <button id="connectMain" class="btn-primary" style="padding: 12px 16px; font-size: 13px">
        Connect
      </button>
    </section>

    <!-- Error -->
    <div id="error" class="error-banner"></div>
    
  </main>

</div>

<!-- Ad Panel -->
<div id="adPanel" class="ad-panel">
  <div class="ad-label">Advertisement</div>
  <div id="adContainer"></div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
  import { getDatabase, ref, onValue, off, get } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

  // Config
  const CREATE_LINK_ENDPOINT = '/.netlify/functions/createTelegramLink';
  const MARK_TOKEN_USED = '/.netlify/functions/markTokenUsed';
  const TELEGRAM_BOT_URL = 'https://t.me/QueueJoyBot';
  const MAX_AHEAD = 20;

  const firebaseConfig = {
    apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
    authDomain: "queue-joy-aa21b.firebaseapp.com",
    databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "queue-joy-aa21b",
    storageBucket: "queue-joy-aa21b.firebasestorage.app",
    messagingSenderId: "950240394209",
    appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  // DOM
  const obModal = document.getElementById('onboardingModal');
  const slides = document.querySelectorAll('.slide');
  const stepDots = document.querySelectorAll('.step-dot');
  const obNext = document.getElementById('obNext');
  const obNext2 = document.getElementById('obNext2');
  const obBack1 = document.getElementById('obBack1');
  const obBack2 = document.getElementById('obBack2');
  const obSkip = document.getElementById('obSkip');
  const obFinish = document.getElementById('obFinish');
  const obFinishContent = document.getElementById('obFinishContent');
  const obStatusText = document.getElementById('obStatusText');
  const obDone = document.getElementById('obDone');
  
  const logoBox = document.getElementById('logoBox');
  const logoText = document.getElementById('logoText');
  const logoImg = document.getElementById('logoImg');
  const yourNumberEl = document.getElementById('yourNumber');
  const nowServingEl = document.getElementById('nowServing');
  const peopleAheadEl = document.getElementById('peopleAhead');
  const estimatedWaitEl = document.getElementById('estimatedWait');
  const progressFill = document.getElementById('progressFill');
  const progressLabel = document.getElementById('progressLabel');
  const progressCaption = document.getElementById('progressCaption');
  const connectMainBtn = document.getElementById('connectMain');
  const connectMiniBtn = document.getElementById('miniConnect');
  const connectionTitle = document.getElementById('connectionTitle');
  const connectionSub = document.getElementById('connectionSub');
  const stayAlert = document.getElementById('stayAlert');
  const connectedAlert = document.getElementById('connectedAlert');
  const adPanel = document.getElementById('adPanel');
  const adContainer = document.getElementById('adContainer');
  const errorBox = document.getElementById('error');

  // State
  let currentQueueKey = null;
  let currentQueueData = null;
  let currentCounterId = null;
  let latestConnectLink = null;
  let linkGenerating = false;
  let isTelegramConnected = false;
  let redirecting = false;
  let avgServiceTime = 3;
  let qRef = null, counterRef = null, adRef = null, analyticsRef = null;

  // Utilities
  function showError(msg) {
    if (!errorBox) return;
    errorBox.style.display = 'block';
    errorBox.textContent = msg;
    setTimeout(() => errorBox.style.display = 'none', 6000);
  }

  // Extract ONLY the numeric part from ticket strings like "COFFEE 001" -> 1
  function extractNumber(str) {
    if (str === null || str === undefined) return null;
    const s = String(str).trim();
    // Match digits at the end of the string
    const m = s.match(/(\d+)$/);
    if (m) {
      return parseInt(m[1], 10);
    }
    // If the whole string is a number
    if (/^\d+$/.test(s)) {
      return parseInt(s, 10);
    }
    return null;
  }

  function formatMinutes(m) {
    const mm = Math.max(0, Math.round(m));
    if (mm === 0) return 'Now';
    if (mm < 60) return `${mm} min`;
    const h = Math.floor(mm / 60), r = mm % 60;
    return r === 0 ? `${h}h` : `${h}h ${r}m`;
  }

  // Modal functions
  function showSlide(idx) {
    slides.forEach(s => s.classList.remove('active'));
    stepDots.forEach(d => d.classList.remove('active'));
    const slide = document.querySelector(`[data-slide="${idx}"]`);
    if (slide) slide.classList.add('active');
    if (typeof idx === 'number' && stepDots[idx]) stepDots[idx].classList.add('active');
    if (idx === 2) generateLink();
  }

  function openModal() {
    obModal.classList.add('show');
    if (isTelegramConnected) {
      showSlide('connected');
    } else {
      showSlide(0);
    }
  }

  function closeModal() {
    obModal.classList.remove('show');
  }

  obNext.onclick = () => showSlide(1);
  obNext2.onclick = () => showSlide(2);
  obBack1.onclick = () => showSlide(0);
  obBack2.onclick = () => showSlide(1);
  obSkip.onclick = () => {
    localStorage.setItem('qj_modal_skipped_' + currentQueueKey, 'true');
    closeModal();
  };
  obDone.onclick = closeModal;
  obModal.onclick = (e) => { if (e.target === obModal) closeModal(); };

  // Telegram link generation
  async function generateLink() {
    if (linkGenerating || latestConnectLink) return;
    linkGenerating = true;
    
    obFinish.disabled = true;
    obFinishContent.innerHTML = '<span class="spinner"></span><span>Generating...</span>';
    obStatusText.textContent = 'Creating secure link...';

    try {
      const res = await fetch(CREATE_LINK_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ queueKey: currentQueueKey })
      });
      
      if (!res.ok) throw new Error('Failed');
      
      const json = await res.json();
      let link = json.link || null;
      
      if (!link && json.token) {
        link = `${TELEGRAM_BOT_URL}?start=${json.token}`;
      }
      
      if (link && !link.includes('start=')) {
        const token = currentQueueData?.telegramToken || currentQueueData?.token || currentQueueKey;
        link = `${TELEGRAM_BOT_URL}?start=${token}`;
      }
      
      latestConnectLink = link || `${TELEGRAM_BOT_URL}?start=${currentQueueKey}`;
      obStatusText.textContent = 'Ready! Tap below to open Telegram.';
      obFinish.disabled = false;
      obFinishContent.innerHTML = 'üöÄ Open Telegram';
      
    } catch (e) {
      console.error('Link generation failed:', e);
      latestConnectLink = `${TELEGRAM_BOT_URL}?start=${currentQueueKey}`;
      obStatusText.textContent = 'Using fallback link.';
      obFinish.disabled = false;
      obFinishContent.innerHTML = 'üöÄ Open Telegram';
    } finally {
      linkGenerating = false;
    }
  }

  async function openTelegram() {
    if (linkGenerating) return;
    
    obFinish.disabled = true;
    obFinishContent.innerHTML = '<span class="spinner"></span><span>Opening...</span>';
    
    const url = latestConnectLink || `${TELEGRAM_BOT_URL}?start=${currentQueueKey}`;
    
    // Open in NEW tab
    const newTab = window.open(url, '_blank', 'noopener,noreferrer');
    
    if (!newTab) {
      const a = document.createElement('a');
      a.href = url;
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
    
    // Mark token used
    try {
      const token = url.split('start=')[1];
      if (token) {
        await fetch(MARK_TOKEN_USED, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ queueKey: currentQueueKey, token })
        });
      }
    } catch (e) {}
    
    setTimeout(() => {
      obFinish.disabled = false;
      obFinishContent.innerHTML = '‚úÖ Opened!';
      setTimeout(closeModal, 1500);
    }, 500);
  }

  obFinish.onclick = openTelegram;
  connectMainBtn.onclick = openModal;
  connectMiniBtn.onclick = openModal;
  document.getElementById('miniGame').onclick = () => {
  const q = currentQueueKey ? `?queueId=${encodeURIComponent(currentQueueKey)}` : '';
  // use assign so it navigates in the same tab (keeps history)
  window.location.assign(`game.html${q}`);
};


  // UI Updates
  function setTelegramUI(connected) {
    isTelegramConnected = connected;
    
    if (connected) {
      connectionTitle.textContent = '‚úÖ Connected to Telegram';
      connectionSub.textContent = "We'll notify you when it's your turn.";
      connectMainBtn.innerHTML = '‚úÖ';
      connectMainBtn.disabled = true;
      connectMainBtn.classList.add('btn-connected');
      connectMiniBtn.classList.remove('pulse');
      // Hide warning, show success
      stayAlert.style.display = 'none';
      connectedAlert.style.display = 'block';
    } else {
      connectionTitle.textContent = 'Get Telegram notifications';
      connectionSub.textContent = 'Only Telegram can notify you when the app is closed.';
      connectMainBtn.innerHTML = 'Connect';
      connectMainBtn.disabled = false;
      connectMainBtn.classList.remove('btn-connected');
      connectMiniBtn.classList.add('pulse');
      // Show warning, hide success
      stayAlert.style.display = 'block';
      connectedAlert.style.display = 'none';
    }
  }

  function updateProgress(pct, ahead, status) {
    const p = Math.max(4, Math.min(100, Math.round(pct)));
    progressFill.style.width = p + '%';
    progressLabel.textContent = p + '%';
    
    const st = String(status || '').toLowerCase();
    if (st === 'called' || st === 'serving' || st === 'your_turn') {
      progressCaption.textContent = "üéâ It's your turn!";
      progressCaption.style.color = 'var(--success)';
    } else if (ahead === 0) {
      progressCaption.textContent = "üéØ You're next!";
      progressCaption.style.color = 'var(--primary)';
    } else if (ahead === 1) {
      progressCaption.textContent = "1 person ahead";
      progressCaption.style.color = 'var(--primary)';
    } else if (ahead > 1) {
      progressCaption.textContent = `${ahead} people ahead`;
      progressCaption.style.color = '#6b7280';
    } else {
      progressCaption.textContent = 'Loading...';
      progressCaption.style.color = '#6b7280';
    }
  }

  // REDIRECT to your_turn.html
  function redirectToTurn() {
    if (redirecting) return;
    redirecting = true;
    console.log('[STATUS] Redirecting to your_turn.html with queueKey:', currentQueueKey);
    updateProgress(100, 0, 'serving');
    setTimeout(() => {
      window.location.href = `your_turn.html?queueId=${encodeURIComponent(currentQueueKey)}`;
    }, 600);
  }

  // Compute estimates and check if it's user's turn
  async function computeEstimates() {
    if (!currentQueueData || redirecting) return;
    
    // Get user's ticket info
    const myTicket = currentQueueData.queueId || currentQueueData.ticketNumber || currentQueueData.ticket || currentQueueData.number;
    const myNum = extractNumber(myTicket);
    const myStatus = String(currentQueueData.status || '').toLowerCase();
    
    console.log('[STATUS] Computing estimates:', { myTicket, myNum, myStatus, called: currentQueueData.called });
    
    // Check if already called by status
    if (myStatus === 'called' || myStatus === 'serving' || myStatus === 'your_turn') {
      console.log('[STATUS] Status indicates turn, redirecting...');
      redirectToTurn();
      return;
    }
    
    // Check if marked as called
    if (currentQueueData.called === true || currentQueueData.notifiedAt || currentQueueData.calledAt) {
      console.log('[STATUS] Queue marked as called, redirecting...');
      redirectToTurn();
      return;
    }
    
    // Get nowServing from counter
    let servingNum = null;
    let counterData = null;
    
    const counterId = currentQueueData.counterId || currentQueueData.counter || currentQueueData.counterAssigned;
    if (counterId) {
      try {
        const snap = await get(ref(db, `counters/${counterId}`));
        if (snap.exists()) {
          counterData = snap.val();
          servingNum = extractNumber(counterData.nowServing);
          
          console.log('[STATUS] Counter data:', { counterId, nowServing: counterData.nowServing, servingNum, myNum });
          
          // Update nowServing display with proper formatting
          const prefix = counterData.prefix || '';
          if (counterData.nowServing !== undefined && counterData.nowServing !== null) {
            // Match the format of the user's ticket
            const digits = String(myTicket).match(/(\d+)$/);
            const len = digits ? digits[1].length : 3;
            const rawServingNum = extractNumber(counterData.nowServing);
            
            // Check if myTicket has a prefix (like "COFFEE")
            const ticketPrefix = String(myTicket).replace(/\d+$/, '').trim();
            const formattedServing = ticketPrefix 
              ? `${ticketPrefix} ${String(rawServingNum).padStart(len, '0')}`
              : prefix + String(rawServingNum).padStart(len, '0');
            
            nowServingEl.textContent = formattedServing;
          }
        }
      } catch (e) {
        console.error('[STATUS] Error fetching counter:', e);
      }
    }
    
    // *** FIXED LOGIC ***
    // Calculate people ahead CORRECTLY
    // peopleAhead = myNum - servingNum
    // Example: If nowServing = 0 (or "000") and myTicket = 1 (or "001"), there's 1 person ahead (me!)
    // When servingNum === myNum, it's MY turn (0 people ahead)
    
    let peopleAhead = 0;
    
    if (myNum !== null && servingNum !== null) {
      // CORRECT CALCULATION:
      // If nowServing is 0 and I'm 1, then peopleAhead = 1 - 0 = 1 (I'm waiting, not being served yet)
      // If nowServing is 1 and I'm 1, then peopleAhead = 1 - 1 = 0 (It's my turn!)
      // If nowServing is 2 and I'm 1, then I missed my turn (servingNum > myNum)
      
      peopleAhead = myNum - servingNum;
      
      // Ensure non-negative (in case user missed their turn)
      peopleAhead = Math.max(0, peopleAhead);
      
      console.log('[STATUS] People ahead calculation:', { myNum, servingNum, peopleAhead });
      
      // Check if it's EXACTLY my turn (nowServing === myNum)
      if (servingNum === myNum) {
        console.log('[STATUS] nowServing === myNum, it is my turn! Redirecting...');
        redirectToTurn();
        return;
      }
      
      // Check if I missed my turn (nowServing > myNum)
      if (servingNum > myNum) {
        console.log('[STATUS] Missed turn! servingNum > myNum');
        peopleAhead = 0;
        // Optionally show "missed" state here
      }
    } else if (myNum === null) {
      console.log('[STATUS] Could not extract myNum from ticket:', myTicket);
      peopleAhead = 0;
    } else {
      // Fallback: count from queue if we can't get counter data
      console.log('[STATUS] No servingNum, using fallback count');
      try {
        const allSnap = await get(ref(db, 'queue'));
        if (allSnap.exists()) {
          const all = allSnap.val();
          const myTime = currentQueueData.timestamp || 0;
          for (const k in all) {
            const t = all[k];
            if (!t || String(t.status || '').toLowerCase() !== 'waiting') continue;
            if (counterId && String(t.counterId || t.counter || '') !== String(counterId)) continue;
            if (Number(t.timestamp) < Number(myTime)) peopleAhead++;
          }
        }
      } catch (e) {
        console.error('[STATUS] Fallback count error:', e);
      }
    }
    
    // Update UI
    peopleAheadEl.textContent = peopleAhead;
    
    // Estimated wait
    const estMin = peopleAhead * avgServiceTime;
    estimatedWaitEl.textContent = formatMinutes(estMin);
    
    // Progress bar
    // When peopleAhead is high, progress is low. When peopleAhead is 0, progress is 100%
    let progressPct;
    if (peopleAhead <= 0) {
      progressPct = 100;
    } else if (peopleAhead >= MAX_AHEAD) {
      progressPct = 5;
    } else {
      progressPct = Math.round(100 - (peopleAhead / MAX_AHEAD) * 95);
    }
    
    updateProgress(progressPct, peopleAhead, myStatus);
  }

  // Ads
  function showAd(url) {
    if (!url) { adPanel.style.display = 'none'; return; }
    const u = String(url).trim();
    if (!u) { adPanel.style.display = 'none'; return; }
    
    adPanel.style.display = 'block';
    const isVideo = /\.(mp4|webm)(\?|$)/i.test(u);
    
    if (isVideo) {
      adContainer.innerHTML = `<video src="${u}" class="ad-media" autoplay muted loop playsinline></video>`;
    } else {
      adContainer.innerHTML = `<img src="${u}" class="ad-media" alt="Ad" onerror="this.parentElement.parentElement.style.display='none'" />`;
    }
  }

  // Logo
  async function loadLogo() {
    try {
      const snap = await get(ref(db, 'settings/logoUrl'));
      if (snap.exists() && snap.val()) {
        const url = String(snap.val()).trim();
        if (url) {
          logoImg.src = url;
          logoImg.onload = () => {
            logoText.style.display = 'none';
            logoImg.style.display = 'block';
          };
        }
      }
    } catch (e) {}
  }

  // Avg service time from analytics
  async function loadAvgServiceTime() {
    try {
      const snap = await get(ref(db, 'analytics/serviceEvents'));
      if (!snap.exists()) return;
      
      const events = snap.val();
      const times = [];
      
      for (const k in events) {
        const e = events[k];
        if (e.serviceMs && e.serviceMs > 0) {
          const min = e.serviceMs / 60000;
          if (min <= 120) times.push(min);
        }
      }
      
      if (times.length > 0) {
        const sum = times.reduce((a, b) => a + b, 0);
        avgServiceTime = Math.max(1, Math.round(sum / times.length));
      }
    } catch (e) {}
  }

  // Initialize
  document.addEventListener('DOMContentLoaded', async () => {
    const params = new URLSearchParams(window.location.search);
    const queueKey = params.get('queueId') || params.get('queueid') || params.get('qid') || params.get('id');
    
    if (!queueKey) {
      showError('Queue ID missing. Redirecting...');
      setTimeout(() => window.location.href = 'index.html', 1500);
      return;
    }
    
    currentQueueKey = queueKey;
    console.log('[STATUS] Initialized with queueKey:', queueKey);
    
    // Load initial data
    await Promise.all([loadLogo(), loadAvgServiceTime()]);
    
    // Watch queue entry
    qRef = ref(db, `queue/${queueKey}`);
    onValue(qRef, (snap) => {
      if (!snap.exists()) {
        showError('Queue not found. Redirecting...');
        setTimeout(() => window.location.href = 'index.html', 1500);
        return;
      }
      
      currentQueueData = snap.val();
      console.log('[STATUS] Queue data updated:', currentQueueData);
      
      const ticket = currentQueueData.queueId || currentQueueData.ticketNumber || currentQueueData.ticket || currentQueueData.number || '‚Äî';
      yourNumberEl.textContent = ticket;
      
      // Check Telegram connection
      const connected = Boolean(currentQueueData.telegramConnected || currentQueueData.tgConnected || currentQueueData.telegramChatId);
      setTelegramUI(connected);
      
      // Show modal on first visit if not connected
      if (!connected && !obModal.classList.contains('show') && !localStorage.getItem('qj_modal_skipped_' + queueKey)) {
        openModal();
      }
      
      // Watch counter
      const cid = currentQueueData.counterId || currentQueueData.counter || currentQueueData.counterAssigned;
      if (cid && cid !== currentCounterId) {
        if (counterRef) off(counterRef);
        currentCounterId = cid;
        counterRef = ref(db, `counters/${cid}`);
        onValue(counterRef, (cSnap) => {
          console.log('[STATUS] Counter data updated');
          computeEstimates();
        });
      }
      
      computeEstimates();
    });
    
    // Watch ads
// Replace the existing showAd function with this one
async function showAd(raw) {
  // Debug the DB payload so you can inspect what's coming from Firebase.
  console.log('[AD] raw payload from DB:', raw);

  if (!raw) {
    adPanel.style.display = 'none';
    adContainer.innerHTML = '';
    return;
  }

  // Accept either a plain URL string or an object like { url, type, poster }
  let url = null;
  let explicitType = null;
  let poster = null;

  if (typeof raw === 'string') {
    url = raw.trim();
  } else if (typeof raw === 'object' && raw !== null) {
    // Common patterns: { url: '...', type: 'video/mp4' } or { video: '...', image: '...' }
    url = (raw.url || raw.src || raw.video || raw.image || raw.media || '').toString().trim();
    explicitType = raw.type || raw.mime || raw.mediaType || raw.kind || null;
    poster = raw.poster || raw.thumb || raw.thumbnail || null;
  }

  if (!url) {
    adPanel.style.display = 'none';
    adContainer.innerHTML = '';
    return;
  }

  // Normalize
  const u = String(url).trim();

  // Heuristic video detection:
  // 1) explicit type (e.g. "video/mp4")
  // 2) file extension in URL (mp4/webm/mov/m4v/ogg)
  // 3) presence of 'video' keyword in URL (signed storage urls sometimes lack extension)
  const extTest = /\.(mp4|webm|mov|m4v|ogg)(\?.*)?$/i.test(u);
  const typeIsVideo = !!(explicitType && String(explicitType).toLowerCase().startsWith('video'));
  const keywordVideo = /(\bvideo\b)/i.test(u);
  const isVideo = typeIsVideo || extTest || keywordVideo;

  // Show the panel, clear previous content
  adPanel.style.display = 'block';
  adContainer.innerHTML = '';

  if (isVideo) {
    // Create <video> and provide a graceful fallback to an <img>
    const video = document.createElement('video');
    video.className = 'ad-media';
    video.src = u;
    video.autoplay = true;
    video.muted = true;
    video.loop = true;
    video.playsInline = true;
    video.setAttribute('playsinline', '');

    // If there's a poster thumbnail provided in DB, use it
    if (poster) video.poster = poster;

    // Give user a visible control if autoplay is blocked (non-intrusive)
    video.controls = false;

    // Success / error handlers
    video.addEventListener('play', () => console.log('[AD] video started playing'));
    video.addEventListener('error', (ev) => {
      console.warn('[AD] video error, falling back to image:', ev);
      adContainer.innerHTML = `<img src="${u}" class="ad-media" alt="Ad" />`;
      // If that image also fails, hide the panel (image onerror will hide it).
      const img = adContainer.querySelector('img');
      if (img) {
        img.onerror = () => {
          console.warn('[AD] fallback image failed to load, hiding ad panel');
          adPanel.style.display = 'none';
          adContainer.innerHTML = '';
        };
      }
    });

    adContainer.appendChild(video);

    // Try to play - promise may reject on autoplay policy; that's okay
    try {
      const p = video.play();
      if (p && typeof p.then === 'function') {
        p.catch((err) => {
          // Autoplay blocked ‚Äî keep panel visible, show poster (if available) or show controls
          console.log('[AD] autoplay blocked or failed:', err);
          if (poster) {
            // show poster image instead of video autoplay
            adContainer.innerHTML = `<img src="${poster}" class="ad-media" alt="Ad poster" />`;
          } else {
            // show first frame by keeping the <video> element but enable controls so user can tap to start
            video.controls = true;
          }
        });
      }
    } catch (e) {
      console.log('[AD] video.play() threw, ignoring:', e);
    }

  } else {
    // Treat as image/GIF
    const img = document.createElement('img');
    img.src = u;
    img.className = 'ad-media';
    img.alt = 'Ad';
    img.onerror = () => {
      console.warn('[AD] Image failed to load, hiding panel');
      adPanel.style.display = 'none';
      adContainer.innerHTML = '';
    };
    adContainer.appendChild(img);
  }
}

    
    // Watch analytics for service time updates
    analyticsRef = ref(db, 'analytics/serviceEvents');
    onValue(analyticsRef, async () => {
      await loadAvgServiceTime();
      computeEstimates();
    });
    
    // Cleanup
    window.addEventListener('beforeunload', () => {
      if (qRef) off(qRef);
      if (counterRef) off(counterRef);
      if (adRef) off(adRef);
      if (analyticsRef) off(analyticsRef);
    });
  });
</script>

</body>
</html>
