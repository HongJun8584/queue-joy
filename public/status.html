<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>QueueJoy ‚Äî Your Status</title>
  <meta name="description" content="Track your queue position in real-time" />
  <meta name="theme-color" content="#8b5cf6" />

  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet" />

  <style>
    :root {
      --primary: #8b5cf6;
      --primary-dark: #7c3aed;
      --bg-start: #f6f5ff;
      --bg-end: #ede9fe;
      --success: #10b981;
      --warning-bg: #fef3c7;
      --warning-border: #fcd34d;
      --warning-text: #92400e;
      --success-bg: #d1fae5;
      --success-border: #6ee7b7;
      --success-text: #065f46;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      font-family: Inter, system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
      min-height: 100vh;
      min-height: 100dvh;
      color: #1f2937;
      -webkit-font-smoothing: antialiased;
      overflow-x: hidden;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 16px;
      padding-bottom: 160px;
    }
    .page-wrapper {
      width: 100%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      /* start hidden until we have stable data to render */
      visibility: hidden;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 300ms ease, transform 300ms ease, visibility 0s 300ms;
    }
    .page-wrapper.visible {
      visibility: visible;
      opacity: 1;
      transform: translateY(0);
      transition: opacity 300ms ease, transform 300ms ease;
    }

    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(15,23,42,0.12);
      z-index: 1100;
      backdrop-filter: blur(4px);
    }
    .loader {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      background: #fff;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 12px 36px rgba(2,6,23,0.12);
      font-weight: 900;
      color: var(--primary-dark);
      font-size: 18px;
    }

    .alert-banner {
      background: linear-gradient(135deg, var(--warning-bg), #fde68a);
      border: 1px solid var(--warning-border);
      color: var(--warning-text);
      padding: 12px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 700;
      text-align: center;
    }
    .alert-banner.success {
      background: linear-gradient(135deg, var(--success-bg), #a7f3d0);
      border: 1px solid var(--success-border);
      color: var(--success-text);
    }

    .card {
      background: rgba(255, 255, 255, 0.98);
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 18px 40px rgba(139,92,246,0.08);
      position: relative;
    }
    .logo-box {
      width: 64px;
      height: 64px;
      border-radius: 14px;
      background: linear-gradient(135deg,var(--primary),var(--primary-dark));
      display:flex;align-items:center;justify-content:center;color:#fff;font-weight:900;font-size:22px;
      overflow:hidden; flex-shrink:0;
    }
    .logo-box img { width:100%;height:100%;object-fit:cover;display:block; }

    .header { display:flex; gap:12px; align-items:center; margin-bottom:16px; padding-right:70px; }
    .header-text h1 { font-size:20px; font-weight:800; color:#111827; line-height:1.2; }
    .header-text p { color:#6b7280; margin-top:6px; font-size:13px; line-height:1.3; }

    .top-buttons { position:absolute; right:12px; top:12px; display:flex; gap:8px; z-index:10;}
    .circle-btn { width:40px;height:40px;border-radius:50%;background:#fff;border:none;display:flex;align-items:center;justify-content:center; font-size:18px; box-shadow:0 6px 14px rgba(2,6,23,0.06); cursor:pointer; }

    .progress-section { margin-bottom:12px; }
    .progress-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    .progress-label { font-size:13px; font-weight:700; color:#374151; }
    .progress-status { font-size:13px; font-weight:800; color:var(--primary); display:flex; align-items:center; gap:6px; }

    .progress-track { height:26px; border-radius:999px; background:#f3f4f6; overflow:hidden; position:relative; }
    .progress-fill { height:100%; background:linear-gradient(90deg,var(--primary-dark),var(--primary)); display:flex; align-items:center; justify-content:flex-end; padding-right:10px; color:#fff; font-weight:800; font-size:12px; transition:width 0.45s ease; min-width:44px; }

    .stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:10px; }
    .glass-card { background:linear-gradient(135deg, rgba(255,255,255,0.98), rgba(250,248,255,0.96)); border-radius:12px; padding:14px; border:1px solid rgba(139,92,246,0.06); box-shadow:0 6px 18px rgba(2,6,23,0.04);}
    .stat-label { font-size:11px; text-transform:uppercase; color:#6b7280; font-weight:700; letter-spacing:0.06em; }
    .stat-value { font-weight:900; font-size:28px; margin-top:8px; color:var(--primary); word-break:break-word;}
    .stat-value.dark { color:#111827; }
    .stat-value-sm { font-weight:800; font-size:20px; margin-top:6px; color:#374151; }
    .stat-value-sm.highlight { color:var(--primary); }

    .connection-banner { display:flex; gap:12px; align-items:center; padding:12px; border-radius:12px; border:1px solid rgba(139,92,246,0.06); background:linear-gradient(135deg, rgba(255,255,255,0.98), rgba(250,248,255,0.96)); margin-bottom:8px; }
    .connection-icon { width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--primary-dark),var(--primary));display:flex;align-items:center;justify-content:center;color:#fff;font-size:20px; }
    .connection-title { font-weight:800; font-size:13px; color:#111827; }
    .connection-sub { color:#6b7280; font-size:12px; margin-top:4px; }

    .btn-primary { background:linear-gradient(135deg,var(--primary-dark),var(--primary)); color:#fff;padding:12px 16px;border-radius:10px;border:none;font-weight:800; cursor:pointer; min-height:44px; display:inline-flex; align-items:center; gap:8px; }
    .btn-outline { border:1px solid rgba(139,92,246,0.08); padding:10px; border-radius:10px; background:#fff; font-weight:700; cursor:pointer; width:100%; }

    .error-banner { padding:12px; border-radius:10px; background:#fff5f5; border:1px solid #fecaca; color:#991b1b; font-weight:700; font-size:13px; text-align:center; display:none; margin-top:8px; }

    .ad-panel { position:fixed; left:50%; transform:translateX(-50%); bottom:12px; width:calc(100% - 32px); max-width:400px; background:#fff; border-radius:12px; box-shadow:0 14px 36px rgba(2,6,23,0.12); padding:10px; z-index:100; display:none; }
    .ad-media { width:100%; height:100px; object-fit:cover; border-radius:8px; }
  </style>
</head>
<body>

<!-- Loading overlay while we fetch tenant + queue + counters -->
<div id="loading" class="loading-overlay" aria-hidden="false">
  <div class="loader">QJ</div>
</div>

<div class="page-wrapper" id="pageWrapper">
  <!-- Top alert -->
  <div id="stayAlert" class="alert-banner" style="display:none">‚ö†Ô∏è <strong>Stay on this page</strong> ‚Äî Only Telegram can notify you when the app is closed.</div>
  <div id="connectedAlert" class="alert-banner success" style="display:none">‚úÖ <strong>You're all set!</strong> We'll notify you on Telegram.</div>

  <!-- Main Card -->
  <main class="card" id="mainCard">
    <div class="top-buttons">
      <button id="miniGame" class="circle-btn" title="Play">üéÆ</button>
      <button id="miniConnect" class="circle-btn" title="Connect Telegram">‚úâÔ∏è</button>
    </div>

    <div class="header">
      <div class="logo-box" id="logoBox">
        <span id="logoText">QJ</span>
        <img id="logoImg" style="display:none" alt="Logo" />
      </div>
      <div class="header-text">
        <h1 id="mainTitle">You're in the queue</h1>
        <p id="subTitle">We're tracking your spot in real-time.</p>
      </div>
    </div>

    <section class="progress-section">
      <div class="progress-header">
        <span class="progress-label">Queue Progress</span>
        <span id="progressCaption" class="progress-status">Loading...</span>
      </div>
      <div class="progress-track">
        <div id="progressFill" class="progress-fill" style="width:6%"><span id="progressLabel">6%</span></div>
      </div>
    </section>

    <section class="stats-grid">
      <div class="glass-card">
        <div class="stat-label">Your Ticket</div>
        <div id="yourNumber" class="stat-value">‚Äî</div>
      </div>
      <div class="glass-card">
        <div class="stat-label">Now Serving</div>
        <div id="nowServing" class="stat-value dark">‚Äî</div>
      </div>
    </section>

    <section class="stats-grid">
      <div class="glass-card">
        <div class="stat-label">People Ahead</div>
        <div id="peopleAhead" class="stat-value-sm">‚Äî</div>
      </div>
      <div class="glass-card">
        <div class="stat-label">Estimated Wait</div>
        <div id="estimatedWait" class="stat-value-sm highlight">‚Äî</div>
      </div>
    </section>

    <section id="connectionBanner" class="connection-banner">
      <div class="connection-icon">üîî</div>
      <div class="connection-text">
        <div id="connectionTitle" class="connection-title">Get Telegram notifications</div>
        <div id="connectionSub" class="connection-sub">Only Telegram can notify you when the app is closed.</div>
      </div>
      <button id="connectMain" class="btn-primary" style="padding:10px 12px;font-size:13px">Connect</button>
    </section>

    <div id="error" class="error-banner"></div>
  </main>
</div>

<div id="adPanel" class="ad-panel"><div id="adContainer"></div></div>

<script type="module">
/* ===== BOOT GUARD ===== */
if (window.__QJ_BOOTED__) {
  console.warn('QJ already booted');
  throw new Error('QJ double boot prevented');
}
window.__QJ_BOOTED__ = true;

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
import { getDatabase, ref, onValue, off, get } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

/* ---------- CONFIG ---------- */
const CREATE_LINK_ENDPOINT = '/.netlify/functions/createTelegramLink';
const MARK_TOKEN_USED = '/.netlify/functions/markTokenUsed';
const TELEGRAM_BOT_URL = 'https://t.me/QueueJoyBot';
const MAX_AHEAD = 20;

/* Firebase client config (same as your original) */
const firebaseConfig = {
  apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
  authDomain: "queue-joy-aa21b.firebaseapp.com",
  databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "queue-joy-aa21b",
  storageBucket: "queue-joy-aa21b.firebasestorage.app",
  messagingSenderId: "950240394209",
  appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/* ---------- TENANT RESOLUTION (path first, query fallback) ---------- */
function getTenantSlug() {
  const parts = window.location.pathname.split('/').filter(Boolean);
  if (parts.length > 0) {
    const p0 = parts[0];
    if (/^[a-z0-9\-]+$/.test(p0)) return p0;
  }
  try {
    const qp = new URLSearchParams(window.location.search);
    if (qp.has('slug')) return qp.get('slug');
  } catch (e) {}
  return null;
}
const TENANT_SLUG = getTenantSlug();
function tenantRef(dbInstance, relPath='') {
  relPath = String(relPath || '').replace(/^\/+/, '');
  if (!TENANT_SLUG) return ref(dbInstance, relPath || '/');
  if (!relPath) return ref(dbInstance, `tenants/${TENANT_SLUG}`);
  return ref(dbInstance, `tenants/${TENANT_SLUG}/${relPath}`);
}

/* ---------- DOM ---------- */
const loadingEl = document.getElementById('loading');
const pageWrapper = document.getElementById('pageWrapper');
const errorBox = document.getElementById('error');
const adPanel = document.getElementById('adPanel');
const adContainer = document.getElementById('adContainer');

const logoImg = document.getElementById('logoImg');
const logoText = document.getElementById('logoText');
const mainTitleEl = document.getElementById('mainTitle');
const subTitleEl = document.getElementById('subTitle');
const yourNumberEl = document.getElementById('yourNumber');
const nowServingEl = document.getElementById('nowServing');
const peopleAheadEl = document.getElementById('peopleAhead');
const estimatedWaitEl = document.getElementById('estimatedWait');
const progressFill = document.getElementById('progressFill');
const progressLabel = document.getElementById('progressLabel');
const progressCaption = document.getElementById('progressCaption');
const connectMainBtn = document.getElementById('connectMain');
const connectMiniBtn = document.getElementById('miniConnect');
const stayAlert = document.getElementById('stayAlert');
const connectedAlert = document.getElementById('connectedAlert');

let qRef = null, counterRef = null, adRef = null, analyticsRef = null;

/* ---------- STATE ---------- */
let currentQueueKey = null;
let currentQueueData = null;
let currentCounterId = null;
let avgServiceTime = 3;
let isTelegramConnected = false;
let redirecting = false;
let initialLoadComplete = { tenant: false, queue: false, counter: false };

/* ---------- UTILS ---------- */
function showError(msg, persistent = false) {
  console.warn('STATUS ERROR:', msg);
  errorBox.style.display = 'block';
  errorBox.textContent = msg;
  if (!persistent) setTimeout(() => { errorBox.style.display = 'none'; }, 6000);
}

function extractNumber(str) {
  if (str === null || str === undefined) return null;
  const s = String(str).trim();
  const m = s.match(/(\d+)$/);
  if (m) return parseInt(m[1], 10);
  if (/^\d+$/.test(s)) return parseInt(s, 10);
  return null;
}
function formatMinutes(m) {
  const mm = Math.max(0, Math.round(m));
  if (mm === 0) return 'Now';
  if (mm < 60) return `${mm} min`;
  const h = Math.floor(mm/60), r = mm%60;
  return r === 0 ? `${h}h` : `${h}h ${r}m`;
}

/* ---------- AD LOADER (robust) ---------- */
function showAd(url) {
  adContainer.innerHTML = '';
  if (!url) { adPanel.style.display = 'none'; return; }
  const u = String(url).trim();
  if (!u) { adPanel.style.display = 'none'; return; }

  // video detection
  const isVideo = /\.(mp4|webm|ogg|mov)(?:[?#].*)?$/i.test(u) || /^data:video\//i.test(u) || /^blob:/i.test(u);
  const isYouTubeOrVimeo = /youtube\.com|youtu\.be|vimeo\.com/i.test(u);

  if (isYouTubeOrVimeo) {
    let embed = u;
    try {
      if (/youtube\.com\/watch\?v=/.test(u) || /youtu\.be\//.test(u)) {
        const urlObj = new URL(u);
        const vid = urlObj.searchParams.get('v') || (u.match(/\/([^/?#]+)(?:[?#]|$)/) || [])[1];
        if (vid) embed = `https://www.youtube.com/embed/${vid}?rel=0&autoplay=1&mute=1&playsinline=1`;
      }
    } catch(e) { embed = u; }
    adContainer.innerHTML = `<div style="position:relative;padding-top:56.25%"><iframe src="${embed}" frameborder="0" allow="autoplay; encrypted-media; picture-in-picture" allowfullscreen style="position:absolute;inset:0;width:100%;height:100%;border:0;border-radius:8px"></iframe></div>`;
    adPanel.style.display = 'block';
    return;
  }

  if (isVideo) {
    const video = document.createElement('video');
    video.src = u;
    video.className = 'ad-media';
    video.autoplay = true; video.muted = true; video.loop = true; video.playsInline = true; video.controls = false;
    video.style.borderRadius = '8px';
    video.onloadedmetadata = () => adPanel.style.display = 'block';
    video.onerror = () => { console.warn('ad video load fail', u); adPanel.style.display = 'none'; };
    adContainer.appendChild(video);
    video.play().catch(()=>{});
    return;
  }

  const img = document.createElement('img');
  img.src = u; img.className = 'ad-media'; img.alt = 'Ad';
  img.onload = () => { adPanel.style.display = 'block'; };
  img.onerror = (e) => { console.warn('ad image load fail', e); adPanel.style.display = 'none'; };
  adContainer.appendChild(img);
}

/* ---------- LOGO LOADER ---------- */
async function loadLogoFromSettings() {
  try {
    const snap = await get(tenantRef(db, 'settings'));
    if (!snap.exists()) return;
    const s = snap.val() || {};
    const logoUrl = (s.logoUrl || s.logo || '').toString().trim();
    const mt = s.mainTitle || s.name || '';
    const st = s.smallTextOnTop || s.introText || '';
    // update UI labels if present
    if (mt) mainTitleEl.textContent = mt;
    if (st) subTitleEl.textContent = st;
    if (logoUrl) {
      logoImg.src = logoUrl;
      logoImg.onload = () => {
        logoImg.style.display = 'block';
        logoText.style.display = 'none';
        document.getElementById('logoBox').style.background = 'transparent';
      };
      logoImg.onerror = () => { logoImg.style.display = 'none'; logoText.style.display = 'block'; };
    }
  } catch (e) { console.warn('logo load failed', e); }
}

/* ---------- AVERAGE SERVICE TIME ---------- */
async function loadAvgServiceTime() {
  try {
    const snap = await get(tenantRef(db, 'analytics/serviceEvents'));
    if (!snap.exists()) return;
    const events = snap.val() || {};
    const times = [];
    for (const k in events) {
      const e = events[k];
      if (e && e.serviceMs && e.serviceMs > 0) {
        const min = e.serviceMs / 60000;
        if (min <= 120) times.push(min);
      }
    }
    if (times.length) {
      const sum = times.reduce((a,b)=>a+b,0);
      avgServiceTime = Math.max(1, Math.round(sum / times.length));
    }
  } catch(e){ console.warn('avg service failed', e); }
}

/* ---------- UI READY HANDLER (prevents flashing) ---------- */
function setReadyToShow() {
  // only show UI after tenant + queue data loaded (counter optional)
  if (!initialLoadComplete.tenant || !initialLoadComplete.queue) return;
  // hide loader
  loadingEl.style.display = 'none';
  pageWrapper.classList.add('visible');
}

/* ---------- REDIRECT TO YOUR_TURN.HTML (safety checks) ---------- */
function redirectToTurn() {
  if (redirecting) return;
  // small safety delay to avoid immediate flapping for transient updates
  redirecting = true;
  updateProgress(100, 0, 'serving');
  setTimeout(() => {
    // set session markers (help index to avoid re-evaluating)
    try {
      sessionStorage.setItem('lastQueueId_root', currentQueueKey);
      if (TENANT_SLUG) sessionStorage.setItem('qj_active_slug', TENANT_SLUG);
    } catch(e){}
    window.location.href = `your_turn.html?queueId=${encodeURIComponent(currentQueueKey)}&slug=${encodeURIComponent(TENANT_SLUG || '')}`;
  }, 520);
}

/* ---------- PROGRESS UI ---------- */
function updateProgress(pct, ahead, status) {
  const p = Math.max(4, Math.min(100, Math.round(pct)));
  progressFill.style.width = `${p}%`;
  progressLabel.textContent = `${p}%`;
  const st = String(status || '').toLowerCase();
  if (st === 'called' || st === 'serving' || st === 'your_turn') {
    progressCaption.textContent = "üéâ It's your turn!";
    progressCaption.style.color = 'var(--success)';
  } else if (ahead === 0) {
    progressCaption.textContent = "üéØ You're next!";
    progressCaption.style.color = 'var(--primary)';
  } else if (ahead === 1) {
    progressCaption.textContent = "1 person ahead";
    progressCaption.style.color = 'var(--primary)';
  } else if (ahead > 1) {
    progressCaption.textContent = `${ahead} people ahead`;
    progressCaption.style.color = '#6b7280';
  } else {
    progressCaption.textContent = 'Loading...';
    progressCaption.style.color = '#6b7280';
  }
}

/* ---------- COMPUTE ESTIMATES (called when queue or counter updates) ---------- */
let computeLock = false;
async function computeEstimates() {
  if (computeLock || !currentQueueData || redirecting) return;
  computeLock = true;
  try {
    const ticket = currentQueueData.queueId || currentQueueData.ticketNumber || currentQueueData.ticket || currentQueueData.number || '‚Äî';
    yourNumberEl.textContent = ticket;
    const myNum = extractNumber(ticket);
    const myStatus = String(currentQueueData.status || '').toLowerCase();

    // If status explicitly marks called/serving, redirect
    if (myStatus === 'called' || myStatus === 'serving' || myStatus === 'your_turn') { redirectToTurn(); return; }
    if (currentQueueData.called === true || currentQueueData.notifiedAt || currentQueueData.calledAt) { redirectToTurn(); return; }

    // Determine counter & serving number
    let servingNum = null;
    let counterData = null;
    const counterId = currentQueueData.counterId || currentQueueData.counter || currentQueueData.counterAssigned;
    if (counterId) {
      try {
        const snap = await get(tenantRef(db, `counters/${counterId}`));
        if (snap.exists()) {
          counterData = snap.val();
          servingNum = extractNumber(counterData.nowServing);
          // Update now serving label with prefix and padding similar to ticket
          const digits = String(ticket).match(/(\d+)$/);
          const len = digits ? digits[1].length : 3;
          const rawServingNum = extractNumber(counterData.nowServing);
          const ticketPrefix = String(ticket).replace(/\d+$/, '').trim();
          const prefix = (counterData.prefix || '').toString();
          const formattedServing = ticketPrefix ? `${ticketPrefix} ${String(rawServingNum).padStart(len,'0')}` : prefix + String(rawServingNum || 0).padStart(len,'0');
          nowServingEl.textContent = formattedServing;
        }
      } catch(e){ console.warn('fetch counter error', e); }
    }

    // Calculate people ahead
    let peopleAhead = 0;
    if (myNum !== null && servingNum !== null) {
      peopleAhead = myNum - servingNum;
      peopleAhead = Math.max(0, peopleAhead);
      if (servingNum === myNum) { redirectToTurn(); return; }
      if (servingNum > myNum) { peopleAhead = 0; }
    } else if (myNum === null) {
      peopleAhead = 0;
    } else {
      // fallback: count waiting items in queue with earlier timestamp
      try {
        const allSnap = await get(tenantRef(db, 'queue'));
        if (allSnap.exists()) {
          const all = allSnap.val() || {};
          const myTime = currentQueueData.timestamp || 0;
          for (const k in all) {
            const t = all[k];
            if (!t || String(t.status || '').toLowerCase() !== 'waiting') continue;
            if (counterId && String(t.counterId || t.counter || '') !== String(counterId)) continue;
            if (Number(t.timestamp) < Number(myTime)) peopleAhead++;
          }
        }
      } catch(e){ console.warn('fallback count failed', e); }
    }

    peopleAheadEl.textContent = String(peopleAhead);
    const estMin = peopleAhead * avgServiceTime;
    estimatedWaitEl.textContent = formatMinutes(estMin);

    // progress percent mapping
    let progressPct;
    if (peopleAhead <= 0) progressPct = 100;
    else if (peopleAhead >= MAX_AHEAD) progressPct = 5;
    else progressPct = Math.round(100 - (peopleAhead / MAX_AHEAD) * 95);
    updateProgress(progressPct, peopleAhead, myStatus);

    // Telegram UI
    const connected = Boolean(currentQueueData.telegramConnected || currentQueueData.tgConnected || currentQueueData.telegramChatId);
    setTelegramUI(connected);

  } finally {
    // small debounce window (allow frequent updates but prevent reentrancy)
    setTimeout(() => computeLock = false, 220);
  }
}

/* ---------- TELEGRAM UI ---------- */
function setTelegramUI(connected) {
  isTelegramConnected = connected;
  if (connected) {
    connectionTitle.textContent = '‚úÖ Connected to Telegram';
    connectionSub.textContent = "We'll notify you when it's your turn.";
    connectMainBtn.textContent = '‚úÖ';
    connectMainBtn.disabled = true;
    connectMainBtn.classList.add('btn-connected');
    connectedAlert.style.display = 'block';
    stayAlert.style.display = 'none';
  } else {
    connectionTitle.textContent = 'Get Telegram notifications';
    connectionSub.textContent = 'Only Telegram can notify you when the app is closed.';
    connectMainBtn.textContent = 'Connect';
    connectMainBtn.disabled = false;
    connectMainBtn.classList.remove('btn-connected');
    connectedAlert.style.display = 'none';
    stayAlert.style.display = 'block';
  }
}

/* ---------- LOAD + WATCH FLOW ---------- */
document.addEventListener('DOMContentLoaded', async () => {
  const params = new URLSearchParams(window.location.search);
  const queueKey = params.get('queueId') || params.get('queueid') || params.get('qid') || params.get('id');
  if (!queueKey) {
    showError('Queue ID missing. Redirecting...', true);
    setTimeout(()=> window.location.href = 'index.html', 1200);
    return;
  }
  currentQueueKey = queueKey;
  console.log('[STATUS] init', { queueKey: currentQueueKey, slug: TENANT_SLUG });

  // populate sessionStorage markers to help index avoid re-evaluating and causing flashes
  try {
    sessionStorage.setItem('lastQueueId_root', currentQueueKey);
    if (TENANT_SLUG) sessionStorage.setItem('qj_active_slug', TENANT_SLUG);
  } catch(e){}

  // Prefetch some tenant settings & counters
  try {
    const sSnap = await get(tenantRef(db, 'settings'));
    if (sSnap.exists()) {
      const s = sSnap.val() || {};
      // Apply main title / subtitle right away for correct header
      if (s.mainTitle) mainTitleEl.textContent = s.mainTitle;
      else if (s.name) mainTitleEl.textContent = s.name;
      if (s.smallTextOnTop) subTitleEl.textContent = s.smallTextOnTop;
      else if (s.introText) subTitleEl.textContent = s.introText;
      // ad and logo load
      const logoUrl = (s.logoUrl || s.logo || '').toString().trim();
      if (logoUrl) {
        logoImg.src = logoUrl; logoImg.onload = () => { logoImg.style.display='block'; logoText.style.display='none'; };
      }
      // show ads if present
      if (s.adImage) showAd(s.adImage);
    } else {
      // If no settings found ‚Äî warn but continue; createBusiness issue often caused missing keys
      console.warn('[STATUS] tenant settings missing or incomplete');
    }
    initialLoadComplete.tenant = true;
  } catch(e) {
    console.warn('tenant settings prefetch failed', e);
    initialLoadComplete.tenant = true; // continue but show UI so user can see meaningful error if queue missing
  }

  // load avg service time asynchronously
  loadAvgServiceTime().catch(()=>{});

  // watch the queue entry (primary data source)
  try {
    qRef = tenantRef(db, `queue/${currentQueueKey}`);
    onValue(qRef, (snap) => {
      if (!snap.exists()) {
        showError('Queue not found. Redirecting...', true);
        setTimeout(()=> window.location.href='index.html', 1200);
        return;
      }
      currentQueueData = snap.val();
      initialLoadComplete.queue = true;

      // ensure session markers are set (helps index remain stable if user clicks back)
      try {
        sessionStorage.setItem('lastQueueId_root', currentQueueKey);
        if (TENANT_SLUG) sessionStorage.setItem('qj_active_slug', TENANT_SLUG);
      } catch(e){}

      // display ticket
      const ticket = currentQueueData.queueId || currentQueueData.ticketNumber || currentQueueData.ticket || currentQueueData.number || '‚Äî';
      yourNumberEl.textContent = ticket;

      // determine counter id and attach watcher
      const cid = currentQueueData.counterId || currentQueueData.counter || currentQueueData.counterAssigned;
      if (cid && cid !== currentCounterId) {
        if (counterRef) off(counterRef);
        currentCounterId = cid;
        counterRef = tenantRef(db, `counters/${cid}`);
        onValue(counterRef, (cSnap) => {
          if (cSnap.exists()) {
            initialLoadComplete.counter = true;
          }
          computeEstimates();
        });
      }

      // final UI show trigger (after queue fetched)
      setReadyToShow();
      // compute estimates immediately
      computeEstimates();
    });
  } catch(e) {
    console.error('queue watch failed', e);
    showError('Realtime queue watch failed', true);
    initialLoadComplete.queue = true;
    setReadyToShow();
  }

  // watch ad changes
  try {
    adRef = tenantRef(db, 'settings/adImage');
    onValue(adRef, (snap) => {
      showAd(snap.exists() ? snap.val() : null);
    });
  } catch(e){ console.warn('ad watch failed', e); }

  // watch analytics updates for recalculation
  try {
    analyticsRef = tenantRef(db, 'analytics/serviceEvents');
    onValue(analyticsRef, async () => {
      await loadAvgServiceTime();
      computeEstimates();
    });
  } catch(e){ console.warn('analytics watch failed', e); }

  // hide loader once tenant + queue resolved
  setTimeout(()=>{ setReadyToShow(); }, 1200); // fallback show after short timeout
});

/* ---------- UI buttons (telegram modal handled elsewhere) ---------- */
connectMainBtn.onclick = () => {
  // open telegram bot in new tab with queue token if present
  const token = currentQueueKey;
  const url = `${TELEGRAM_BOT_URL}?start=${encodeURIComponent(token)}`;
  window.open(url, '_blank', 'noopener,noreferrer');
};

document.getElementById('miniGame').onclick = () => {
  const q = currentQueueKey ? `?queueId=${encodeURIComponent(currentQueueKey)}` : '';
  window.location.assign(`game.html${q}`);
};

/* ---------- Cleanup on unload ---------- */
window.addEventListener('beforeunload', () => {
  try {
    if (qRef) off(qRef);
    if (counterRef) off(counterRef);
    if (adRef) off(adRef);
    if (analyticsRef) off(analyticsRef);
  } catch(e){}
});
</script>

</body>
</html>
