<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>QueueJoy ‚Äî Your Status</title>
  <meta name="description" content="Track your queue position in real-time" />
  <meta name="theme-color" content="#8b5cf6" />

  <!-- Tailwind CDN (development). Replace with production build in prod environments. -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet" />

  <style>
    :root {
      --primary: #8b5cf6;
      --primary-dark: #7c3aed;
      --primary-light: #a78bfa;
      --bg-start: #f6f5ff;
      --bg-end: #ede9fe;
      --success: #10b981;
      --warning-bg: #fef3c7;
      --warning-border: #fcd34d;
      --warning-text: #92400e;
      --success-bg: #d1fae5;
      --success-border: #6ee7b7;
      --success-text: #065f46;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      font-family: Inter, system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
      min-height: 100vh;
      color: #1f2937;
      -webkit-font-smoothing: antialiased;
      overflow-x: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 16px;
      padding-bottom: 160px;
    }

    .page-wrapper {
      width: 100%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    /* Visual components (kept and slightly refined from your original) */
    .card {
      background: rgba(255, 255, 255, 0.97);
      border-radius: 24px;
      padding: 24px 20px;
      box-shadow: 0 20px 60px rgba(139, 92, 246, 0.15);
      position: relative;
    }

    .logo-box {
      width: 80px;
      height: 80px;
      border-radius: 20px;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 900;
      font-size: 28px;
      box-shadow: 0 12px 30px rgba(139, 92, 246, 0.3);
      overflow: hidden;
      flex-shrink: 0;
    }

    .header {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-bottom: 24px;
      padding-right: 80px;
    }

    .top-buttons {
      position: absolute;
      right: 16px;
      top: 20px;
      display: flex;
      gap: 10px;
      z-index: 10;
    }

    .circle-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: #fff;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
    }

    .circle-btn:active { transform: scale(0.95); }

    .progress-track {
      height: 28px;
      border-radius: 999px;
      background: #f3f4f6;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-dark), var(--primary));
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 12px;
      color: #fff;
      font-weight: 800;
      font-size: 13px;
      transition: width 0.6s cubic-bezier(0.22, 0.9, 0.22, 1);
      box-shadow: 0 4px 16px rgba(139, 92, 246, 0.4);
      min-width: 50px;
    }

    .glass-card {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(250, 248, 255, 0.9));
      border-radius: 16px;
      padding: 18px 16px;
      border: 1px solid rgba(139, 92, 246, 0.08);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.03);
    }

    .stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
      font-weight: 600;
    }

    .stat-value {
      font-weight: 900;
      font-size: 32px;
      margin-top: 8px;
      line-height: 1;
      word-break: break-word;
      color: var(--primary);
    }

    .stat-value.dark {
      color: #111827;
    }

    .connection-banner {
      display: flex;
      align-items: center;
      gap: 14px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(250, 248, 255, 0.9));
      border-radius: 16px;
      padding: 16px;
      border: 1px solid rgba(139, 92, 246, 0.08);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary-dark), var(--primary));
      color: #fff;
      padding: 14px 20px;
      border-radius: 12px;
      font-weight: 700;
      border: none;
      box-shadow: 0 8px 20px rgba(139, 92, 246, 0.3);
      cursor: pointer;
    }

    .btn-connected {
      background: linear-gradient(135deg, #059669, var(--success));
    }

    .error-banner {
      padding: 14px;
      border-radius: 12px;
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #b91c1c;
      font-weight: 600;
      font-size: 13px;
      text-align: center;
      display: none;
    }

    /* modal simplified styles kept */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
      padding: 20px;
      backdrop-filter: blur(8px);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.25s, visibility 0.25s;
    }

    .modal-overlay.show { opacity: 1; visibility: visible; }

    .modal-card {
      width: 100%;
      max-width: 380px;
      background: #fff;
      border-radius: 24px;
      padding: 28px 24px;
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.4);
      transform: translateY(20px) scale(0.96);
      transition: transform 0.3s cubic-bezier(0.22, 0.9, 0.22, 1);
    }

    .modal-icon { width: 100px; height: 100px; margin: 0 auto; border-radius: 24px; background: linear-gradient(135deg, var(--primary), var(--primary-dark)); display:flex; align-items:center; justify-content:center; font-size:44px; color:#fff; box-shadow: 0 16px 40px rgba(139, 92, 246, 0.3); }

    .slide { display: none; } .slide.active { display: block; }

    /* Ad panel */
    .ad-panel {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 12px;
      width: calc(100% - 32px);
      max-width: 400px;
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.2);
      padding: 12px;
      z-index: 100;
      display: none;
    }

    .ad-label {
      font-size: 9px;
      color: #9ca3af;
      text-align: center;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .ad-media {
      width: 100%;
      height: 100px;
      object-fit: cover;
      border-radius: 12px;
    }

    @media (max-width: 420px) {
      .ad-media { height: 86px; }
      .header { padding-right: 60px; }
    }
  </style>
</head>
<body>

<div class="page-wrapper">

  <!-- Alert Banner -->
  <div id="stayAlert" class="alert-banner" style="display: none">
    <strong>Stay on this page</strong> ‚Äî Only Telegram can notify you when the app is closed.
  </div>

  <!-- Connected Banner -->
  <div id="connectedAlert" class="alert-banner success" style="display: none">
    <strong>You're all set!</strong> You can close this browser now ‚Äî we will notify you on Telegram when it's your turn.
  </div>

  <!-- Onboarding Modal -->
  <div id="onboardingModal" class="modal-overlay" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true">
      <!-- Slides preserved -->
      <div class="slide active" data-slide="0">
        <div class="modal-icon">‚úâÔ∏è</div>
        <h3 style="text-align:center;margin-top:12px;font-size:18px;font-weight:800">Get Telegram Notifications</h3>
        <p style="color:#6b7280;margin-top:8px;text-align:center">Only Telegram can notify you when the app is closed. Receive instant alerts on your phone when it's your turn.</p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:16px">
          <button id="obNext" class="btn-primary" style="min-width:120px">Continue ‚Üí</button>
          <button id="obSkip" class="btn-primary" style="background:#fff;border:1px solid rgba(139,92,246,0.12);color:#374151">Skip</button>
        </div>
      </div>

      <div class="slide" data-slide="1">
        <div class="modal-icon">‚ñ∂Ô∏è</div>
        <h3 style="text-align:center;margin-top:12px;font-size:18px;font-weight:800">Tap "Start" in Telegram</h3>
        <p style="color:#6b7280;margin-top:8px;text-align:center">We'll open our bot. Tap <strong>Start</strong> to activate notifications.</p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:16px">
          <button id="obNext2" class="btn-primary" style="min-width:120px">Next ‚Üí</button>
          <button id="obBack1" class="btn-primary" style="background:#fff;border:1px solid rgba(139,92,246,0.12);color:#374151">‚Üê Back</button>
        </div>
      </div>

      <div class="slide" data-slide="2">
        <div class="modal-icon">‚úÖ</div>
        <h3 style="text-align:center;margin-top:12px;font-size:18px;font-weight:800">Ready to Connect</h3>
        <p id="obStatusText" style="color:#6b7280;margin-top:8px;text-align:center">Generating your secure link...</p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:16px">
          <button id="obFinish" class="btn-primary" disabled style="min-width:160px">
            <span id="obFinishContent"><span style="display:inline-block;width:18px;height:18px;border:3px solid rgba(255,255,255,0.25);border-top-color:#fff;border-radius:50%;animation:spin .7s linear infinite;margin-right:8px"></span>Generating...</span>
          </button>
          <button id="obBack2" class="btn-primary" style="background:#fff;border:1px solid rgba(139,92,246,0.12);color:#374151">‚Üê Back</button>
        </div>
      </div>

      <div class="slide" data-slide="connected">
        <div class="modal-icon" style="background:linear-gradient(135deg,var(--success),#059669)">‚úÖ</div>
        <h3 style="text-align:center;margin-top:12px;font-size:18px;font-weight:800">You're Connected!</h3>
        <p style="color:#6b7280;margin-top:8px;text-align:center">You'll get a Telegram notification when it's your turn.</p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:16px">
          <button id="obDone" class="btn-primary">Got it</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Main Card -->
  <main class="card">
    <!-- Top buttons -->
    <div class="top-buttons">
      <button id="miniGame" class="circle-btn" title="Play game">üéÆ</button>
      <button id="miniConnect" class="circle-btn pulse" title="Connect Telegram">‚úâÔ∏è</button>
    </div>

    <!-- Header -->
    <div class="header">
      <div class="logo-box" id="logoBox">
        <span id="logoText">QJ</span>
        <img id="logoImg" style="display:none" alt="Logo" />
      </div>
      <div class="header-text">
        <h1 style="font-size:22px;font-weight:800">You're in the queue</h1>
        <p style="color:#6b7280;margin-top:6px;font-size:14px">We're tracking your spot in real-time.</p>
      </div>
    </div>

    <!-- Progress -->
    <section class="progress-section">
      <div class="progress-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
        <span class="progress-label">Queue Progress</span>
        <span id="progressCaption" class="progress-status">Loading...</span>
      </div>
      <div class="progress-track">
        <div id="progressFill" class="progress-fill" style="width:8%">
          <span id="progressLabel">8%</span>
        </div>
      </div>
    </section>

    <!-- Stats Grid -->
    <section class="stats-grid" style="margin-top:14px">
      <div class="glass-card">
        <div class="stat-label">Your Ticket</div>
        <div id="yourNumber" class="stat-value">‚Äî</div>
      </div>
      <div class="glass-card">
        <div class="stat-label">Now Serving</div>
        <div id="nowServing" class="stat-value dark">‚Äî</div>
      </div>
    </section>

    <section class="stats-grid">
      <div class="glass-card">
        <div class="stat-label">People Ahead</div>
        <div id="peopleAhead" class="stat-value-sm" style="font-size:26px;color:#374151">‚Äî</div>
      </div>
      <div class="glass-card">
        <div class="stat-label">Estimated Wait</div>
        <div id="estimatedWait" class="stat-value-sm highlight" style="font-size:26px;color:var(--primary)">‚Äî</div>
      </div>
    </section>

    <!-- Connection Banner -->
    <section id="connectionBanner" class="connection-banner" style="margin-top:14px">
      <div class="connection-icon">üîî</div>
      <div class="connection-text">
        <div id="connectionTitle" class="connection-title">Get Telegram notifications</div>
        <div id="connectionSub" class="connection-sub">Only Telegram can notify you when the app is closed.</div>
      </div>
      <button id="connectMain" class="btn-primary" style="padding:12px 16px;font-size:13px">Connect</button>
    </section>

    <!-- Error -->
    <div id="error" class="error-banner"></div>

  </main>

</div>

<!-- Ad Panel -->
<div id="adPanel" class="ad-panel" aria-hidden="true">
  <div class="ad-label">Advertisement</div>
  <div id="adContainer"></div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
  import { getDatabase, ref, onValue, off, get } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

  // Config
  const CREATE_LINK_ENDPOINT = '/.netlify/functions/createTelegramLink';
  const MARK_TOKEN_USED = '/.netlify/functions/markTokenUsed';
  const TELEGRAM_BOT_URL = 'https://t.me/QueueJoyBot';
  const MAX_AHEAD = 20;

  // Firebase config (same as original)
  const firebaseConfig = {
    apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
    authDomain: "queue-joy-aa21b.firebaseapp.com",
    databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "queue-joy-aa21b",
    storageBucket: "queue-joy-aa21b.firebasestorage.app",
    messagingSenderId: "950240394209",
    appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  // DOM refs
  const obModal = document.getElementById('onboardingModal');
  const slides = document.querySelectorAll('.slide');
  const obNext = document.getElementById('obNext');
  const obNext2 = document.getElementById('obNext2');
  const obBack1 = document.getElementById('obBack1');
  const obBack2 = document.getElementById('obBack2');
  const obSkip = document.getElementById('obSkip');
  const obFinish = document.getElementById('obFinish');
  const obFinishContent = document.getElementById('obFinishContent');
  const obStatusText = document.getElementById('obStatusText');
  const obDone = document.getElementById('obDone');

  const logoBox = document.getElementById('logoBox');
  const logoText = document.getElementById('logoText');
  const logoImg = document.getElementById('logoImg');
  const yourNumberEl = document.getElementById('yourNumber');
  const nowServingEl = document.getElementById('nowServing');
  const peopleAheadEl = document.getElementById('peopleAhead');
  const estimatedWaitEl = document.getElementById('estimatedWait');
  const progressFill = document.getElementById('progressFill');
  const progressLabel = document.getElementById('progressLabel');
  const progressCaption = document.getElementById('progressCaption');
  const connectMainBtn = document.getElementById('connectMain');
  const connectMiniBtn = document.getElementById('miniConnect');
  const connectionTitle = document.getElementById('connectionTitle');
  const connectionSub = document.getElementById('connectionSub');
  const stayAlert = document.getElementById('stayAlert');
  const connectedAlert = document.getElementById('connectedAlert');
  const adPanel = document.getElementById('adPanel');
  const adContainer = document.getElementById('adContainer');
  const errorBox = document.getElementById('error');

  // State
  let currentQueueKey = null;
  let currentQueueData = null;
  let currentCounterId = null;
  let latestConnectLink = null;
  let linkGenerating = false;
  let isTelegramConnected = false;
  let redirecting = false;
  let avgServiceTime = 3;
  let qRef = null, counterRef = null, adRef = null, analyticsRef = null;

  // UTILITIES
  function showError(msg) {
    if (!errorBox) return;
    errorBox.style.display = 'block';
    errorBox.textContent = msg;
    setTimeout(() => errorBox.style.display = 'none', 6000);
  }

  function extractNumber(str) {
    if (str === null || str === undefined) return null;
    const s = String(str).trim();
    const m = s.match(/(\d+)$/);
    if (m) return parseInt(m[1], 10);
    if (/^\d+$/.test(s)) return parseInt(s, 10);
    return null;
  }

  function formatMinutes(m) {
    const mm = Math.max(0, Math.round(m));
    if (mm === 0) return 'Now';
    if (mm < 60) return `${mm} min`;
    const h = Math.floor(mm / 60), r = mm % 60;
    return r === 0 ? `${h}h` : `${h}h ${r}m`;
  }

  // Modal helpers
  function showSlide(idx) {
    slides.forEach(s => s.classList.remove('active'));
    const slide = document.querySelector(`[data-slide="${idx}"]`);
    if (slide) slide.classList.add('active');
    if (idx === 2) generateLink();
  }

  function openModal() {
    obModal.classList.add('show');
    if (isTelegramConnected) {
      showSlide('connected');
    } else {
      showSlide(0);
    }
  }

  function closeModal() { obModal.classList.remove('show'); }

  obNext && (obNext.onclick = () => showSlide(1));
  obNext2 && (obNext2.onclick = () => showSlide(2));
  obBack1 && (obBack1.onclick = () => showSlide(0));
  obBack2 && (obBack2.onclick = () => showSlide(1));
  obSkip && (obSkip.onclick = () => { localStorage.setItem('qj_modal_skipped_' + currentQueueKey, 'true'); closeModal(); });
  obDone && (obDone.onclick = closeModal);
  obModal && (obModal.onclick = (e) => { if (e.target === obModal) closeModal(); });

  // Telegram link generation (same flow, defensive)
  async function generateLink() {
    if (linkGenerating || latestConnectLink) return;
    linkGenerating = true;
    obFinish.disabled = true;
    obFinishContent.innerHTML = '<span style="display:inline-block;width:18px;height:18px;border:3px solid rgba(255,255,255,0.25);border-top-color:#fff;border-radius:50%;animation:spin .7s linear infinite;margin-right:8px"></span>Generating...';
    obStatusText.textContent = 'Creating secure link...';

    try {
      const res = await fetch(CREATE_LINK_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ queueKey: currentQueueKey })
      });

      if (!res.ok) throw new Error('Failed to generate link');

      const json = await res.json();
      let link = json.link || null;

      if (!link && json.token) {
        link = `${TELEGRAM_BOT_URL}?start=${json.token}`;
      }

      if (link && !link.includes('start=')) {
        const token = currentQueueData?.telegramToken || currentQueueData?.token || currentQueueKey;
        link = `${TELEGRAM_BOT_URL}?start=${token}`;
      }

      latestConnectLink = link || `${TELEGRAM_BOT_URL}?start=${currentQueueKey}`;
      obStatusText.textContent = 'Ready! Tap below to open Telegram.';
      obFinish.disabled = false;
      obFinishContent.innerHTML = 'üöÄ Open Telegram';

    } catch (e) {
      console.error('Link generation failed:', e);
      latestConnectLink = `${TELEGRAM_BOT_URL}?start=${currentQueueKey}`;
      obStatusText.textContent = 'Using fallback link.';
      obFinish.disabled = false;
      obFinishContent.innerHTML = 'üöÄ Open Telegram';
    } finally {
      linkGenerating = false;
    }
  }

  async function openTelegram() {
    if (linkGenerating) return;
    obFinish.disabled = true;
    obFinishContent.innerHTML = '<span style="display:inline-block;width:18px;height:18px;border:3px solid rgba(255,255,255,0.25);border-top-color:#fff;border-radius:50%;animation:spin .7s linear infinite;margin-right:8px"></span>Opening...';
    const url = latestConnectLink || `${TELEGRAM_BOT_URL}?start=${currentQueueKey}`;

    // Open in new tab reliably
    const newTab = window.open(url, '_blank', 'noopener,noreferrer');
    if (!newTab) {
      const a = document.createElement('a');
      a.href = url;
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    // Notify backend (best-effort)
    try {
      const token = url.split('start=')[1];
      if (token) {
        await fetch(MARK_TOKEN_USED, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ queueKey: currentQueueKey, token })
        });
      }
    } catch (e) { /* ignore */ }

    setTimeout(() => {
      obFinish.disabled = false;
      obFinishContent.innerHTML = '‚úÖ Opened!';
      setTimeout(closeModal, 1200);
    }, 500);
  }

  obFinish && (obFinish.onclick = openTelegram);
  connectMainBtn && (connectMainBtn.onclick = openModal);
  connectMiniBtn && (connectMiniBtn.onclick = openModal);
  document.getElementById('miniGame') && (document.getElementById('miniGame').onclick = () => {
    const q = currentQueueKey ? `?queueId=${encodeURIComponent(currentQueueKey)}` : '';
    window.location.assign(`game.html${q}`);
  });

  // UI updates
  function setTelegramUI(connected) {
    isTelegramConnected = connected;

    if (connected) {
      connectionTitle.textContent = '‚úÖ Connected to Telegram';
      connectionSub.textContent = "We'll notify you when it's your turn.";
      connectMainBtn.innerHTML = '‚úÖ';
      connectMainBtn.disabled = true;
      connectMainBtn.classList.add('btn-connected');
      connectMiniBtn && connectMiniBtn.classList.remove('pulse');
      stayAlert.style.display = 'none';
      connectedAlert.style.display = 'block';
    } else {
      connectionTitle.textContent = 'Get Telegram notifications';
      connectionSub.textContent = 'Only Telegram can notify you when the app is closed.';
      connectMainBtn.innerHTML = 'Connect';
      connectMainBtn.disabled = false;
      connectMainBtn.classList.remove('btn-connected');
      connectMiniBtn && connectMiniBtn.classList.add('pulse');
      stayAlert.style.display = 'block';
      connectedAlert.style.display = 'none';
    }
  }

  function updateProgress(pct, ahead, status) {
    const p = Math.max(4, Math.min(100, Math.round(pct)));
    progressFill.style.width = p + '%';
    progressLabel && (progressLabel.textContent = p + '%');

    const st = String(status || '').toLowerCase();
    if (st === 'called' || st === 'serving' || st === 'your_turn') {
      progressCaption.textContent = "üéâ It's your turn!";
      progressCaption.style.color = 'var(--success)';
    } else if (ahead === 0) {
      progressCaption.textContent = "üéØ You're next!";
      progressCaption.style.color = 'var(--primary)';
    } else if (ahead === 1) {
      progressCaption.textContent = "1 person ahead";
      progressCaption.style.color = 'var(--primary)';
    } else if (ahead > 1) {
      progressCaption.textContent = `${ahead} people ahead`;
      progressCaption.style.color = '#6b7280';
    } else {
      progressCaption.textContent = 'Loading...';
      progressCaption.style.color = '#6b7280';
    }
  }

  function redirectToTurn() {
    if (redirecting) return;
    redirecting = true;
    console.log('[STATUS] Redirecting to your_turn.html with queueKey:', currentQueueKey);
    updateProgress(100, 0, 'serving');
    setTimeout(() => {
      window.location.href = `your_turn.html?queueId=${encodeURIComponent(currentQueueKey)}`;
    }, 600);
  }

  // Robust ad handling (supports string or object from Firebase)
  function clearAd() {
    adContainer.innerHTML = '';
    adPanel.style.display = 'none';
    adPanel.setAttribute('aria-hidden', 'true');
  }

  async function showAdPayload(raw) {
    console.log('[AD] payload:', raw);

    if (!raw) { clearAd(); return; }

    let url = '';
    let explicitType = null;
    let poster = null;

    if (typeof raw === 'string') {
      url = raw.trim();
    } else if (typeof raw === 'object' && raw !== null) {
      // support fields: url, src, video, image, media, type/mime, poster/thumb
      url = String(raw.url || raw.src || raw.video || raw.image || raw.media || '').trim();
      explicitType = raw.type || raw.mime || raw.mediaType || null;
      poster = raw.poster || raw.thumb || raw.thumbnail || null;
    }

    if (!url) { clearAd(); return; }

    // heuristics
    const extVideo = /\.(mp4|webm|mov|m4v|ogg)(\?.*)?$/i.test(url);
    const typeVideo = explicitType && String(explicitType).toLowerCase().startsWith('video');
    const keywordVideo = /\bvideo\b/i.test(url);
    const isVideo = extVideo || typeVideo || keywordVideo;

    adContainer.innerHTML = '';
    adPanel.style.display = 'block';
    adPanel.setAttribute('aria-hidden', 'false');

    if (isVideo) {
      // create video element with safe fallbacks
      const video = document.createElement('video');
      video.className = 'ad-media';
      video.src = url;
      video.autoplay = true;
      video.muted = true;
      video.loop = true;
      video.playsInline = true;
      video.setAttribute('playsinline', '');
      if (poster) video.poster = poster;
      video.controls = false;

      // fallback image
      const fallback = document.createElement('img');
      fallback.className = 'ad-media';
      fallback.alt = 'Ad';
      fallback.style.display = 'none';

      let started = false;
      function fallbackToImage() {
        try { video.remove(); } catch (e) {}
        fallback.src = poster || url;
        fallback.style.display = 'block';
        fallback.onerror = () => { console.warn('[AD] fallback image failed'); clearAd(); };
        adContainer.appendChild(fallback);
      }

      video.addEventListener('play', () => { started = true; console.log('[AD] video playing'); });
      video.addEventListener('error', (ev) => { console.warn('[AD] video error', ev); fallbackToImage(); });

      adContainer.appendChild(video);

      // try to play (autoplay policies may block)
      try {
        const p = video.play();
        if (p !== undefined && typeof p.then === 'function') {
          p.catch((err) => {
            console.log('[AD] autoplay blocked or failed:', err);
            // offer user control - enable controls so user can tap to start
            video.controls = true;
            if (poster) {
              // show poster (pause video)
              video.pause();
              video.currentTime = 0;
            }
          });
        }
      } catch (e) {
        console.log('[AD] play() threw', e);
      }

    } else {
      // image or gif
      const img = document.createElement('img');
      img.src = url;
      img.className = 'ad-media';
      img.alt = 'Ad';
      img.onerror = () => { console.warn('[AD] Image failed to load, hiding panel'); clearAd(); };
      adContainer.appendChild(img);
    }
  }

  // logo loader
  async function loadLogo() {
    try {
      const snap = await get(ref(db, 'settings/logoUrl'));
      if (snap.exists() && snap.val()) {
        const url = String(snap.val()).trim();
        if (url) {
          logoImg.src = url;
          logoImg.onload = () => {
            logoText.style.display = 'none';
            logoImg.style.display = 'block';
          };
        }
      }
    } catch (e) { console.warn('logo load error', e); }
  }

  // avg service time
  async function loadAvgServiceTime() {
    try {
      const snap = await get(ref(db, 'analytics/serviceEvents'));
      if (!snap.exists()) return;
      const events = snap.val();
      const times = [];
      for (const k in events) {
        const e = events[k];
        if (e.serviceMs && e.serviceMs > 0) {
          const min = e.serviceMs / 60000;
          if (min <= 120) times.push(min);
        }
      }
      if (times.length > 0) {
        const sum = times.reduce((a, b) => a + b, 0);
        avgServiceTime = Math.max(1, Math.round(sum / times.length));
      }
    } catch (e) { console.warn('avg service time load error', e); }
  }

  // compute estimates & determine redirection
  async function computeEstimates() {
    if (!currentQueueData || redirecting) return;

    const myTicket = currentQueueData.queueId || currentQueueData.ticketNumber || currentQueueData.ticket || currentQueueData.number;
    const myNum = extractNumber(myTicket);
    const myStatus = String(currentQueueData.status || '').toLowerCase();

    console.log('[STATUS] Computing estimates:', { myTicket, myNum, myStatus, called: currentQueueData.called });

    if (myStatus === 'called' || myStatus === 'serving' || myStatus === 'your_turn') { redirectToTurn(); return; }
    if (currentQueueData.called === true || currentQueueData.notifiedAt || currentQueueData.calledAt) { redirectToTurn(); return; }

    // get nowServing from counter if possible
    let servingNum = null;
    let counterData = null;
    const counterId = currentQueueData.counterId || currentQueueData.counter || currentQueueData.counterAssigned;
    if (counterId) {
      try {
        const snap = await get(ref(db, `counters/${counterId}`));
        if (snap.exists()) {
          counterData = snap.val();
          servingNum = extractNumber(counterData.nowServing);
          console.log('[STATUS] Counter data:', { counterId, nowServing: counterData.nowServing, servingNum, myNum });

          // format nowServing display similarly to user's ticket
          const prefix = counterData.prefix || '';
          if (counterData.nowServing !== undefined && counterData.nowServing !== null) {
            const digits = String(myTicket || '').match(/(\d+)$/);
            const len = digits ? digits[1].length : 3;
            const rawServingNum = extractNumber(counterData.nowServing);
            const ticketPrefix = String(myTicket || '').replace(/\d+$/, '').trim();
            const formattedServing = ticketPrefix
              ? `${ticketPrefix} ${String(rawServingNum).padStart(len, '0')}`
              : prefix + String(rawServingNum).padStart(len, '0');
            nowServingEl.textContent = formattedServing;
          }
        }
      } catch (e) {
        console.error('[STATUS] Error fetching counter:', e);
      }
    }

    // people ahead logic
    let peopleAhead = 0;
    if (myNum !== null && servingNum !== null) {
      peopleAhead = myNum - servingNum;
      peopleAhead = Math.max(0, peopleAhead);

      console.log('[STATUS] People ahead calculation:', { myNum, servingNum, peopleAhead });

      if (servingNum === myNum) { redirectToTurn(); return; }
      if (servingNum > myNum) { peopleAhead = 0; /* missed turn */ }
    } else if (myNum === null) {
      console.log('[STATUS] Could not extract myNum from ticket:', myTicket);
      peopleAhead = 0;
    } else {
      // fallback: count waiting entries before my timestamp
      try {
        const allSnap = await get(ref(db, 'queue'));
        if (allSnap.exists()) {
          const all = allSnap.val();
          const myTime = currentQueueData.timestamp || 0;
          for (const k in all) {
            const t = all[k];
            if (!t || String(t.status || '').toLowerCase() !== 'waiting') continue;
            if (counterId && String(t.counterId || t.counter || '') !== String(counterId)) continue;
            if (Number(t.timestamp) < Number(myTime)) peopleAhead++;
          }
        }
      } catch (e) {
        console.error('[STATUS] Fallback count error:', e);
      }
    }

    // update UI
    peopleAheadEl.textContent = peopleAhead;
    const estMin = peopleAhead * avgServiceTime;
    estimatedWaitEl.textContent = formatMinutes(estMin);

    let progressPct;
    if (peopleAhead <= 0) progressPct = 100;
    else if (peopleAhead >= MAX_AHEAD) progressPct = 5;
    else progressPct = Math.round(100 - (peopleAhead / MAX_AHEAD) * 95);

    updateProgress(progressPct, peopleAhead, myStatus);
  }

  // Initialize: read queue key and wire listeners
  document.addEventListener('DOMContentLoaded', async () => {
    const params = new URLSearchParams(window.location.search);
    const queueKey = params.get('queueId') || params.get('queueid') || params.get('qid') || params.get('id');

    if (!queueKey) {
      showError('Queue ID missing. Redirecting...');
      setTimeout(() => window.location.href = 'index.html', 1500);
      return;
    }

    currentQueueKey = queueKey;
    console.log('[STATUS] Initialized with queueKey:', queueKey);

    // Load initial resources
    await Promise.all([loadLogo(), loadAvgServiceTime()]);

    // Watch queue entry
    qRef = ref(db, `queue/${queueKey}`);
    onValue(qRef, (snap) => {
      if (!snap.exists()) {
        showError('Queue not found. Redirecting...');
        setTimeout(() => window.location.href = 'index.html', 1500);
        return;
      }

      currentQueueData = snap.val();
      console.log('[STATUS] Queue data updated:', currentQueueData);

      const ticket = currentQueueData.queueId || currentQueueData.ticketNumber || currentQueueData.ticket || currentQueueData.number || '‚Äî';
      yourNumberEl.textContent = ticket;

      const connected = Boolean(currentQueueData.telegramConnected || currentQueueData.tgConnected || currentQueueData.telegramChatId);
      setTelegramUI(connected);

      if (!connected && !obModal.classList.contains('show') && !localStorage.getItem('qj_modal_skipped_' + queueKey)) {
        openModal();
      }

      // Watch counter
      const cid = currentQueueData.counterId || currentQueueData.counter || currentQueueData.counterAssigned;
      if (cid && cid !== currentCounterId) {
        if (counterRef) off(counterRef);
        currentCounterId = cid;
        counterRef = ref(db, `counters/${cid}`);
        onValue(counterRef, (cSnap) => {
          console.log('[STATUS] Counter data updated');
          computeEstimates();
        });
      }

      computeEstimates();
    });

    // Watch ads (tries common keys; adjust if your DB uses a different path)
    // If your DB stores an object at settings/ad, we'll handle it; if it stores a string at settings/adImage, we handle that too.
    const adPaths = ['settings/ad', 'settings/adImage', 'settings/adObject'];
    let adListenerSet = false;
    for (const p of adPaths) {
      try {
        const r = ref(db, p);
        onValue(r, (snap) => {
          const val = snap.exists() ? snap.val() : null;
          if (val) showAdPayload(val);
          else clearAd();
        });
        // remember the ref to shut down on unload
        adRef = r;
        adListenerSet = true;
        break;
      } catch (e) {
        console.warn('[AD] listener error for', p, e);
      }
    }
    if (!adListenerSet) {
      // fallback to original path to remain compatible
      try {
        adRef = ref(db, 'settings/adImage');
        onValue(adRef, (snap) => showAdPayload(snap.exists() ? snap.val() : null));
      } catch (e) { console.warn('[AD] fallback listener failed', e); }
    }

    // Watch analytics
    analyticsRef = ref(db, 'analytics/serviceEvents');
    onValue(analyticsRef, async () => {
      await loadAvgServiceTime();
      computeEstimates();
    });

    // cleanup on unload
    window.addEventListener('beforeunload', () => {
      if (qRef) off(qRef);
      if (counterRef) off(counterRef);
      if (adRef) off(adRef);
      if (analyticsRef) off(analyticsRef);
    });

    // connect button: fallback opens Telegram link directly
    connectMainBtn.addEventListener('click', () => {
      // If you prefer to open the onboarding modal, call openModal() instead.
      const url = `${TELEGRAM_BOT_URL}?start=${encodeURIComponent(currentQueueKey)}`;
      window.open(url, '_blank', 'noopener');
      // Optionally: mark token used via backend here if you want.
    });
  });
</script>

</body>
</html>
