<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Queue Joy - Snake Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    body { font-family: 'Inter', sans-serif; }
    .fade-in { animation: fadeIn 0.5s ease-in; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(20px);} to { opacity: 1; transform: translateY(0);} }
    canvas { border-radius: 8px; display:block; touch-action: none; }
    .circle { border-radius: 9999px; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 flex flex-col items-center justify-center p-4 pb-32">
  <div class="w-full max-w-sm bg-white rounded-2xl shadow-xl p-6 space-y-4 fade-in">
    <div class="text-center space-y-2">
      <div class="w-12 h-12 bg-gradient-to-r from-purple-600 to-indigo-500 rounded-full flex items-center justify-center mx-auto">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1m4 0h1m-6 4h.01M15 14h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
      </div>
      <h1 class="text-xl font-bold text-indigo-800">Snake Game</h1>
      <p class="text-xs text-gray-500 italic">Play while you wait ‚Äî we‚Äôll call you when your number is up.</p>
    </div>

    <div class="grid grid-cols-2 gap-2 text-center">
      <div class="bg-gray-50 rounded-lg p-2">
        <p class="text-xs text-gray-600">Score</p>
        <p id="score" class="text-sm font-bold text-gray-800">0</p>
      </div>
      <div class="bg-gray-50 rounded-lg p-2">
        <p class="text-xs text-gray-600">High Score</p>
        <p id="highScore" class="text-sm font-bold text-gray-800">0</p>
      </div>
    </div>

    <div id="gameBoard" class="relative w-full" style="padding-top:100%; position:relative;">
      <canvas id="gameCanvas" style="position:absolute; left:0; top:0; width:100%; height:100%"></canvas>
    </div>

    <div id="gameOver" class="hidden bg-red-50 border-2 border-red-200 rounded-xl p-3 text-center">
      <div class="text-2xl mb-1">üò¢</div>
      <p class="text-red-800 font-bold">Game Over!</p>
      <div id="finalStats" class="text-red-700 text-xs"></div>
    </div>

    <div class="space-y-2">
      <button id="newGameBtn" class="w-full py-2 bg-gradient-to-r from-indigo-600 to-purple-500 text-white font-semibold rounded-xl shadow hover:scale-105 transition-all duration-300">üéÆ New Game</button>
      <button id="backBtn" class="w-full py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors">‚Üê Back to Status</button>
      <div id="inlineError" class="hidden text-red-600 text-sm text-center bg-red-50 border border-red-200 rounded-lg p-2"></div>
    </div>
  </div>

  <div class="fixed bottom-4 left-1/2 transform -translate-x-1/2 w-full max-w-sm px-4">
    <div class="bg-white rounded-xl shadow-lg p-3">
      <p class="text-xs text-gray-500 text-center mb-2">Advertisement</p>
      <img id="adPanel" src="" alt="Advertisement" class="w-full rounded-lg shadow-md hidden max-h-24 object-cover">
      <div id="noAd" class="text-center text-gray-400 text-sm py-4">No advertisement available</div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getDatabase, ref, onValue, off, get } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
      authDomain: "queue-joy-aa21b.firebaseapp.com",
      databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "queue-joy-aa21b",
      storageBucket: "queue-joy-aa21b.firebasedatabase.app",
      messagingSenderId: "950240394209",
      appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
    };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // UI refs
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const gameOverEl = document.getElementById('gameOver');
    const finalStatsEl = document.getElementById('finalStats');
    const newGameBtn = document.getElementById('newGameBtn');
    const backBtn = document.getElementById('backBtn');
    const adPanel = document.getElementById('adPanel');
    const noAd = document.getElementById('noAd');
    const inlineError = document.getElementById('inlineError');

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // game variables
    const grid = 16;
    let tileCount = 20; // will adapt with resize
    let score = 0;
    let highScore = 0;
    let loopId = null;
    let count = 0;

    let snake = { x: 160, y:160, dx: grid, dy:0, cells: [], maxCells: 4 };
    let apple = { x: 256, y: 256 };

    // DB listeners
    let adRef = null;
    let queueRef = null;
    let counterRef = null;

    let hasNavigated = false;
    let currentQueueKey = null;
    let currentQueueData = null;

    function showError(msg) {
      inlineError.textContent = msg;
      inlineError.classList.remove('hidden');
      setTimeout(()=> inlineError.classList.add('hidden'), 5000);
    }

    function randInt(min, max){ return Math.floor(Math.random() * (max - min)) + min; }

    function resizeCanvasToContainer() {
      // canvas parent is square via padding-top trick; set canvas pixel size equal to CSS size for sharpness
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(240, Math.min(480, Math.round(rect.width)));
      const h = w;
      canvas.width = w;
      canvas.height = h;
      tileCount = Math.floor(w / grid);
    }

    window.addEventListener('resize', resizeCanvasToContainer);

    function resetGameState() {
      resizeCanvasToContainer();
      const mid = Math.floor(canvas.width / 2 / grid) * grid;
      snake = { x: mid, y: mid, dx: grid, dy: 0, cells: [], maxCells: 4 };
      apple = { x: (randInt(0, tileCount) * grid), y: (randInt(0, tileCount) * grid) };
      score = 0;
      count = 0;
      scoreEl.textContent = score;
      gameOverEl.classList.add('hidden');
      if (loopId) cancelAnimationFrame(loopId);
      loopId = requestAnimationFrame(gameLoop);
    }

    function endGame() {
      if (loopId) cancelAnimationFrame(loopId);
      loopId = null;
      finalStatsEl.innerText = `Final Score: ${score}`;
      gameOverEl.classList.remove('hidden');
    }

    function gameLoop() {
      loopId = requestAnimationFrame(gameLoop);
      if (++count < 4) return;
      count = 0;

      ctx.fillStyle = '#F3F4F6';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      snake.x += snake.dx;
      snake.y += snake.dy;

      // wall collision -> end
      if (snake.x < 0 || snake.x >= canvas.width || snake.y < 0 || snake.y >= canvas.height) {
        endGame(); return;
      }

      snake.cells.unshift({ x: snake.x, y: snake.y });
      if (snake.cells.length > snake.maxCells) snake.cells.pop();

      // draw apple
      ctx.fillStyle = 'red';
      ctx.fillRect(apple.x, apple.y, grid - 1, grid - 1);

      // draw snake
      ctx.fillStyle = 'green';
      for (let i=0;i<snake.cells.length;i++){
        const cell = snake.cells[i];
        ctx.fillRect(cell.x, cell.y, grid - 1, grid - 1);

        // apple eaten
        if (cell.x === apple.x && cell.y === apple.y){
          score += 10;
          snake.maxCells++;
          scoreEl.textContent = score;
          if (score > highScore){ highScore = score; highScoreEl.textContent = highScore; }
          apple.x = randInt(0, tileCount) * grid;
          apple.y = randInt(0, tileCount) * grid;
        }

        // collision with self
        for (let j=i+1;j<snake.cells.length;j++){
          if (cell.x === snake.cells[j].x && cell.y === snake.cells[j].y) { endGame(); return; }
        }
      }
    }

    // touch / click controls map to direction change
    canvas.addEventListener('click', (e) => {
      if (!loopId) return;
      const rect = canvas.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;
      const headX = snake.x + grid/2;
      const headY = snake.y + grid/2;
      const dx = cx - headX;
      const dy = cy - headY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0 && snake.dx === 0) { snake.dx = grid; snake.dy = 0; }
        else if (dx < 0 && snake.dx === 0) { snake.dx = -grid; snake.dy = 0; }
      } else {
        if (dy > 0 && snake.dy === 0) { snake.dx = 0; snake.dy = grid; }
        else if (dy < 0 && snake.dy === 0) { snake.dx = 0; snake.dy = -grid; }
      }
    });

    // --- Firebase listeners ---
    function initAd() {
      try {
        adRef = ref(db, 'settings/adImage');
        onValue(adRef, snap => {
          const v = snap.exists() ? snap.val() : '';
          if (v) { adPanel.src = v; adPanel.classList.remove('hidden'); noAd.classList.add('hidden'); }
          else { adPanel.classList.add('hidden'); noAd.classList.remove('hidden'); }
        });
      } catch(e){ console.warn('ad init error', e); }
    }

    // Watch queue entry and counters. Redirect when called.
    function initQueueAndCounterListeners(dbKey) {
      if (!dbKey) return;
      // cleanup previous
      try { if (queueRef) off(queueRef); if (counterRef) off(counterRef); } catch(e){}

      queueRef = ref(db, `queue/${dbKey}`);
      onValue(queueRef, async snap => {
        if (!snap.exists()) return;
        const val = snap.val();
        currentQueueData = val;
        // if staff set a 'status' flag to 'called' or 'serving', redirect immediately
        const status = (val.status || '').toLowerCase();
        if ((status === 'called' || status === 'serving' || status === 'served') && !hasNavigated) {
          hasNavigated = true;
          window.location.href = `/your_turn.html?queueId=${encodeURIComponent(dbKey)}`;
          return;
        }

        // if counterId present, attach counter listener to detect nowServing hitting user's number
        const counterId = val.counterId;
        if (counterId) {
          // parse user's numeric part from queueId string (e.g. "A012" -> 12)
          const qid = val.queueId || '';
          const prefix = String(qid).match(/^[A-Za-z]*/)?.[0] || '';
          const numeric = Number(String(qid).replace(prefix, '')) || NaN;

          // attach counter nowServing
          try {
            if (counterRef) off(counterRef);
            counterRef = ref(db, `counters/${counterId}/nowServing`);
            onValue(counterRef, nowSnap => {
              const nowVal = Number(nowSnap.val() || 0);
              // when nowServing reaches the user's numeric ticket, redirect
              if (!hasNavigated && Number.isFinite(numeric) && nowVal === numeric) {
                hasNavigated = true;
                window.location.href = `/your_turn.html?queueId=${encodeURIComponent(dbKey)}`;
              }
            });
          } catch (e) {
            console.warn('counter listener error', e);
          }
        }
      });
    }

    // init on DOM ready
    document.addEventListener('DOMContentLoaded', () => {
      // responsive setup
      resizeCanvasToContainer();
      resetGameState();
      initAd();

      const params = new URLSearchParams(window.location.search);
      const dbKey = params.get('queueId');
      currentQueueKey = dbKey || null;

      // back button: always go back to status.html with same queue key if present
      backBtn.addEventListener('click', () => {
        try {
          if (loopId) cancelAnimationFrame(loopId);
        } catch (e) {}
        if (currentQueueKey) {
          window.location.href = `status.html?queueId=${encodeURIComponent(currentQueueKey)}`;
        } else {
          window.location.href = 'index.html';
        }
      });

      // new game
      newGameBtn.addEventListener('click', () => {
        resetGameState();
      });

      // attach DB listener to redirect when called
      if (currentQueueKey) initQueueAndCounterListeners(currentQueueKey);
    });

    // cleanup
    window.addEventListener('beforeunload', () => {
      try {
        if (loopId) cancelAnimationFrame(loopId);
        if (adRef) off(adRef);
        if (queueRef) off(queueRef);
        if (counterRef) off(counterRef);
      } catch (e) {}
    });

  </script>
</body>
</html>
