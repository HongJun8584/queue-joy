<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Queue Joy ‚Äî Snake (Play while you wait)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet"/>
  <style>
    :root { --bg-from: #F8FAFF; --bg-to: #F3F6FF; }
    body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg,var(--bg-from),var(--bg-to)); }
    .card { border-radius: 16px; box-shadow: 0 10px 30px rgba(13, 24, 58, 0.08); }
    canvas { border-radius: 12px; display:block; touch-action:none; background:linear-gradient(180deg,#ffffff,#f7fbff); }
    .pulse { animation: pulse 1s infinite; }
    @keyframes pulse { 0% { transform: scale(1)} 50% { transform: scale(1.02) } 100% { transform: scale(1)} }
  </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

  <main class="w-full max-w-2xl">
    <div class="card bg-white p-6 space-y-4">
      <header class="flex items-center justify-between">
        <div>
          <h1 class="text-lg font-bold text-indigo-700">Snake ‚Äî Play while you wait</h1>
          <p class="text-xs text-gray-500">We‚Äôll call you when your number is up. Keep this tab open.</p>
        </div>
        <div class="flex gap-2 items-center">
          <button id="muteBtn" class="px-3 py-1 rounded-md bg-gray-100 text-sm">üîä</button>
          <button id="pauseBtn" class="px-3 py-1 rounded-md bg-gray-100 text-sm">‚è∏ Pause</button>
        </div>
      </header>

      <section class="grid grid-cols-3 gap-3">
        <div class="col-span-2">
          <div class="relative" style="padding-top:62%; border-radius:12px; overflow:hidden;">
            <canvas id="gameCanvas" style="position:absolute;left:0;top:0;width:100%;height:100%"></canvas>
          </div>
        </div>

        <aside class="space-y-3">
          <div class="bg-gray-50 rounded-lg p-3 text-center">
            <div class="text-xs text-gray-500">Score</div>
            <div id="score" class="text-xl font-semibold text-gray-800">0</div>
          </div>
          <div class="bg-gray-50 rounded-lg p-3 text-center">
            <div class="text-xs text-gray-500">High Score</div>
            <div id="highScore" class="text-xl font-semibold text-gray-800">0</div>
          </div>
          <div class="bg-gray-50 rounded-lg p-3 text-center">
            <div class="text-xs text-gray-500">Queue</div>
            <div id="queueLabel" class="text-sm font-medium text-indigo-700">‚Äî</div>
            <div id="callStatus" class="text-xs text-gray-500 mt-1">Waiting...</div>
          </div>
        </aside>
      </section>

      <div class="flex gap-2">
        <button id="newGameBtn" class="flex-1 py-2 rounded-xl bg-gradient-to-r from-indigo-600 to-purple-500 text-white font-semibold">New Game</button>
        <button id="backBtn" class="py-2 px-4 rounded-xl bg-gray-100 text-gray-700">Back</button>
      </div>

      <div id="gameOver" class="hidden p-3 rounded-lg bg-red-50 text-center text-red-700">
        <div class="text-lg font-bold">Game Over</div>
        <div id="finalStats" class="text-sm mt-1"></div>
      </div>
    </div>

    <!-- Bottom ad / info -->
    <div class="mt-4 card bg-white p-3 text-center">
      <div class="text-xs text-gray-400 mb-2">Advertisement</div>
      <img id="adPanel" class="mx-auto rounded-lg max-h-28 object-cover hidden" alt="Ad"/>
      <div id="noAd" class="text-sm text-gray-400">No advertisement available</div>
    </div>
  </main>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getDatabase, ref, onValue, off } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

    // ---------- CONFIG (keep as your original) ----------
    const firebaseConfig = {
      apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
      authDomain: "queue-joy-aa21b.firebaseapp.com",
      databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "queue-joy-aa21b",
      storageBucket: "queue-joy-aa21b.firebasestorage.app",
      messagingSenderId: "950240394209",
      appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // ---------- UI Refs ----------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const newGameBtn = document.getElementById('newGameBtn');
    const backBtn = document.getElementById('backBtn');
    const muteBtn = document.getElementById('muteBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const gameOverEl = document.getElementById('gameOver');
    const finalStatsEl = document.getElementById('finalStats');
    const adPanel = document.getElementById('adPanel');
    const noAd = document.getElementById('noAd');
    const queueLabel = document.getElementById('queueLabel');
    const callStatus = document.getElementById('callStatus');

    // ---------- Game state ----------
    const GRID = 18;
    let tileCount = 16;
    let score = 0;
    let highScore = Number(localStorage.getItem('snake_highscore') || 0) || 0;
    highScoreEl.textContent = highScore;
    let animationId = null;
    let tick = 0;
    let paused = false;
    let muted = false;

    let snake = {};
    let apple = {};

    // ---------- Queue / Listener state ----------
    let queueKey = null;
    let queueRef = null;
    let counterRef = null;
    let adRef = null;
    let calledAlready = false; // prevent double redirect

    // notification helpers (WebAudio)
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playBeep() {
      if (muted) return;
      try {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine';
        o.frequency.value = 880;
        g.gain.value = 0.08;
        o.connect(g); g.connect(audioCtx.destination);
        o.start();
        setTimeout(()=>{ o.frequency.value = 660; }, 120);
        setTimeout(()=>{ o.stop(); }, 400);
      } catch (e) { /* ignore */ }
    }

    function vibrate() {
      if (navigator.vibrate) navigator.vibrate([200, 80, 200]);
    }

    // visual flash
    function flashTitleAndBg() {
      document.body.style.transition = 'background 0.25s';
      document.body.style.background = 'linear-gradient(135deg,#fff8f0,#fff2f0)';
      setTimeout(()=> { document.body.style.background=''; }, 700);
    }

    // request notification permission
    if ('Notification' in window && Notification.permission === 'default') {
      try { Notification.requestPermission(); } catch(e) {}
    }

    function showDesktopNotification(title, body) {
      if (Notification.permission === 'granted' && !muted) {
        try {
          new Notification(title, { body, silent: true });
        } catch(e) {}
      }
    }

    // ---------- Canvas sizing ----------
    function resizeCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      const size = Math.max(200, Math.min(720, Math.floor(rect.width)));
      canvas.width = size;
      canvas.height = Math.floor(size * 0.62); // match padding-top 62%
      tileCount = Math.max(10, Math.floor(Math.min(canvas.width, canvas.height) / GRID));
    }
    window.addEventListener('resize', resizeCanvas);

    // ---------- Game logic ----------
    function initGame() {
      resizeCanvas();
      const midX = Math.floor(canvas.width / (2*GRID)) * GRID;
      const midY = Math.floor(canvas.height / (2*GRID)) * GRID;
      snake = { x: midX, y: midY, dx: GRID, dy: 0, cells: [], maxCells: 4 };
      apple = placeApple();
      score = 0; tick = 0; paused = false; calledAlready = false;
      scoreEl.textContent = score;
      gameOverEl.classList.add('hidden');
      cancelAnim(); animationId = requestAnimationFrame(loop);
    }

    function placeApple() {
      // pick a cell not occupied by snake
      const maxX = Math.floor(canvas.width / GRID);
      const maxY = Math.floor(canvas.height / GRID);
      let ax, ay, tries = 0;
      while (true) {
        ax = Math.floor(Math.random() * maxX) * GRID;
        ay = Math.floor(Math.random() * maxY) * GRID;
        let collide = snake.cells.some(c => c.x === ax && c.y === ay);
        if (!collide) return { x: ax, y: ay };
        if (++tries > 200) return { x: ax, y: ay }; // fallback
      }
    }

    function loop() {
      animationId = requestAnimationFrame(loop);
      if (paused) return;

      // slower step control
      if (tick++ % 4 !== 0) return;
      tick = tick % 1000;

      // update
      snake.x += snake.dx;
      snake.y += snake.dy;

      // wall collision
      if (snake.x < 0 || snake.x >= canvas.width || snake.y < 0 || snake.y >= canvas.height) {
        return endGame();
      }

      // move body
      snake.cells.unshift({ x: snake.x, y: snake.y });
      if (snake.cells.length > snake.maxCells) snake.cells.pop();

      // eat apple?
      if (snake.x === apple.x && snake.y === apple.y) {
        score += 10;
        snake.maxCells++;
        scoreEl.textContent = score;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('snake_highscore', String(highScore));
          highScoreEl.textContent = highScore;
        }
        apple = placeApple();
      }

      // self collision
      for (let i = 1; i < snake.cells.length; i++) {
        if (snake.cells[i].x === snake.x && snake.cells[i].y === snake.y) {
          return endGame();
        }
      }

      // draw
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // background grid subtle
      ctx.fillStyle = '#F8FAFF';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // draw apple
      ctx.fillStyle = '#EF4444';
      ctx.fillRect(apple.x + 2, apple.y + 2, GRID - 4, GRID - 4);

      // draw snake
      for (let i = 0; i < snake.cells.length; i++) {
        ctx.fillStyle = i === 0 ? '#059669' : '#10B981';
        const c = snake.cells[i];
        ctx.fillRect(c.x + 1, c.y + 1, GRID - 2, GRID - 2);
      }
    }

    function endGame() {
      cancelAnim();
      finalStatsEl.textContent = `Final score: ${score}`;
      gameOverEl.classList.remove('hidden');
    }

    function cancelAnim() {
      if (animationId) cancelAnimationFrame(animationId);
      animationId = null;
    }

    // controls
    window.addEventListener('keydown', (e) => {
      if (!snake) return;
      if (e.key === 'ArrowUp' || e.key === 'w') { if (snake.dy === 0) { snake.dx = 0; snake.dy = -GRID; } }
      else if (e.key === 'ArrowDown' || e.key === 's') { if (snake.dy === 0) { snake.dx = 0; snake.dy = GRID; } }
      else if (e.key === 'ArrowLeft' || e.key === 'a') { if (snake.dx === 0) { snake.dx = -GRID; snake.dy = 0; } }
      else if (e.key === 'ArrowRight' || e.key === 'd') { if (snake.dx === 0) { snake.dx = GRID; snake.dy = 0; } }
      else if (e.key === ' ' ) { togglePause(); e.preventDefault(); }
    });

    // touch / click controls: tap to move toward tap
    canvas.addEventListener('pointerdown', (ev) => {
      if (!snake) return;
      const rect = canvas.getBoundingClientRect();
      const cx = ev.clientX - rect.left;
      const cy = ev.clientY - rect.top;
      const headX = snake.x + GRID/2;
      const headY = snake.y + GRID/2;
      const dx = cx - headX, dy = cy - headY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0 && snake.dx === 0) { snake.dx = GRID; snake.dy = 0; }
        if (dx < 0 && snake.dx === 0) { snake.dx = -GRID; snake.dy = 0; }
      } else {
        if (dy > 0 && snake.dy === 0) { snake.dx = 0; snake.dy = GRID; }
        if (dy < 0 && snake.dy === 0) { snake.dx = 0; snake.dy = -GRID; }
      }
    });

    // UI buttons
    newGameBtn.addEventListener('click', () => initGame());
    backBtn.addEventListener('click', () => {
      cleanupListeners();
      cancelAnim();
      // keep same queue key if present when navigating back to status
      const q = queueKey ? `?queueId=${encodeURIComponent(queueKey)}` : '';
      window.location.href = `status.html${q}`;
    });
    pauseBtn.addEventListener('click', () => togglePause());
    muteBtn.addEventListener('click', () => {
      muted = !muted;
      muteBtn.textContent = muted ? 'üîá' : 'üîä';
    });

    function togglePause() {
      paused = !paused;
      pauseBtn.textContent = paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
      if (!paused && !animationId) animationId = requestAnimationFrame(loop);
    }

    // ---------- Firebase listeners & redirect logic ----------
    // Helper: extract numeric part and full string for safe comparison
    function normalizeNowServing(val) {
      if (val === null || val === undefined) return { raw: '', num: NaN };
      const raw = String(val).trim();
      const num = Number(raw.replace(/\D+/g, '')) || NaN;
      return { raw, num };
    }

    function extractTargetFromQueue(val) {
      // Look for common fields: ticketNumber, number, queueId, or id
      if (!val) return { raw: '', num: NaN };
      const candidates = [ val.ticketNumber, val.number, val.queueId, val.queueIdStr, val.id, val.ticket, val.code ];
      for (const c of candidates) {
        if (c !== undefined && c !== null && String(c).trim() !== '') {
          const s = String(c).trim();
          const n = Number(s.replace(/\D+/g, '')) || NaN;
          return { raw: s, num: n };
        }
      }
      // fallback: try to derive from val.queueId if present elsewhere
      return { raw: '', num: NaN };
    }

    function notifyAndRedirect(targetFull, targetNum) {
      if (calledAlready) return;
      calledAlready = true;
      // audible / visual alert
      playBeep(); vibrate(); flashTitleAndBg(); showDesktopNotification('You are being called', `Ticket ${targetFull || targetNum}`);
      // pause and cleanup
      paused = true;
      cancelAnim();
      // small delay to let UI update and sound play
      setTimeout(() => {
        cleanupListeners();
        // redirect to your_turn page with queue id param
        const q = queueKey ? `?queueId=${encodeURIComponent(queueKey)}` : '';
        window.location.href = `/your_turn.html${q}`;
      }, 700);
    }

    // attaches queue listeners for given queue DB key
    function attachQueueListeners(dbKey) {
      if (!dbKey) return;
      queueKey = dbKey;
      queueLabel.textContent = dbKey;
      // cleanup previous
      cleanupListeners();

      try {
        queueRef = ref(db, `queue/${dbKey}`);
        onValue(queueRef, (snap) => {
          if (!snap.exists()) return;
          const val = snap.val();

          // update UI status
          const status = (val.status || '').toString();
          callStatus.textContent = status ? status : 'Waiting...';

          // extract target ticket from queue entry
          const target = extractTargetFromQueue(val); // { raw, num }

          // if status indicates staff-called, redirect immediately
          const sNormalized = status.toLowerCase();
          if (sNormalized === 'called' || sNormalized === 'serving' || sNormalized === 'called_by_staff' || sNormalized === 'called_by_counter') {
            notifyAndRedirect(target.raw || target.num);
            return;
          }

          // if counterId present, attach counter nowServing watcher
          const counterId = val.counterId || val.counter || val.counter_id;
          if (counterId) {
            // attach counter listener (replacing previous)
            if (counterRef) off(counterRef);
            counterRef = ref(db, `counters/${counterId}/nowServing`);
            onValue(counterRef, (nowSnap) => {
              if (!nowSnap.exists()) return;
              const nowVal = nowSnap.val();
              const now = normalizeNowServing(nowVal); // { raw, num }

              // if target raw equals now.raw (e.g. "A12" == "A12"), or numeric matches, redirect
              // Also if now.raw equals queue's queueId (some setups)
              if (target.raw && target.raw === now.raw) {
                notifyAndRedirect(target.raw, target.num);
                return;
              }
              if (!Number.isNaN(target.num) && !Number.isNaN(now.num) && target.num === now.num) {
                notifyAndRedirect(target.raw || String(target.num), target.num);
                return;
              }
            });
          }
        });
      } catch (e) {
        console.warn('attachQueueListeners error', e);
      }

      // ad listener
      try {
        adRef = ref(db, 'settings/adImage');
        onValue(adRef, snap => {
          const v = snap.exists() ? snap.val() : '';
          if (v) { adPanel.src = v; adPanel.classList.remove('hidden'); noAd.classList.add('hidden'); }
          else { adPanel.classList.add('hidden'); noAd.classList.remove('hidden'); }
        });
      } catch(e){ console.warn('adRef attach error', e); }
    }

    function cleanupListeners() {
      try {
        if (queueRef) { off(queueRef); queueRef = null; }
        if (counterRef) { off(counterRef); counterRef = null; }
        if (adRef) { off(adRef); adRef = null; }
      } catch(e) { console.warn('cleanup listeners error', e); }
    }

    // ---------- Init flow ----------
    function initFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const dbKey = params.get('queueId') || params.get('q') || params.get('id');
      if (dbKey) attachQueueListeners(dbKey);
      initGame();
    }

    // ensure we properly stop audio context on unload
    window.addEventListener('beforeunload', () => {
      cleanupListeners();
      cancelAnim();
      try { audioCtx.close(); } catch(e) {}
    });

    // start
    initFromUrl();

  </script>
</body>
</html>
