<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Queue Joy - Snake Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    body { font-family: 'Inter', sans-serif; }
    .fade-in { animation: fadeIn 0.5s ease-in; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(20px);} to { opacity: 1; transform: translateY(0);} }
    canvas { border-radius: 8px; display:block; touch-action: none; }
    .no-scroll { overflow: hidden !important; height: 100% !important; touch-action: none !important; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 flex flex-col items-center justify-center p-4 pb-32">
  <div class="w-full max-w-sm bg-white rounded-2xl shadow-xl p-6 space-y-4 fade-in">
    <div class="text-center space-y-2">
      <div class="w-12 h-12 bg-gradient-to-r from-purple-600 to-indigo-500 rounded-full flex items-center justify-center mx-auto">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1m4 0h1m-6 4h.01M15 14h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
      </div>
      <h1 class="text-xl font-bold text-indigo-800">Snake Game</h1>
      <p class="text-xs text-gray-500 italic">Play while you wait ‚Äî we‚Äôll call you when your number is up.</p>
    </div>

    <div class="grid grid-cols-2 gap-2 text-center">
      <div class="bg-gray-50 rounded-lg p-2">
        <p class="text-xs text-gray-600">Score</p>
        <p id="score" class="text-sm font-bold text-gray-800">0</p>
      </div>
      <div class="bg-gray-50 rounded-lg p-2">
        <p class="text-xs text-gray-600">High Score</p>
        <p id="highScore" class="text-sm font-bold text-gray-800">0</p>
      </div>
    </div>

    <div id="gameBoard" class="relative w-full" style="padding-top:100%; position:relative;">
      <canvas id="gameCanvas" style="position:absolute; left:0; top:0; width:100%; height:100%"></canvas>
    </div>

    <div id="gameOver" class="hidden bg-red-50 border-2 border-red-200 rounded-xl p-3 text-center">
      <div class="text-2xl mb-1">üò¢</div>
      <p class="text-red-800 font-bold">Game Over!</p>
      <div id="finalStats" class="text-red-700 text-xs"></div>
    </div>

    <div class="space-y-2">
      <button id="newGameBtn" class="w-full py-2 bg-gradient-to-r from-indigo-600 to-purple-500 text-white font-semibold rounded-xl shadow hover:scale-105 transition-all duration-300">üéÆ New Game</button>
      <button id="backBtn" class="w-full py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors">‚Üê Back to Status</button>
      <div id="inlineError" class="hidden text-red-600 text-sm text-center bg-red-50 border border-red-200 rounded-lg p-2"></div>
    </div>
  </div>

  <div class="fixed bottom-4 left-1/2 transform -translate-x-1/2 w-full max-w-sm px-4">
    <div class="bg-white rounded-xl shadow-lg p-3">
      <p class="text-xs text-gray-500 text-center mb-2">Advertisement</p>
      <img id="adPanel" src="" alt="Advertisement" class="w-full rounded-lg shadow-md hidden max-h-24 object-cover">
      <div id="noAd" class="text-center text-gray-400 text-sm py-4">No advertisement available</div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getDatabase, ref, onValue, off } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
      authDomain: "queue-joy-aa21b.firebaseapp.com",
      databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "queue-joy-aa21b",
      storageBucket: "queue-joy-aa21b.firebasestorage.app",
      messagingSenderId: "950240394209",
      appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
    };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // UI refs
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const gameOverEl = document.getElementById('gameOver');
    const finalStatsEl = document.getElementById('finalStats');
    const newGameBtn = document.getElementById('newGameBtn');
    const backBtn = document.getElementById('backBtn');
    const adPanel = document.getElementById('adPanel');
    const noAd = document.getElementById('noAd');
    const inlineError = document.getElementById('inlineError');

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // game variables
    const grid = 16;
    let tileCount = 20; // will adapt with resize
    let score = 0;
    let highScore = 0;
    let loopId = null;
    let count = 0;

    let snake = { x: 160, y:160, dx: grid, dy:0, cells: [], maxCells: 4 };
    let apple = { x: 256, y: 256 };

    // DB listeners
    let adRef = null;
    let queueRef = null;
    let counterRef = null;

    let hasNavigated = false;
    let currentQueueKey = null;
    let currentQueueData = null;

    // scroll-lock helpers
    let _preventTouchMove = (e) => { e.preventDefault(); };
    function lockScroll() {
      document.documentElement.classList.add('no-scroll');
      document.body.classList.add('no-scroll');
      window.addEventListener('wheel', preventWheel, { passive: false });
      window.addEventListener('touchmove', _preventTouchMove, { passive: false });
    }
    function unlockScroll() {
      document.documentElement.classList.remove('no-scroll');
      document.body.classList.remove('no-scroll');
      window.removeEventListener('wheel', preventWheel, { passive: false });
      window.removeEventListener('touchmove', _preventTouchMove, { passive: false });
    }
    function preventWheel(e){ e.preventDefault(); }

    function showError(msg) {
      inlineError.textContent = msg;
      inlineError.classList.remove('hidden');
      setTimeout(()=> inlineError.classList.add('hidden'), 5000);
    }

    function randInt(min, max){ return Math.floor(Math.random() * (max - min)) + min; }

    function resizeCanvasToContainer() {
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(240, Math.min(480, Math.round(rect.width)));
      canvas.width = w;
      canvas.height = w;
      tileCount = Math.max(6, Math.floor(w / grid));
    }

    window.addEventListener('resize', resizeCanvasToContainer);

    function resetGameState() {
      // unlock scroll on restart
      unlockScroll();

      resizeCanvasToContainer();
      const mid = Math.floor(canvas.width / 2 / grid) * grid;
      snake = { x: mid, y: mid, dx: grid, dy: 0, cells: [], maxCells: 4 };
      apple = { x: (randInt(0, tileCount) * grid), y: (randInt(0, tileCount) * grid) };
      score = 0;
      count = 0;
      scoreEl.textContent = score;
      gameOverEl.classList.add('hidden');
      if (loopId) cancelAnimationFrame(loopId);
      loopId = requestAnimationFrame(gameLoop);
    }

    function endGame() {
      if (loopId) cancelAnimationFrame(loopId);
      loopId = null;
      finalStatsEl.innerText = `Final Score: ${score}`;
      gameOverEl.classList.remove('hidden');

      // lock scrolling while Game Over is visible
      lockScroll();
    }

    function gameLoop() {
      loopId = requestAnimationFrame(gameLoop);
      if (++count < 4) return;
      count = 0;

      ctx.fillStyle = '#F3F4F6';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      snake.x += snake.dx;
      snake.y += snake.dy;

      // wall collision -> end
      if (snake.x < 0 || snake.x >= canvas.width || snake.y < 0 || snake.y >= canvas.height) {
        endGame(); return;
      }

      snake.cells.unshift({ x: snake.x, y: snake.y });
      if (snake.cells.length > snake.maxCells) snake.cells.pop();

      // draw apple
      ctx.fillStyle = 'red';
      ctx.fillRect(apple.x, apple.y, grid - 1, grid - 1);

      // draw snake
      ctx.fillStyle = 'green';
      for (let i=0;i<snake.cells.length;i++){
        const cell = snake.cells[i];
        ctx.fillRect(cell.x, cell.y, grid - 1, grid - 1);

        // apple eaten
        if (cell.x === apple.x && cell.y === apple.y){
          score += 10;
          snake.maxCells++;
          scoreEl.textContent = score;
          if (score > highScore){ highScore = score; highScoreEl.textContent = highScore; }
          apple.x = randInt(0, tileCount) * grid;
          apple.y = randInt(0, tileCount) * grid;
        }

        // collision with self
        for (let j=i+1;j<snake.cells.length;j++){
          if (cell.x === snake.cells[j].x && cell.y === snake.cells[j].y) { endGame(); return; }
        }
      }
    }

    // touch / click controls map to direction change
    canvas.addEventListener('click', (e) => {
      if (!loopId) return;
      const rect = canvas.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;
      const headX = snake.x + grid/2;
      const headY = snake.y + grid/2;
      const dx = cx - headX;
      const dy = cy - headY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0 && snake.dx === 0) { snake.dx = grid; snake.dy = 0; }
        else if (dx < 0 && snake.dx === 0) { snake.dx = -grid; snake.dy = 0; }
      } else {
        if (dy > 0 && snake.dy === 0) { snake.dx = 0; snake.dy = grid; }
        else if (dy < 0 && snake.dy === 0) { snake.dx = 0; snake.dy = -grid; }
      }
    });

    // --- Firebase listeners ---
    function initAd() {
      try {
        adRef = ref(db, 'settings/adImage');
        onValue(adRef, snap => {
          const v = snap.exists() ? snap.val() : '';
          if (v) { adPanel.src = v; adPanel.classList.remove('hidden'); noAd.classList.add('hidden'); }
          else { adPanel.classList.add('hidden'); noAd.classList.remove('hidden'); }
        });
      } catch(e){ console.warn('ad init error', e); }
    }

    // safe cleanup helper
    function cleanupListeners() {
      try {
        if (adRef) { off(adRef); adRef = null; }
        if (queueRef) { off(queueRef); queueRef = null; }
        if (counterRef) { off(counterRef); counterRef = null; }
      } catch (e) { console.warn('cleanup error', e); }
    }

    // same-tab top-level redirect helper
    function performSameTabRedirect(dbKey) {
      try {
        // stop animations & listeners first
        if (loopId) cancelAnimationFrame(loopId);
        cleanupListeners();
      } catch (e) { console.warn('redirect cleanup error', e); }

      const url = `/your_turn.html?queueId=${encodeURIComponent(dbKey)}`;

      // Attempt to force navigation in the top frame (works when page is in iframe)
      try {
        if (window.top && window.top !== window) {
          // use href (same tab) on the top window
          window.top.location.href = url;
          return;
        }
      } catch (e) {
        // cross-origin frames may throw; fall back below
        console.warn('top.location access failed', e);
      }

      // fallback: replace current location in same tab (does not open new tab)
      try {
        window.location.replace(url);
      } catch (e) {
        // last resort
        window.location.href = url;
      }
    }

    // attach queue + counter listeners and redirect when called
    function initQueueAndCounterListeners(dbKey) {
      if (!dbKey) return;
      // cleanup previous
      cleanupListeners();

      queueRef = ref(db, `queue/${dbKey}`);
      onValue(queueRef, (snap) => {
        if (!snap.exists()) return;
        const val = snap.val();
        currentQueueData = val;

        // build possible identifiers from the queue entry
        const identifiers = [];
        function pushIf(v){
          if (v === undefined || v === null) return;
          const s = String(v).trim();
          if (s.length) identifiers.push(s);
        }
        pushIf(val.ticketNumber);
        pushIf(val.number);
        pushIf(val.queueId);
        pushIf(val.id);
        pushIf(val.ticket);
        pushIf(val.code);
        // also include numeric-only forms
        const numericIds = identifiers.map(s => {
          const n = Number(String(s).replace(/\D+/g,''));
          return Number.isFinite(n) ? n : NaN;
        });

        // If status was explicitly set to a 'called' state by staff, redirect
        const status = (val.status || '').toString().toLowerCase();
        if ((status === 'called' || status === 'serving' || status === 'called_by_staff') && !hasNavigated) {
          hasNavigated = true;
          performSameTabRedirect(dbKey);
          return;
        }

        // attach counter nowServing listener if counterId exists
        const counterId = val.counterId || val.counter || val.counter_id;
        if (counterId) {
          // attach counterRef if not already attached
          if (counterRef) off(counterRef);
          counterRef = ref(db, `counters/${counterId}/nowServing`);
          onValue(counterRef, (nowSnap) => {
            if (!nowSnap.exists()) return;

            // tolerate nowServing being number, string, or object with value
            let nowRaw = nowSnap.val();
            if (typeof nowRaw === 'object' && nowRaw !== null) {
              nowRaw = nowRaw.value || nowRaw.nowServing || nowRaw.current || nowRaw;
            }
            nowRaw = String(nowRaw || '').trim();
            if (!nowRaw) return;

            // compare raw equality
            if (!hasNavigated && identifiers.some(id => id === nowRaw)) {
              hasNavigated = true;
              performSameTabRedirect(dbKey);
              return;
            }

            // compare numeric part if applicable
            const nowNum = Number(nowRaw.replace(/\D+/g,''));
            if (!hasNavigated && Number.isFinite(nowNum)) {
              for (const idNum of numericIds) {
                if (Number.isFinite(idNum) && idNum === nowNum) {
                  hasNavigated = true;
                  performSameTabRedirect(dbKey);
                  return;
                }
              }
            }

            // compare nowRaw to queue key as fallback
            if (!hasNavigated && nowRaw === String(dbKey)) {
              hasNavigated = true;
              performSameTabRedirect(dbKey);
              return;
            }
          });
        }
      });
    }

    // init on DOM ready
    document.addEventListener('DOMContentLoaded', () => {
      resizeCanvasToContainer();
      resetGameState();
      initAd();

      const params = new URLSearchParams(window.location.search);
      const dbKey = params.get('queueId');
      currentQueueKey = dbKey || null;

      // Back button: always return to status with same queue key
      backBtn.addEventListener('click', () => {
        try { if (loopId) cancelAnimationFrame(loopId); } catch(e){}
        cleanupListeners();
        // unlock scroll on navigate back
        unlockScroll();
        const q = currentQueueKey ? `?queueId=${encodeURIComponent(currentQueueKey)}` : '';
        // same-tab back navigation
        window.location.replace(`status.html${q}`);
      });

      newGameBtn.addEventListener('click', () => {
        resetGameState();
      });

      // attach DB listener to redirect when called
      if (currentQueueKey) initQueueAndCounterListeners(currentQueueKey);
    });

    // cleanup before unload
    window.addEventListener('beforeunload', () => {
      try {
        if (loopId) cancelAnimationFrame(loopId);
        cleanupListeners();
        unlockScroll();
      } catch (e) {}
    });

  </script>
</body>
</html>
