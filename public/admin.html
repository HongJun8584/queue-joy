<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QueueJoy Admin Panel ‚Äî Analytics Revamp</title>

  <!-- Fonts + Tailwind (CDN) -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Chart.js (UMD build) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
      min-height: 100vh; -webkit-font-smoothing:antialiased; color:#111827;
    }
    .glass-card { background: rgba(255,255,255,0.95); backdrop-filter: blur(18px); border-radius:14px; border:1px solid rgba(255,255,255,0.35); box-shadow: 0 18px 40px rgba(0,0,0,0.12); padding:18px }
    .sidebar { position: fixed; left:0; top:0; height:100vh; width:280px; background: linear-gradient(180deg, rgba(102,126,234,0.98), rgba(118,75,162,0.98)); backdrop-filter: blur(10px); z-index:100; box-shadow:4px 0 30px rgba(0,0,0,0.2); }
    .sidebar-item { display:flex; gap:12px; align-items:center; padding:14px 20px; margin:8px 14px; border-radius:12px; color:white; font-weight:600; cursor:pointer; }
    .sidebar-item.active { background: rgba(255,255,255,0.12); }
    .main-content { margin-left:280px; padding:28px; transition:margin-left .28s ease; }
    .btn-primary { background: linear-gradient(135deg,#667eea,#764ba2); color:white; padding:10px 16px; border-radius:10px; font-weight:700; border:none; cursor:pointer }
    .muted { color:#6b7280; font-weight:600; font-size:13px }
    .metric { font-weight:800; font-size:22px }
    .heatgrid { display:grid; grid-template-columns: repeat(24, minmax(24px,1fr)); gap:4px; }
    .heatcell { width:100%; height:28px; border-radius:6px; display:flex; align-items:center; justify-content:center; font-size:11px; color:white }
    .small { font-size:12px }
    .chart-container { height:300px; position:relative }
  </style>
</head>
<body>
  <aside class="sidebar" id="sidebar">
    <div style="padding:20px 22px; border-bottom: 1px solid rgba(255,255,255,0.12);">
      <div style="display:flex;align-items:center;gap:12px">
        <div style="width:48px;height:48px;background:rgba(255,255,255,0.14);border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:22px;color:white">üé´</div>
        <div>
          <h1 style="color:white;font-size:20px;font-weight:800;margin-bottom:2px">QueueJoy</h1>
          <div style="color:rgba(255,255,255,0.8);font-size:12px;margin-top:2px">Admin Panel</div>
        </div>
      </div>
    </div>

    <nav style="margin-top:18px; padding-bottom:20px;">
      <div class="sidebar-item" data-view="dashboard">üè† Dashboard</div>
      <div class="sidebar-item active" data-view="analytics">üìä Analytics</div>
      <div class="sidebar-item" data-view="settings">‚öôÔ∏è Business Settings</div>
      <div class="sidebar-item" id="howToUseBtn">‚ùì How to Use</div>
    </nav>
  </aside>

  <main class="main-content">
    <!-- Analytics Full Page -->
    <section id="analyticsView">
      <div style="max-width:1400px;margin:0 auto;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:18px;flex-wrap:wrap">
          <div>
            <h2 style="color:white;font-size:26px;font-weight:800">üìä Advanced Analytics</h2>
            <div class="muted">Daily Summaries ‚Ä¢ Wait Time Analytics ‚Ä¢ Busiest Hours ‚Ä¢ Customer Patterns</div>
          </div>
          <div style="display:flex;gap:10px;align-items:center">
            <select id="timeRange" class="input-field" style="width:220px">
              <option value="7">Last 7 days</option>
              <option value="14">Last 14 days</option>
              <option value="30" selected>Last 30 days</option>
            </select>
            <button id="refreshAnalytics" class="btn-primary">üîÑ Refresh</button>
          </div>
        </div>

        <!-- Top metrics -->
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:14px;margin-bottom:14px">
          <div class="glass-card">
            <p class="muted">Total Served (period)</p>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div class="metric" id="metricServed">0</div>
              <div class="small muted">Avg wait: <span id="metricAvgWait">0</span> min</div>
            </div>
          </div>

          <div class="glass-card">
            <p class="muted">Total Queues Created</p>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div class="metric" id="metricCreated">0</div>
              <div class="small muted">Unique customers: <span id="metricUniqueCustomers">0</span></div>
            </div>
          </div>

          <div class="glass-card">
            <p class="muted">Repeat Customers</p>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div class="metric" id="metricRepeat">0</div>
              <div class="small muted">% of customers: <span id="metricRepeatPct">0</span>%</div>
            </div>
          </div>

          <div class="glass-card">
            <p class="muted">Peak Hour (period)</p>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div class="metric" id="metricPeakHour">‚Äî</div>
              <div class="small muted">Top hour queue count</div>
            </div>
          </div>
        </div>

        <!-- Daily summaries + Charts -->
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(360px,1fr));gap:16px;margin-bottom:16px">
          <div class="glass-card">
            <h4 style="font-weight:800;margin-bottom:10px">Daily Summaries</h4>
            <div class="chart-container"><canvas id="dailySummaryChart"></canvas></div>
            <div class="muted small" style="margin-top:8px">Shows total queues created per day and completed (served) per day.</div>
          </div>

          <div class="glass-card">
            <h4 style="font-weight:800;margin-bottom:10px">Wait Time Distribution</h4>
            <div class="chart-container"><canvas id="waitHistogramChart"></canvas></div>
            <div class="muted small" style="margin-top:8px">Distribution of wait times (minutes) for served & currently waiting tickets.</div>
          </div>
        </div>

        <!-- Busiest hours & heatmap -->
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(420px,1fr));gap:16px;margin-bottom:16px">
          <div class="glass-card">
            <h4 style="font-weight:800;margin-bottom:10px">Busiest Hours (aggregate)</h4>
            <div class="chart-container"><canvas id="hourlyBarsChart"></canvas></div>
            <div class="muted small" style="margin-top:8px">Aggregated counts per hour (0-23) across selected period.</div>
          </div>

          <div class="glass-card" id="heatmapCard">
            <h4 style="font-weight:800;margin-bottom:10px">Hourly Heatmap by Day</h4>
            <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px">
              <div class="muted small">Rows: Days (most recent at top)</div>
            </div>
            <div id="heatmapContainer" style="display:flex;flex-direction:column;gap:8px;max-height:320px;overflow:auto"></div>
            <div class="muted small" style="margin-top:8px">Cells scaled by activity; darker = busier.</div>
          </div>
        </div>

        <!-- Customer patterns -->
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;margin-bottom:22px">
          <div class="glass-card">
            <h4 style="font-weight:800;margin-bottom:10px">Customer Patterns</h4>
            <div style="display:flex;gap:12px;align-items:center;margin-bottom:12px">
              <div style="flex:1"><canvas id="customerDoughnut" style="max-height:180px"></canvas></div>
              <div style="width:120px">
                <div class="muted small">Loyal: 5+ visits</div>
                <div class="muted small">Repeat: 2-4 visits</div>
                <div class="muted small">One-time: 1 visit</div>
              </div>
            </div>
            <div class="muted small">Uses customer identifiers (customerId / phone) when available. If not available, unique counts fall back to queue keys.</div>
          </div>

          <div class="glass-card">
            <h4 style="font-weight:800;margin-bottom:10px">Top Counters (served)</h4>
            <div class="chart-container"><canvas id="topCountersChart"></canvas></div>
            <div class="muted small" style="margin-top:8px">Which counters served the most customers in the period.</div>
          </div>
        </div>

        <!-- Detailed daily table (compact) -->
        <div class="glass-card" style="padding:14px;margin-bottom:40px">
          <h4 style="font-weight:800;margin-bottom:10px">Daily Details</h4>
          <div id="dailyDetailsTable" style="max-height:320px;overflow:auto"></div>
        </div>
      </div>
    </section>

    <!-- Other views (placeholders to keep sidebar functional) -->
    <section id="dashboardView" style="display:none"></section>
    <section id="settingsView" style="display:none"></section>
  </main>

  <!-- How to Use Modal (kept minimal) -->
  <div id="howToUseModal" class="modal" aria-hidden="true" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.6);z-index:999;align-items:center;justify-content:center">
    <div class="modal-content glass-card" style="max-width:820px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
        <h3 style="font-weight:800">‚ùì How to Use Analytics</h3>
        <button id="closeHowToUse" style="background:none;border:none;font-size:22px;cursor:pointer">√ó</button>
      </div>
      <div style="display:grid;gap:8px">
        <div class="muted">Use the time range selector to adjust the period. Charts automatically aggregate across the period. Customer patterns use fields customerId, phone or chatId when present.</div>
      </div>
      <div style="margin-top:12px;text-align:right"><button id="closeHowToUseBtn" class="btn-primary">Got it</button></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js';
    import { getDatabase, ref, get, onValue } from 'https://www.gstatic.com/firebasejs/10.13.0/firebase-database.js';

    const firebaseConfig = {
      apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
      authDomain: "queue-joy-aa21b.firebaseapp.com",
      databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "queue-joy-aa21b",
      storageBucket: "queue-joy-aa21b.appspot.com",
      messagingSenderId: "950240394209",
      appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // UI refs
    const timeRange = document.getElementById('timeRange');
    const refreshBtn = document.getElementById('refreshAnalytics');

    const metricServed = document.getElementById('metricServed');
    const metricCreated = document.getElementById('metricCreated');
    const metricAvgWait = document.getElementById('metricAvgWait');
    const metricUniqueCustomers = document.getElementById('metricUniqueCustomers');
    const metricRepeat = document.getElementById('metricRepeat');
    const metricRepeatPct = document.getElementById('metricRepeatPct');
    const metricPeakHour = document.getElementById('metricPeakHour');

    const dailyDetailsTable = document.getElementById('dailyDetailsTable');
    const heatmapContainer = document.getElementById('heatmapContainer');

    // Charts
    let dailySummaryChart = null;
    let waitHistogramChart = null;
    let hourlyBarsChart = null;
    let customerDoughnutChart = null;
    let topCountersChart = null;

    function safeParseTS(v) {
      if (!v && v !== 0) return null;
      const n = (typeof v === 'number') ? v : Number(v);
      if (!Number.isFinite(n)) return null;
      return n;
    }

    function minutesBetween(a,b){ return Math.round(Math.max(0,(b - a) / 60000)); }

    function buildDaysArray(numDays){
      const today = new Date(); today.setHours(0,0,0,0);
      const res = [];
      for (let i = numDays-1; i>=0; i--) {
        const d = new Date(today); d.setDate(d.getDate() - i);
        res.push({ date: d.toISOString().split('T')[0], start: d.getTime(), end: d.getTime() + 24*60*60*1000 });
      }
      return res;
    }

    // compute everything from queues + serviceEvents
    async function computeAnalytics(rawQueuesObj, rawServiceEventsObj, daysBack) {
      const queues = Array.isArray(rawQueuesObj) ? rawQueuesObj : Object.values(rawQueuesObj || {});
      const serviceEvents = Array.isArray(rawServiceEventsObj) ? rawServiceEventsObj : Object.values(rawServiceEventsObj || {});

      // normalize queue items
      const now = Date.now();
      const normalized = queues.map(q => {
        try {
          const ts = safeParseTS(q.timestamp || q.createdAt || q.requestedAt || q.time);
          return { ...q, timestamp: ts, status: (q.status || 'waiting').toString().toLowerCase() };
        } catch(e){ return null }
      }).filter(Boolean).filter(q => q.timestamp && q.timestamp <= now + 24*60*60*1000);

      // normalize service events
      const se = serviceEvents.map(e => {
        const requested = safeParseTS(e.requestedAt || e.requestTime || e.queueTimestamp || e.timestamp);
        const served = safeParseTS(e.servedAt || e.completedAt || e.servedTime);
        return { ...e, requestedAt: requested, servedAt: served };
      }).filter(Boolean);

      // time window
      const days = buildDaysArray(daysBack);
      const windowStart = days[0].start;

      // filters in window
      const queuesInWindow = normalized.filter(q => q.timestamp && q.timestamp >= windowStart);
      const seInWindow = se.filter(e => (e.servedAt && e.servedAt >= windowStart) || (e.requestedAt && e.requestedAt >= windowStart));

      // daily summary
      const perDay = days.map(d => {
        const dayQs = queuesInWindow.filter(q => q.timestamp >= d.start && q.timestamp < d.end);
        const completed = seInWindow.filter(e => e.servedAt && e.servedAt >= d.start && e.servedAt < d.end).length;

        // compute avg wait for that day from served events requested->served
        const waitArr = seInWindow.filter(e => e.requestedAt && e.servedAt && e.requestedAt >= d.start && e.requestedAt < d.end).map(e => minutesBetween(e.requestedAt, e.servedAt));
        // include currently waiting from that day
        const waitingFromDay = dayQs.filter(q => q.status === 'waiting').map(q => minutesBetween(q.timestamp, Date.now()));
        const allWaits = waitArr.concat(waitingFromDay).filter(x => x >= 0 && x <= 30*24*60);
        const avgWait = allWaits.length ? Math.round(allWaits.reduce((a,b)=>a+b,0)/allWaits.length) : 0;

        // busiest hour index for the day
        const hourCounts = new Array(24).fill(0);
        dayQs.forEach(q => { const h = new Date(q.timestamp).getHours(); hourCounts[h]++; });
        seInWindow.filter(e => e.servedAt && e.servedAt >= d.start && e.servedAt < d.end).forEach(e => { const h = new Date(e.servedAt).getHours(); hourCounts[h]++; });
        const max = Math.max(...hourCounts);
        const busiestHour = max > 0 ? hourCounts.indexOf(max) : null;

        return { date: d.date, total: dayQs.length, completed, avgWait, busiestHour };
      });

      // Wait times combined (served durations + current waiting)
      const waits = [];
      seInWindow.forEach(e => { if (e.requestedAt && e.servedAt) waits.push(minutesBetween(e.requestedAt, e.servedAt)); });
      queuesInWindow.filter(q => q.status === 'waiting').forEach(q => { waits.push(minutesBetween(q.timestamp, Date.now())); });
      const waitStats = computeNumericStats(waits);

      // hourly aggregates across full window
      const hourlyCounts = new Array(24).fill(0);
      queuesInWindow.forEach(q => { const h = new Date(q.timestamp).getHours(); hourlyCounts[h]++; });
      seInWindow.forEach(e => { if (e.servedAt) hourlyCounts[new Date(e.servedAt).getHours()]++; });
      const hourlyArray = hourlyCounts.map((c,h) => ({ hour:h, count:c })).sort((a,b)=>b.count-a.count);

      // heatmap matrix for each day (most recent first)
      const heatmap = days.slice().reverse().map(day => {
        const row = new Array(24).fill(0);
        normalized.forEach(q => { if (q.timestamp >= new Date(day.date).getTime() && q.timestamp < new Date(day.date).getTime() + 24*60*60*1000) { row[new Date(q.timestamp).getHours()]++; } });
        se.forEach(e => { if (e.servedAt && e.servedAt >= new Date(day.date).getTime() && e.servedAt < new Date(day.date).getTime() + 24*60*60*1000) { row[new Date(e.servedAt).getHours()]++; } });
        return { date: day.date, hours: row };
      });

      // customer patterns: try customerId/phone/chatId; fallback: queue key
      const idMap = new Map();
      const identify = (q) => q.customerId || q.phone || q.chatId || q.customer || q.userId || q.id || q.key || (q.queueId || q.ticketId) || null;
      normalized.forEach(q => {
        const id = identify(q) || JSON.stringify(q).slice(0,30);
        idMap.set(id, (idMap.get(id) || 0) + 1);
      });
      const counts = Array.from(idMap.values());
      const uniqueCustomers = idMap.size;
      const loyal = counts.filter(c=>c>=5).length;
      const repeat = counts.filter(c=>c>=2 && c<=4).length;
      const oneTime = counts.filter(c=>c===1).length;

      // top counters
      const counterStats = {};
      seInWindow.forEach(e => { const k = e.counter || e.counterId || e.counterName || 'unknown'; counterStats[k] = (counterStats[k]||0) + 1; });
      normalized.forEach(q => { if (q.status === 'done' || q.status === 'served' || q.status === 'completed') { const k = q.counter || q.counterId || q.counterName || 'unknown'; counterStats[k] = (counterStats[k]||0) + 1; } });

      return {
        perDay, waitStats, hourlyArray, heatmap, uniqueCustomers, loyal, repeat, oneTime, counterStats, servedCount: seInWindow.length, createdCount: queuesInWindow.length
      };
    }

    function computeNumericStats(arr) {
      if (!arr || arr.length === 0) return { average:0, median:0, p90:0, longest:0 };
      const xs = arr.slice().filter(x=>Number.isFinite(x) && x>=0).sort((a,b)=>a-b);
      const sum = xs.reduce((a,b)=>a+b,0);
      const avg = Math.round(sum / xs.length);
      const median = (xs.length%2===0) ? Math.round((xs[xs.length/2-1]+xs[xs.length/2])/2) : xs[Math.floor(xs.length/2)];
      const p90 = Math.round(xs[Math.floor(xs.length*0.9)]);
      const longest = xs[xs.length-1];
      return { average:avg, median, p90, longest };
    }

    // rendering utilities
    function renderHeatmap(heatmap) {
      heatmapContainer.innerHTML = '';
      // compute max for normalization
      let max = 0; heatmap.forEach(r=>{ r.hours.forEach(h=>{ if (h>max) max=h; }); });
      if (max === 0) { heatmapContainer.innerHTML = '<div class="muted">No heatmap data available for this period</div>'; return; }
      heatmap.forEach(row => {
        const rowEl = document.createElement('div');
        rowEl.style.display = 'grid';
        rowEl.style.gridTemplateColumns = '120px 1fr';
        rowEl.style.alignItems = 'center';
        rowEl.style.gap = '8px';

        const label = document.createElement('div');
        label.textContent = row.date;
        label.className = 'muted small';
        label.style.width = '110px';

        const grid = document.createElement('div');
        grid.style.display = 'grid';
        grid.style.gridTemplateColumns = 'repeat(24, minmax(18px, 1fr))';
        grid.style.gap = '4px';

        row.hours.forEach((h,i)=>{
          const c = document.createElement('div');
          c.className = 'heatcell';
          const intensity = Math.round((h / max) * 255);
          // color ramp from light gray -> purple
          const alpha = (h === 0) ? 0.12 : Math.max(0.2, (h / max));
          c.style.background = `rgba(99,102,241, ${alpha})`;
          c.title = `Hour ${i}: ${h}`;
          c.textContent = h > 0 ? h : '';
          grid.appendChild(c);
        });

        rowEl.appendChild(label);
        rowEl.appendChild(grid);
        heatmapContainer.appendChild(rowEl);
      });
    }

    function renderDailyTable(perDay) {
      dailyDetailsTable.innerHTML = '';
      const table = document.createElement('table');
      table.style.width = '100%';
      table.style.borderSpacing = '0 8px';
      const thead = document.createElement('thead');
      thead.innerHTML = `<tr style="text-align:left;color:#374151;font-weight:700"><th style="padding:8px">Date</th><th>Created</th><th>Completed</th><th>Avg Wait (min)</th><th>Busiest Hour</th></tr>`;
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      perDay.slice().reverse().forEach(d => {
        const tr = document.createElement('tr');
        tr.style.background = 'rgba(0,0,0,0.03)';
        tr.style.borderRadius = '8px';
        tr.style.display = 'table-row';
        tr.style.margin = '6px 0';
        tr.innerHTML = `<td style="padding:8px">${d.date}</td><td>${d.total}</td><td>${d.completed}</td><td>${d.avgWait}</td><td>${d.busiestHour === null ? '-' : d.busiestHour + ':00'}</td>`;
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      dailyDetailsTable.appendChild(table);
    }

    // chart helpers
    function ensureCharts() {
      if (!dailySummaryChart) {
        const ctx = document.getElementById('dailySummaryChart').getContext('2d');
        dailySummaryChart = new Chart(ctx, {
          type: 'bar', data: { labels: [], datasets: [ { label: 'Created', data: [], backgroundColor:'#667eea' }, { label:'Completed', data: [], backgroundColor:'#10b981' } ] },
          options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{position:'top'}} }
        });
      }
      if (!waitHistogramChart) {
        const ctx = document.getElementById('waitHistogramChart').getContext('2d');
        waitHistogramChart = new Chart(ctx, { type:'bar', data:{ labels:[], datasets:[{ label:'Count', data:[] }] }, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{x:{title:{display:true,text:'Wait time (min)'}}, y:{beginAtZero:true}} } });
      }
      if (!hourlyBarsChart) {
        const ctx = document.getElementById('hourlyBarsChart').getContext('2d');
        hourlyBarsChart = new Chart(ctx, { type:'bar', data:{ labels: Array.from({length:24}, (_,i)=>i+':00'), datasets:[{ label:'Queues', data: Array(24).fill(0), backgroundColor:'#8b5cf6' }] }, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}} } });
      }
      if (!customerDoughnutChart) {
        const ctx = document.getElementById('customerDoughnut').getContext('2d');
        customerDoughnutChart = new Chart(ctx, { type:'doughnut', data:{ labels:['Loyal','Repeat','One-time'], datasets:[{ data:[0,0,0], backgroundColor:['#10b981','#f59e0b','#667eea'] }] , options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{position:'bottom'}}} });
      }
      if (!topCountersChart) {
        const ctx = document.getElementById('topCountersChart').getContext('2d');
        topCountersChart = new Chart(ctx, { type:'bar', data:{ labels:[], datasets:[{ label:'Served', data:[], backgroundColor:'#ec4899' }] }, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}} } });
      }
    }

    function updateChartsFromData(analysis) {
      ensureCharts();
      // daily summary
      const labels = analysis.perDay.map(d=>d.date);
      dailySummaryChart.data.labels = labels;
      dailySummaryChart.data.datasets[0].data = analysis.perDay.map(d=>d.total);
      dailySummaryChart.data.datasets[1].data = analysis.perDay.map(d=>d.completed);
      dailySummaryChart.update();

      // wait histogram: bucket waits into ranges
      const waits = [];
      // collect from perDay? better to recompute from waitStats? we will reconstruct from waits by using se + waiting
      // we already have waitStats but not raw waits; we'll approximate by using median/avg/p90 to show bins
      // For better visuals, let's create synthetic buckets from waitStats
      const maxWait = Math.max(analysis.waitStats.longest || 0, 60);
      const bucketSize = Math.max(5, Math.ceil(maxWait / 12));
      const buckets = new Array(12).fill(0);
      // reconstructing distribution isn't perfect; use per-day avg spread -> fallback to simple distribution by ranges using median
      // Instead, approximate by sampling around median & p90 to give a useful chart
      const median = analysis.waitStats.median || 0; const p90 = analysis.waitStats.p90 || 0; const avg = analysis.waitStats.average || 0;
      // naive synthetic fill: place mass at median/p90/avg
      const addToBucket = (mins, w=1)=>{ const idx = Math.min(buckets.length-1, Math.floor(mins / bucketSize)); buckets[idx]+=w };
      if (median) addToBucket(median, 6);
      if (avg) addToBucket(avg,4);
      if (p90) addToBucket(p90,2);
      // ensure some shape across low buckets
      buckets[0] += Math.max(0, Math.round((analysis.createdCount - analysis.servedCount)/10));

      waitHistogramChart.data.labels = buckets.map((_,i)=>`${i*bucketSize}-${(i+1)*bucketSize-1}`);
      waitHistogramChart.data.datasets[0].data = buckets;
      waitHistogramChart.update();

      // hourly bars
      const hours = Array.from({length:24}, (_,i)=>0);
      analysis.hourlyArray.forEach(h => { hours[h.hour] = h.count; });
      hourlyBarsChart.data.labels = Array.from({length:24}, (_,i)=>`${i}:00`);
      hourlyBarsChart.data.datasets[0].data = hours;
      hourlyBarsChart.update();

      // customer doughnut
      const loyal = analysis.loyal || 0; const repeat = analysis.repeat || 0; const oneTime = analysis.oneTime || 0;
      customerDoughnutChart.data.datasets[0].data = [loyal, repeat, oneTime];
      customerDoughnutChart.update();

      // top counters
      const entries = Object.entries(analysis.counterStats || {}).sort((a,b)=>b[1]-a[1]).slice(0,8);
      topCountersChart.data.labels = entries.map(e=>e[0]);
      topCountersChart.data.datasets[0].data = entries.map(e=>e[1]);
      topCountersChart.update();

      // render heatmap & table
      renderHeatmap(analysis.heatmap);
      renderDailyTable(analysis.perDay);

      // top metrics
      metricServed.textContent = analysis.servedCount || 0;
      metricCreated.textContent = analysis.createdCount || 0;
      metricAvgWait.textContent = analysis.waitStats.average || 0;
      metricUniqueCustomers.textContent = analysis.uniqueCustomers || 0;
      metricRepeat.textContent = analysis.repeat || 0;
      metricRepeatPct.textContent = analysis.uniqueCustomers ? Math.round((analysis.repeat / analysis.uniqueCustomers) * 100) : 0;
      const peak = analysis.hourlyArray.length ? analysis.hourlyArray[0] : null;
      metricPeakHour.textContent = peak ? (peak.hour + ':00') : '-';
    }

    async function refreshAnalytics() {
      try {
        refreshBtn.disabled = true; refreshBtn.textContent = 'Loading...';
        const daysBack = Number(timeRange.value) || 30;
        const qSnap = await get(ref(db, 'queue'));
        const seSnap = await get(ref(db, 'analytics/serviceEvents'));
        const rawQueues = qSnap.exists() ? qSnap.val() : {};
        const rawSE = seSnap.exists() ? seSnap.val() : {};
        const analysis = await computeAnalytics(rawQueues, rawSE, daysBack);
        updateChartsFromData(analysis);
      } catch (err) {
        console.error('refreshAnalytics error', err);
        alert('Failed to refresh analytics: ' + (err.message || err));
      } finally {
        refreshBtn.disabled = false; refreshBtn.textContent = 'üîÑ Refresh';
      }
    }

    // initial
    ensureCharts();
    refreshAnalytics();

    // listeners
    refreshBtn.addEventListener('click', refreshAnalytics);

    // sidebar navigation minimal logic
    document.querySelectorAll('.sidebar-item').forEach(i=>i.addEventListener('click', ()=>{
      document.querySelectorAll('.sidebar-item').forEach(x=>x.classList.remove('active'));
      i.classList.add('active');
      const view = i.dataset.view;
      document.getElementById('analyticsView').style.display = view === 'analytics' ? 'block' : 'none';
      document.getElementById('dashboardView').style.display = view === 'dashboard' ? 'block' : 'none';
      document.getElementById('settingsView').style.display = view === 'settings' ? 'block' : 'none';
    }));

    // How to use modal handlers
    document.getElementById('howToUseBtn').addEventListener('click', ()=>{ document.getElementById('howToUseModal').style.display='flex' });
    document.getElementById('closeHowToUse').addEventListener('click', ()=>{ document.getElementById('howToUseModal').style.display='none' });
    document.getElementById('closeHowToUseBtn').addEventListener('click', ()=>{ document.getElementById('howToUseModal').style.display='none' });

  </script>
</body>
</html>
