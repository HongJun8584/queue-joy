<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QueueJoy — Admin (Analytics)</title>

  <!-- Tailwind (dev) + Chart.js -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:linear-gradient(135deg,#667eea 0%,#764ba2 100%); color:#111827; min-height:100vh; padding:24px; }
    .card { background: rgba(255,255,255,0.96); border-radius:12px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,0.12); }
    .muted { color:#6b7280; font-weight:600; font-size:13px; }
    .btn { background:linear-gradient(135deg,#667eea,#764ba2); color:white; padding:10px 14px; border-radius:10px; font-weight:700; border:none; cursor:pointer; }
    .badge { display:inline-block;padding:6px 10px;border-radius:8px;font-weight:700;color:white;margin:4px 4px 4px 0 }
    .heatcell { width:48px;height:28px;border-radius:6px;display:inline-flex;align-items:center;justify-content:center;margin:2px; font-size:12px;color:white }
    .small { font-size:12px; color:#374151 }
    pre { white-space:pre-wrap; word-break:break-word }
    table { width:100%; border-collapse:collapse; font-size:13px }
    th,td { padding:8px; text-align:left; border-bottom:1px solid #eef2ff }
  </style>
</head>
<body>
  <div style="max-width:1300px;margin:0 auto;display:grid;grid-template-columns:1fr 420px;gap:20px">
    <div>
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px">
        <div>
          <h1 style="color:white;font-size:22px;font-weight:900;margin:0">QueueJoy — Admin</h1>
          <div style="color:rgba(255,255,255,0.85);font-size:13px">Analytics powered by your Firebase structure</div>
        </div>

        <div style="display:flex;gap:8px">
          <button id="exportCsv" class="btn">⬇ Export CSV</button>
          <button id="refreshBtn" class="btn">⟳ Refresh</button>
        </div>
      </div>

      <!-- Top metrics -->
      <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin-bottom:12px">
        <div class="card">
          <div class="muted">Total Queues</div><div id="totalQueues" style="font-weight:900;font-size:20px">0</div>
        </div>
        <div class="card">
          <div class="muted">Active Waiting</div><div id="waitingQueues" style="font-weight:900;font-size:20px">0</div>
        </div>
        <div class="card">
          <div class="muted">Completed (served)</div><div id="completedCount" style="font-weight:900;font-size:20px">0</div>
        </div>
        <div class="card">
          <div class="muted">Active Counters</div><div id="activeCounters" style="font-weight:900;font-size:20px">0</div>
        </div>
      </div>

      <!-- Daily summaries -->
      <div class="card" style="margin-bottom:12px" id="dailySummaryCard">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <h2 style="font-size:16px;font-weight:900">Daily Summaries (Last 7 days)</h2>
          <div class="small muted">Based on `queue` timestamps & `analytics/serviceEvents`</div>
        </div>

        <div id="dailyTableWrap" style="overflow:auto;max-height:220px">
          <table id="dailyTable">
            <thead>
              <tr><th>Date</th><th>Created</th><th>Completed</th><th>Cancelled</th><th>Avg Wait (min)</th><th>Busiest Hour</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <!-- Wait analytics + distribution -->
      <div style="display:grid;grid-template-columns:1fr 360px;gap:12px;margin-bottom:12px">
        <div class="card">
          <h3 style="font-weight:900">Wait Time Analytics</h3>
          <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap">
            <div>
              <div class="muted">Average</div><div id="waitAvg" style="font-weight:900;font-size:18px">0 min</div>
            </div>
            <div>
              <div class="muted">Median</div><div id="waitMedian" style="font-weight:900;font-size:18px">0 min</div>
            </div>
            <div>
              <div class="muted">90th percentile</div><div id="waitP90" style="font-weight:900;font-size:18px">0 min</div>
            </div>
            <div>
              <div class="muted">Longest</div><div id="waitMax" style="font-weight:900;font-size:18px">0 min</div>
            </div>
          </div>

          <div style="margin-top:16px">
            <canvas id="waitDistChart" style="max-height:260px"></canvas>
          </div>
        </div>

        <div class="card">
          <h3 style="font-weight:900">Customer Patterns</h3>
          <div style="margin-top:10px">
            <div class="muted">Unique subscribers (queue or subscriptions)</div>
            <div id="uniqueCustomers" style="font-weight:900;font-size:18px">0</div>
          </div>

          <div style="margin-top:12px">
            <div class="muted">Repeat vs One-time</div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <div style="flex:1">
                <div class="muted">Repeat</div><div id="repeatCount" style="font-weight:900">0</div>
              </div>
              <div style="flex:1">
                <div class="muted">One-time</div><div id="oneTimeCount" style="font-weight:900">0</div>
              </div>
            </div>
          </div>

          <div style="margin-top:12px">
            <div class="muted">Top subscribers (by served)</div>
            <div id="topSubscribers" style="margin-top:8px"></div>
          </div>
        </div>
      </div>

      <!-- Busiest hours + charts -->
      <div class="card" style="margin-bottom:12px">
        <h3 style="font-weight:900">Busiest Hours (Last 7 days)</h3>
        <div style="display:flex;gap:12px;margin-top:12px;align-items:flex-start">
          <div style="flex:1">
            <div id="topHoursBadges" style="margin-bottom:12px"></div>
            <canvas id="hoursChart" style="height:220px"></canvas>
          </div>

          <div style="width:260px">
            <div class="muted">Per-day heat (hours)</div>
            <div id="heatmap" style="margin-top:8px"></div>
            <div class="small muted" style="margin-top:8px">Darker = busier</div>
          </div>
        </div>
      </div>

      <!-- Counter performance -->
      <div class="card" style="margin-bottom:12px">
        <h3 style="font-weight:900">Counter Performance</h3>
        <div id="counterPerfWrap" style="margin-top:12px"></div>
      </div>

    </div>

    <!-- Right column: settings preview / debug -->
    <div>
      <div class="card" style="margin-bottom:12px">
        <h3 style="font-weight:900">Realtime Settings Preview</h3>
        <div style="margin-top:8px">
          <div class="muted">Main title</div><div id="mainTitle" style="font-weight:800">—</div>
          <div class="muted" style="margin-top:8px">Intro</div><div id="introText" class="small">—</div>
        </div>
      </div>

      <div class="card" style="margin-bottom:12px">
        <h3 style="font-weight:900">Announcement</h3>
        <div class="muted">Subscribers (count)</div><div id="announceCount" style="font-weight:900">0</div>
        <div style="margin-top:8px">
          <div class="muted">Bot token present?</div><div id="botTokenPresent" style="font-weight:900">—</div>
        </div>
      </div>

      <div class="card" id="debugCard">
        <h3 style="font-weight:900">Debug / Raw</h3>
        <div class="muted">Last refresh</div><div id="lastRefresh" class="small">—</div>
        <pre id="rawPreview" style="max-height:360px;overflow:auto"></pre>
      </div>
    </div>
  </div>

  <!-- Firebase -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js';
    import { getDatabase, ref, onValue, get } from 'https://www.gstatic.com/firebasejs/10.13.0/firebase-database.js';

    // --- YOUR firebase config (kept from your dump) ---
    const firebaseConfig = {
      apiKey: "AIzaSyDiRGvkQbnLlpnJT3fEEQrY1A3nwLVIFY0",
      authDomain: "queue-joy-aa21b.firebaseapp.com",
      databaseURL: "https://queue-joy-aa21b-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "queue-joy-aa21b",
      storageBucket: "queue-joy-aa21b.appspot.com",
      messagingSenderId: "950240394209",
      appId: "1:950240394209:web:78d4f2471d2d89ac91f0a0"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // --- UI refs ---
    const totalQueuesEl = document.getElementById('totalQueues');
    const waitingQueuesEl = document.getElementById('waitingQueues');
    const completedCountEl = document.getElementById('completedCount');
    const activeCountersEl = document.getElementById('activeCounters');
    const dailyTableBody = document.querySelector('#dailyTable tbody');
    const waitAvgEl = document.getElementById('waitAvg');
    const waitMedianEl = document.getElementById('waitMedian');
    const waitP90El = document.getElementById('waitP90');
    const waitMaxEl = document.getElementById('waitMax');
    const uniqueCustomersEl = document.getElementById('uniqueCustomers');
    const repeatCountEl = document.getElementById('repeatCount');
    const oneTimeCountEl = document.getElementById('oneTimeCount');
    const topSubscribersEl = document.getElementById('topSubscribers');
    const topHoursBadges = document.getElementById('topHoursBadges');
    const heatmapEl = document.getElementById('heatmap');
    const counterPerfWrap = document.getElementById('counterPerfWrap');
    const announceCountEl = document.getElementById('announceCount');
    const botTokenPresentEl = document.getElementById('botTokenPresent');
    const mainTitleEl = document.getElementById('mainTitle');
    const introTextEl = document.getElementById('introText');
    const rawPreview = document.getElementById('rawPreview');
    const lastRefreshEl = document.getElementById('lastRefresh');
    const exportCsvBtn = document.getElementById('exportCsv');
    const refreshBtn = document.getElementById('refreshBtn');

    // --- charts ---
    let waitDistChart = null;
    let hoursChart = null;

    function createChartIfNeeded() {
      if (!waitDistChart) {
        const ctx = document.getElementById('waitDistChart').getContext('2d');
        waitDistChart = new Chart(ctx, {
          type: 'bar',
          data: { labels: [], datasets:[{ label:'Tickets', data:[] , backgroundColor: undefined }] },
          options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
        });
      }
      if (!hoursChart) {
        const ctx = document.getElementById('hoursChart').getContext('2d');
        hoursChart = new Chart(ctx, {
          type: 'line',
          data: { labels: Array.from({length:24}, (_,i) => i+'h'), datasets: [{ label:'Events', data:Array(24).fill(0), tension:0.3, fill:true }] },
          options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
        });
      }
    }
    createChartIfNeeded();

    // ---------- helpers ----------
    function safeNum(n) {
      if (n === undefined || n === null) return null;
      const x = Number(n);
      if (!Number.isFinite(x)) return null;
      return x;
    }

    // Interpret timestamp values robustly:
    // Some values in your dump are >1e12 (ms since epoch). Accept numbers > 1e11 as unix-ms, otherwise try URL-style parse.
    function parseTs(ts) {
      if (ts === undefined || ts === null) return null;
      if (typeof ts === 'number') {
        if (ts > 1e11 && ts < 1e18) return ts;
        if (ts > 1e9 && ts < 1e11) return ts * 1000; // maybe seconds
      }
      const n = Number(ts);
      if (!Number.isNaN(n)) {
        if (n > 1e11 && n < 1e18) return n;
        if (n > 1e9 && n < 1e11) return n * 1000;
      }
      const d = Date.parse(ts);
      return Number.isNaN(d) ? null : d;
    }

    function minsBetween(a,b){ return Math.round(Math.abs(b-a)/60000); }

    // statistical helpers
    function computeStats(arr) {
      if (!arr || arr.length===0) return { avg:0, median:0, p90:0, max:0, counts:[] };
      const xs = arr.slice().sort((a,b)=>a-b);
      const sum = xs.reduce((s,v)=>s+v,0);
      const avg = Math.round(sum/xs.length);
      const median = xs.length%2===0 ? Math.round((xs[xs.length/2-1]+xs[xs.length/2])/2) : xs[Math.floor(xs.length/2)];
      const p90 = xs[Math.min(xs.length-1, Math.floor(xs.length*0.9))];
      const max = xs[xs.length-1];
      return { avg, median, p90, max, counts: xs };
    }

    function formatDateYMD(ms) {
      const d = new Date(ms);
      return d.toISOString().split('T')[0];
    }

    function formatHourLabel(h){
      if (h===0) return '12AM';
      if (h<12) return `${h}AM`;
      if (h===12) return '12PM';
      return `${h-12}PM`;
    }

    // ---------- main analytics logic ----------
    async function computeAndRenderAll(snapshotQueue, snapshotServiceEvents, snapshotCounters, snapshotSettings, snapshotAnnouncement, snapshotQueueSubs) {
      lastRefreshEl.textContent = new Date().toLocaleString();
      rawPreview.textContent = `queue: ${Object.keys(snapshotQueue || {}).length || 0}\nserviceEvents: ${Object.keys(snapshotServiceEvents || {}).length || 0}\ncounters: ${Object.keys(snapshotCounters || {}).length || 0}`;

      // Normalize inputs to arrays
      const queues = Object.values(snapshotQueue || {}).map(q => ({ ...q }));
      const serviceEvents = Object.values(snapshotServiceEvents || {}).map(e => ({ ...e }));

      // quick counts
      totalQueuesEl.textContent = queues.length;
      const waiting = queues.filter(q => (q.status || 'waiting').toString().toLowerCase() === 'waiting').length;
      waitingQueuesEl.textContent = waiting;

      const activeCounters = Object.values(snapshotCounters || {}).filter(c => c && c.active === true).length;
      activeCountersEl.textContent = activeCounters;
      document.getElementById('analystActiveCounters')?.textContent = activeCounters; // optional

      // Completed — prefer serviceEvents length (authoritative)
      const completed = serviceEvents.length;
      completedCountEl.textContent = completed;

      // Announcement info
      const announceIds = snapshotAnnouncement?.chatIds ? Object.keys(snapshotAnnouncement.chatIds) : [];
      announceCountEl.textContent = announceIds.length;
      botTokenPresentEl.textContent = snapshotAnnouncement?.botToken ? 'Yes' : 'No';

      // SETTINGS preview
      mainTitleEl.textContent = snapshotSettings?.mainTitle || '—';
      introTextEl.textContent = snapshotSettings?.introText || '—';

      // WAIT TIME: combine serviceEvents durations (serviceMs / minutes) and current waiting durations from queue entries
      const waitsMins = [];
      // from serviceEvents (use serviceMs if present or servedAt-requestedAt)
      serviceEvents.forEach(e => {
        if (e.serviceMs && Number.isFinite(e.serviceMs)) {
          const m = Math.round(Number(e.serviceMs) / 60000);
          if (m>=0 && m<30*24*60) waitsMins.push(m);
        } else {
          const req = parseTs(e.requestedAt);
          const served = parseTs(e.servedAt);
          if (req && served && served >= req) {
            const m = minsBetween(req, served);
            if (m>=0 && m<30*24*60) waitsMins.push(m);
          }
        }
      });
      // from current waiting queue entries: now - timestamp
      const now = Date.now();
      queues.filter(q => (q.status||'waiting').toLowerCase()==='waiting').forEach(q => {
        const ts = parseTs(q.timestamp);
        if (!ts) return;
        const m = Math.max(0, Math.round((now - ts)/60000));
        if (m>=0 && m<30*24*60) waitsMins.push(m);
      });

      const waitStats = computeStats(waitsMins);
      waitAvgEl.textContent = waitStats.avg + ' min';
      waitMedianEl.textContent = waitStats.median + ' min';
      waitP90El.textContent = waitStats.p90 + ' min';
      waitMaxEl.textContent = waitStats.max + ' min';

      // Distribution histogram (buckets: 0-5,6-10,11-20,21-30,31-60,61-120,120+)
      const buckets = [
        {label:'0-5', min:0, max:5},
        {label:'6-10', min:6, max:10},
        {label:'11-20', min:11, max:20},
        {label:'21-30', min:21, max:30},
        {label:'31-60', min:31, max:60},
        {label:'61-120', min:61, max:120},
        {label:'120+', min:121, max:Infinity}
      ];
      const bucketCounts = buckets.map(b => waitsMins.filter(m => m>=b.min && m<=b.max).length);

      // update wait chart
      createChartIfNeeded();
      waitDistChart.data.labels = buckets.map(b=>b.label);
      waitDistChart.data.datasets[0].data = bucketCounts;
      waitDistChart.update();

      // DAILY SUMMARY (last 7 days)
      const days = [];
      const today = new Date();
      today.setHours(0,0,0,0);
      for (let i=6;i>=0;i--) {
        const d = new Date(today); d.setDate(d.getDate() - i);
        const start = d.getTime();
        const end = start + 24*60*60*1000;
        // created that day
        const dayQueues = queues.filter(q => {
          const ts = parseTs(q.timestamp);
          return ts && ts >= start && ts < end;
        });
        const total = dayQueues.length;
        const cancelled = dayQueues.filter(q => (q.status||'waiting').toLowerCase() === 'cancelled').length;
        // completed via serviceEvents servedAt in that day
        const completedDay = serviceEvents.filter(e => {
          const s = parseTs(e.servedAt);
          return s && s >= start && s < end;
        }).length;

        // avg wait for day: use served events requested->served for those requested that day OR waiting tickets from that day
        const waitTimesForDay = [];
        serviceEvents.forEach(e => {
          const req = parseTs(e.requestedAt);
          const served = parseTs(e.servedAt);
          if (req && served && req >= start && req < end) {
            const m = Math.round((served - req)/60000);
            if (m>=0 && m<30*24*60) waitTimesForDay.push(m);
          }
        });
        dayQueues.forEach(q => {
          if ((q.status||'waiting').toLowerCase()==='waiting') {
            const ts = parseTs(q.timestamp);
            if (ts && ts >= start && ts < end) {
              const m = Math.round((now - ts)/60000);
              if (m>=0 && m<30*24*60) waitTimesForDay.push(m);
            }
          }
        });
        const avgWaitDay = waitTimesForDay.length ? Math.round(waitTimesForDay.reduce((a,b)=>a+b,0)/waitTimesForDay.length) : 0;

        // busiest hour: count queue.timestamp hours + servedAt hours inside the day
        const hourCounts = new Array(24).fill(0);
        dayQueues.forEach(q => { const ts = parseTs(q.timestamp); if (ts) hourCounts[new Date(ts).getHours()]++; });
        serviceEvents.forEach(e => { const s = parseTs(e.servedAt); if (s && s>=start && s<end) hourCounts[new Date(s).getHours()]++; });
        const maxCount = Math.max(...hourCounts);
        const busiestHour = maxCount>0 ? hourCounts.indexOf(maxCount) : null;

        days.push({ date: formatDateYMD(start), total, completed: completedDay, cancelled, avgWait: avgWaitDay, busiestHour, hourCounts });
      }

      // render daily table
      dailyTableBody.innerHTML = '';
      days.forEach(d => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td style="font-weight:800">${d.date}</td>
                        <td>${d.total}</td>
                        <td>${d.completed}</td>
                        <td>${d.cancelled}</td>
                        <td>${d.avgWait} min</td>
                        <td>${d.busiestHour !== null ? formatHourLabel(d.busiestHour) : '-'}</td>`;
        dailyTableBody.appendChild(tr);
      });

      // BUSIEST HOURS (aggregate last 7 days)
      const aggHours = new Array(24).fill(0);
      // queues in last7
      const last7 = now - 7*24*60*60*1000;
      queues.forEach(q => {
        const ts = parseTs(q.timestamp);
        if (ts && ts >= last7) aggHours[new Date(ts).getHours()]++;
      });
      serviceEvents.forEach(e => {
        const s = parseTs(e.servedAt);
        if (s && s >= last7) aggHours[new Date(s).getHours()]++;
      });

      const hoursArr = aggHours.map((c,h)=>({hour:h,count:c})).sort((a,b)=>b.count-a.count);
      // badges
      topHoursBadges.innerHTML = '';
      hoursArr.slice(0,5).forEach((h,i) => {
        const b = document.createElement('span');
        b.className = 'badge';
        const colors = ['#667eea','#8b5cf6','#ec4899','#f59e0b','#10b981'];
        b.style.background = colors[i % colors.length];
        b.textContent = `${formatHourLabel(h.hour)}: ${h.count}`;
        topHoursBadges.appendChild(b);
      });

      // hours chart
      hoursChart.data.labels = Array.from({length:24},(_,i)=>formatHourLabel(i));
      hoursChart.data.datasets[0].data = aggHours;
      hoursChart.update();

      // heatmap per-day: render rows for each day with 24 small cells colored by count
      heatmapEl.innerHTML = '';
      const maxForHeat = Math.max(...days.flatMap(d=>d.hourCounts));
      days.forEach(d => {
        const rowWrap = document.createElement('div');
        rowWrap.style.display = 'flex';
        rowWrap.style.alignItems = 'center';
        rowWrap.style.marginBottom = '6px';
        const label = document.createElement('div');
        label.style.width = '70px';
        label.style.fontSize = '12px';
        label.style.marginRight = '8px';
        label.textContent = d.date;
        rowWrap.appendChild(label);
        d.hourCounts.forEach(c => {
          const cell = document.createElement('div');
          const intensity = maxForHeat ? Math.round((c/maxForHeat)*220) : 40;
          // choose color scale from light to dark purple
          const bg = `rgba(99,102,241,${0.15 + (intensity/255)})`;
          cell.className = 'heatcell';
          cell.style.background = bg;
          cell.title = c + ' events';
          cell.textContent = c>0 ? c : '';
          rowWrap.appendChild(cell);
        });
        heatmapEl.appendChild(rowWrap);
      });

      // Customer patterns: use queue.chatId & queueSubscriptions to identify uniqueness & repeaters
      const subsMap = snapshotQueueSubs || {};
      const customerCounts = {}; // key by chatId OR subscription uuid fallback
      queues.forEach(q => {
        const chatId = q.chatId || null;
        const subsUuid = Object.keys(subsMap || {}).find(k => subsMap[k] === q.chatId) || null;
        const key = chatId ? `c:${chatId}` : (subsUuid ? `s:${subsUuid}` : `q:${q.queueId||Math.random().toString(36).slice(2,7)}`);
        customerCounts[key] = (customerCounts[key] || 0) + 1;
      });
      const uniqueCustomers = Object.keys(customerCounts).length;
      uniqueCustomersEl.textContent = uniqueCustomers;
      const repeats = Object.values(customerCounts).filter(v=>v>1).length;
      const oneTimes = Object.values(customerCounts).filter(v=>v===1).length;
      repeatCountEl.textContent = repeats;
      oneTimeCountEl.textContent = oneTimes;

      // Top subscribers by count
      topSubscribersEl.innerHTML = '';
      Object.entries(customerCounts).sort((a,b)=>b[1]-a[1]).slice(0,8).forEach(([k,v])=>{
        const el = document.createElement('div');
        el.className = 'small';
        el.style.marginBottom='6px';
        el.textContent = `${k.replace(/^c:/,'chat:').replace(/^s:/,'sub:').replace(/^q:/,'queue:')} — ${v} ticket(s)`;
        topSubscribersEl.appendChild(el);
      });

      // Counter performance: prefer analytics/serviceEvents.counter or counter field
      const counterStats = {};
      serviceEvents.forEach(e => {
        const key = e.counter || e.counterId || e.counterName || (e.counter && String(e.counter)) || 'unknown';
        counterStats[key] = (counterStats[key] || 0) + 1;
      });
      // fallback approximate from queue counterId values
      if (Object.keys(counterStats).length === 0) {
        queues.forEach(q => {
          if (q.counterId) counterStats[q.counterId] = (counterStats[q.counterId]||0)+1;
        });
      }
      // render counters
      counterPerfWrap.innerHTML = '';
      Object.entries(counterStats).sort((a,b)=>b[1]-a[1]).forEach(([k,v])=>{
        const wrap = document.createElement('div');
        wrap.style.display='flex'; wrap.style.justifyContent='space-between'; wrap.style.padding='6px 0';
        wrap.innerHTML = `<div style="font-weight:700">${k}</div><div class="small">${v} served</div>`;
        counterPerfWrap.appendChild(wrap);
      });

      // Save for CSV export: attach to element
      exportCsvBtn.dataset.csv = createCsvForExport(queues, serviceEvents);

      // Completed rendering
    } // end computeAndRenderAll

    function createCsvForExport(queues, serviceEvents) {
      // produce a simple CSV: ticketId, queueId, counterId, status, timestamp (ISO), chatId, servedAt (ISO), serviceMin
      const rows = [['ticketKey','queueId','counterId','status','timestamp','chatId','servedAt','serviceMin']];
      queues.forEach((q) => {
        const tkey = q.queueId || '';
        const ts = parseTs(q.timestamp);
        rows.push([q.queueId || '', q.queueId || '', q.counterId || '', q.status || '', ts ? new Date(ts).toISOString() : '', q.chatId || '', '', '']);
      });
      serviceEvents.forEach(e => {
        const served = parseTs(e.servedAt);
        const req = parseTs(e.requestedAt);
        const minutes = (e.serviceMs && Number.isFinite(e.serviceMs)) ? Math.round(e.serviceMs/60000) : (served && req ? minsBetween(req, served) : '');
        rows.push([e.ticketId || '', '', e.counter || '', 'served', req ? new Date(req).toISOString() : '', '', served? new Date(served).toISOString() : '', minutes]);
      });
      return rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
    }

    // ---------- realtime listeners ----------
    async function fetchAllOnceAndRender() {
      try {
        const [qSnap, seSnap, cSnap, sSnap, aSnap, qsSnap] = await Promise.all([
          get(ref(db, 'queue')),
          get(ref(db, 'analytics/serviceEvents')),
          get(ref(db, 'counters')),
          get(ref(db, 'settings')),
          get(ref(db, 'announcement')),
          get(ref(db, 'queueSubscriptions'))
        ]);
        const qObj = qSnap.exists() ? qSnap.val() : {};
        const seObj = seSnap.exists() ? seSnap.val() : {};
        const cObj = cSnap.exists() ? cSnap.val() : {};
        const sObj = sSnap.exists() ? sSnap.val() : {};
        const aObj = aSnap.exists() ? aSnap.val() : {};
        const qsObj = qsSnap.exists() ? qsSnap.val() : {};
        computeAndRenderAll(qObj, seObj, cObj, sObj, aObj, qsObj);
      } catch (err) {
        console.error('fetchAllOnce error', err);
      }
    }

    // realtime subscription: queue / analytics/serviceEvents / counters / settings / announcement / queueSubscriptions
    onValue(ref(db, 'queue'), async (snap) => {
      const qObj = snap.exists() ? snap.val() : {};
      // also fetch serviceEvents and others on change (so analytics reflect together)
      try {
        const [seSnap, cSnap, sSnap, aSnap, qsSnap] = await Promise.all([
          get(ref(db, 'analytics/serviceEvents')),
          get(ref(db, 'counters')),
          get(ref(db, 'settings')),
          get(ref(db, 'announcement')),
          get(ref(db, 'queueSubscriptions'))
        ]);
        computeAndRenderAll(qObj, seSnap.exists()?seSnap.val():{}, cSnap.exists()?cSnap.val():{}, sSnap.exists()?sSnap.val():{}, aSnap.exists()?aSnap.val():{}, qsSnap.exists()?qsSnap.val():{});
      } catch (e) { console.warn('onValue combined read failed', e); }
    });

    onValue(ref(db, 'analytics/serviceEvents'), (snap) => {
      // serviceEvents changed -> refetch queue to combine view
      get(ref(db, 'queue')).then(qSnap => {
        computeAndRenderAll(qSnap.exists()?qSnap.val():{}, snap.exists()?snap.val():{}, {}, {}, {}, {});
      }).catch(()=>{ computeAndRenderAll({}, snap.exists()?snap.val():{}, {}, {}, {}, {}); });
    });

    // counters/settings/announcement/queueSubscriptions listeners for UI previews
    onValue(ref(db, 'counters'), (snap) => {
      const obj = snap.exists()?snap.val():{};
      const active = Object.values(obj).filter(c => c && c.active===true).length;
      activeCountersEl.textContent = active;
    });
    onValue(ref(db, 'settings'), (snap) => {
      if (!snap.exists()) return;
      const s = snap.val();
      mainTitleEl.textContent = s.mainTitle || '—';
      introTextEl.textContent = s.introText || '—';
    });
    onValue(ref(db, 'announcement'), (snap) => {
      const a = snap.exists()?snap.val():{};
      announceCountEl.textContent = a?.chatIds ? Object.keys(a.chatIds).length : 0;
      botTokenPresentEl.textContent = a?.botToken ? 'Yes' : 'No';
    });

    // ---------- UI actions ----------
    refreshBtn.addEventListener('click', () => fetchAllOnceAndRender());
    exportCsvBtn.addEventListener('click', () => {
      const csv = exportCsvBtn.dataset.csv || '';
      if (!csv) return alert('No CSV generated yet — refresh first.');
      const blob = new Blob([csv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `queuejoy_export_${new Date().toISOString().slice(0,10)}.csv`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    // initial load
    fetchAllOnceAndRender();
  </script>
</body>
</html>
